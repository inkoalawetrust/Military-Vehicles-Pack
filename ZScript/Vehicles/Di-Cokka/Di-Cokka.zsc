//TODO:
//Make it so the turret rises up and then down to shoot. Might not do this, since unlike in Metal Slug, the Di-Cokka can aim up and down here.
//In MS, the Di-Cokka can fire a burst of 3 shells, maybe add this as a somewhat rare alt attack ?
//Make the turret create a warning zone when it's about to fire, that warps to wherever its' aiming. To warn marines to avoid the firing spot.
//Make the prop and wrecked prop versions, the latter should also a have a variable to turn on the fire particles permanently.

//The Di-Cokka has very weak stats compared to the other vehicles, and especially future ones. This is because it's a cartoony vehicle from Metal Slug.
Class MVP_DiCokka : MVP_BaseVehicle
{
	Default
	{
		//$Title Di-Cokka
		//$Category Vehicles/Di-Cokka
		//$Sprite MSV1Z1
		Health 600;
		GibHealth 100;
		Radius 48;
		Height 60;
		Speed 8;
		FastSpeed 12;
		CameraHeight 32;
		DeathHeight 60;
		FriendlySeeBlocks 64; //Same as the default despite being an armed vehicle. Because it's shells are much slower.
		MaxTargetRange 8192;
		MaxStepHeight 24;
		Mass 10000;
		XScale 0.9;
		YScale 0.75;
		Tag "Type II AFV \"Di-Cokka\"";
		Obituary "%o was blown up by a Rebel tank.";
		MVP_BaseVehicle.VehicleTurret "MVP_DiCokkaTurret";
		MVP_BaseVehicle.MaxCorpseRadius 24; //Only crushes human sized objects. And only incidentally.
		MVP_BaseVehicle.MaxCorpseHeight 60;
		
		-NoPain; //This vehicle CAN feel pain.
		PainChance 30;
		PainChance "Autocannon", 55;
		PainChance "RifleBullet", 20;
		PainChance "MarineHMG", 10;
		PainChance "MarineRifle", 25;
		PainThreshold 10;
		PainSound "Vehicle/Di-Cokka/Pain";
		DeathSound "Vehicle/Di-Cokka/Death";
		
		//Doesn't have any damage factors. It's a cartoon vehicle, plus it's already overall weaker than the other vehicles like the APC.
		DamageFactor "Melee", 1;
		DamageFactor "Electric", 1;
		DamageFactor "ExplosiveImpact", 1;
		DamageFactor "Explosion", 1;
		DamageFactor "Explosive", 1;
		DamageFactor "Grenade", 1;
		DamageFactor "HitScan", 1; //The generic damage type of hitscan attacks.
		DamageFactor "Fire", 1;
		DamageFactor "Crush", 1;
		DamageFactor "Disintegrate", 1;
		DamageFactor "Railgun", 1;
		DamageFactor "Falling", 1;
		//Damage factors specific to the Smart Marines.
		DamageFactor "MarineHMG", 1;
		DamageFactor "MarineGrenade", 1;
		DamageFactor "MarineRifle", 1;
		//Vehicle damage factors
		DamageFactor "Autocannon", 1;
		DamageFactor "RifleBullet", 1;
	}
	
	String User_Color; //The Di-Cokkas' color.
	Bool User_TargetPrediction; //If the Di-Cokka should be able to lead its' shots. By default it doesn't.
	Bool User_NoCorpseCrush; //If true, the Di-Cokka won't crush small corpses it happens to drive over.
	
	Bool ExtremePain; //The Di-Cokka flinched from a very strong attack.
	Int ForcedFireParticlesCount; //If this has a value, then the Di-Cokka is forced to spawn this amount of particles even when dead.
	Double FireParticleFrequency; //How often fire particles spawn.
	
	Override Void SpawnVehicleTurret ()
	{
		Super.SpawnVehicleTurret();
		
		If (Turret) Turret.bNoTargetPrediction = !User_TargetPrediction;
	}
	
	Override Void UserVariableDefaults()
	{
		If (User_RetreatDistance == 0) User_RetreatDistance = 512;
		Super.UserVariableDefaults();
	}

	
	Override Void SpawnHeadlights ()
	{
		Headlights.Push (SpawnVehicleHeadlight (Self,(32,32,24),spotlightangles:(20,30)));
		Headlights.Push (SpawnVehicleHeadlight (Self,(32,-32,24),spotlightangles:(20,30)));
	}
	
	//TODO: Add back the code for this virtual once the turret can even aim and shoot.
	Override Bool StayStillAndShoot(Actor CheckSightFrom) {Return False;}
	
	//This simply returns true so that the vehicle doesn't always run away from all enemies. Even if the chassis itself technically has no attack.
	Override Bool CanAttack()
	{
		If (Turret)
			Return True;
		
		Return False;
	}
	
	Override Void Tick()
	{
		Super.Tick();
		
		If (IsFrozen()) Return;
		If (GetAge() % 16*FireParticleFrequency == 0)
		{
			//Spawn fire particles when the vehicle is weakened enough.
			If (ForcedFireParticlesCount || !IsDead (Self) && Health <= SpawnHealth()/2.5)
			{
				Actor Particle = Spawn ("MVP_DiCokkaFireParticle",Vec3Offset (FRandom (Radius, -Radius),FRandom (Radius, -Radius),FRandom (0, Height)),ALLOW_REPLACE);
				Particle.Scale.X = Particle.Scale.Y = FRandom (0.4,0.55);
				Particle.bXFlip = Random (False,True);
				If (ForcedFireParticlesCount) ForcedFireParticlesCount--;
			}
		}
	}
	
	Override Void PostBeginPlay ()
	{
		TurretOffsets = (0,0,-0.25);
		FireParticleFrequency = 1.0;
		Super.PostBeginPlay();
		
		//Copied from how the Smart Marines' color variable is handled.
		If (!User_Color || User_Color ~== ""){} //Don't run the code if User_Color is empty.
		Else
		{
			//Handles the random color choice that is performed if the color name given is "Random".
			If (User_Color ~== "Random")
			{
				Static Const String ColorArray[] = {"White","Black","Yellow","Orange","Green","Default"}; //Contains all the valid color names.
				
				User_Color = ColorArray[Random(0,ColorArray.Size()-1)]; //Randomly picks a color string.
			}
			
			If (!(User_Color ~== "Default"))
			{
				A_SetTranslation (String.Format("DiCokka_%s", User_Color));
				If (Turret) Turret.A_SetTranslation (String.Format("DiCokka_%s", User_Color));
			}
			Else
			{
				A_SetTranslation ('');
				If (Turret) Turret.A_SetTranslation ('');
			}
		}
	}
	
	Override Int DamageMobj (Actor Inflictor, Actor Source, Int Damage, Name MOD, Int Flags, Double Angle)
	{
		Int LeDamage = Super.DamageMobj (Inflictor, Source, Damage, MOD, Flags, Angle);
		
		//If DamageMobj decided that the chassis should flinch. Then make the turret flinch as well. Unless its' already flinching.
		If (InStateSequence(CurState.NextState,FindState ("Pain")))
		{
			If (LeDamage >= 50) ExtremePain = True; //Got hurt by a very damage attack, so flinch for longer.
			If (Turret && !IsInState (Turret,"Pain"))
			{A_Log ("The turret is hurt too");
				If (Turret Is "MVP_DiCokkaTurret") MVP_DiCokkaTurret(Turret).ExtremePain = ExtremePain;
				Turret.TriggerPainChance (MOD,True);
			}
		}
		
		Return LeDamage;
	}
	
	Override Void Die (Actor Source, Actor Inflictor, Int DmgFlags, Name MeansOfDeath)
	{
		Super.Die (Source, Inflictor, DmgFlags, MeansOfDeath);
		If (Health < GetGibHealth())
		{
			ForcedFireParticlesCount = Random (24,64);
			FireParticleFrequency = 0.25;
		}
		Else
			ForcedFireParticlesCount = Random (8,24);
	}
	
	States
	{
		Spawn:
			MSV1 A 4
			{
				A_StopSound (CHAN_MOVING);
				A_StartSound("Vehicle/Di-Cokka/Idle",CHAN_IDLING,CHANF_LOOPING,0.4,0.8);
				bStandStill = True;
				A_LookEx (0,0,MaxTargetRange,DEFAULT_HEARDISTANCE);
				bStandStill = False;
			}
			Loop;
		//The hull is basically just a moving platform for the turret, so its' AI is just whatever MVP_Chase has.
		See:
			MSV1 AABBCCDDEEFF 2
			{
				A_StopSound (CHAN_IDLING);
				ActiveSound = Health >= SpawnHealth()/2.5 ? "Vehicle/Di-Cokka/Move" : "Vehicle/Di-Cokka/AltMove";
				A_StartSound (ActiveSound,CHAN_MOVING,CHANF_LOOPING,0.6,0.7);
				MVP_Chase (followdist:256);
				If (!User_NoCorpseCrush) MVP_CrushCorpses (1);
			}
			Loop;
		Pain:
			MSV1 # 20
			{
				A_StopSound (CHAN_IDLING);
				A_StopSound (CHAN_MOVING);
				A_StartSound (PainSound,CHAN_BODY);
			}
			MSV1 # 0 A_JumpIf (ExtremePain,1); //Flinch for a bit longer.
			Goto See;
			
			MSV1 # 16 {ExtremePain = False;}
			Goto See;
		//The Di-Cokka sinks down when it dies.
		Death:
			MSV1 R 0 A_SetSize (-1,Height-1);
			MSV1 R 8 A_StartSound (DeathSound,CHAN_BODY);
			MSV1 S 8 A_SetSize (-1,Height-2);
			MSV1 T 8 A_SetSize (-1,Height-3);
			MSV1 U 8 A_SetSize (-1,Height-2);
			MSV1 V 8 A_SetSize (-1,Height-1);
			MSV1 V -1;
			Stop;
		//Ditto, but the Di-Cokka explodes into a shower of metal debris soon after.
		XDeath:
			MSV1 R 0 A_SetSize (-1,Height-1);
			MSV1 R 8 A_StartSound (DeathSound,CHAN_BODY);
			MSV1 S 8 A_SetSize (-1,Height-2);
			MSV1 T 8 A_SetSize (-1,Height-3);
			MSV1 U 8 A_SetSize (-1,Height-2);
			MSV1 V 8 A_SetSize (-1,Height-1);
			MSV1 V Random (35,35*5); //Wait for it.
			MSV1 V 0
			{
				SmokeCounter = Random (64,192);
				Bool b; Actor Debris;
				
				Debris = Spawn ("MVP_MetalSlugExplosion",Pos);
				If (Debris)
				{
					Debris.A_SetRenderStyle (1.0,STYLE_NORMAL);
					Debris.A_SetScale(2.5);
					Debris.MeleeRange = 128;
				}
				
				For (Int I; I <= SmokeCounter; I++)
				{
					[B, Debris] = A_SpawnItemEx ("MVP_DiCokkaDebris",FRandom (Radius,-Radius),FRandom(Radius,-Radius),FRandom (0,Height),FRandom (-32,32),FRandom (-32,32),FRandom (4,16));
					If (Debris)
					{
						Debris.Scale *= FRandom (0.2,0.7);
						Debris.bXFlip = Random (False,True);
					}
				}
			}
			Stop;
	}
}

Class MVP_DiCokkaTurret : MVP_BaseTurret
{
	Default
	{
		Health 300;
		Radius 32;
		Height 24;
		XScale 0.9;
		YScale 0.75;
		Mass 2000;
		DeathHeight 24;
		FriendlySeeBlocks 48;
		MaxTargetRange 6144;
		Tag "Di-Cokka Turret";
		Obituary "%o was blown up by a Rebel tank.";
		MVP_BaseTurret.MaximumPitch -20;
		MVP_BaseTurret.MinimumPitch 10;
		+MVP_BaseTurret.TransferDamage;
		
		//Copied from the hull.
		-NoPain; //This vehicle CAN feel pain.
		PainChance 30;
		PainChance "Autocannon", 55;
		PainChance "RifleBullet", 20;
		PainChance "MarineHMG", 10;
		PainChance "MarineRifle", 25;
		PainThreshold 10;
		PainSound "Vehicle/Di-Cokka/Pain";
		DeathSound "Vehicle/Di-Cokka/Death";
		AttackSound "Vehicle/Di-Cokka/Shoot";
		MVP_BaseTurret.TurnSound "Vehicle/APC/TurretTurn";
		
		//Doesn't have any damage factors. It's a cartoon vehicle, plus it's already overall weaker than the other vehicles like the APC.
		DamageFactor "Melee", 1;
		DamageFactor "Electric", 1;
		DamageFactor "ExplosiveImpact", 1;
		DamageFactor "Explosion", 1;
		DamageFactor "Explosive", 1;
		DamageFactor "Grenade", 1;
		DamageFactor "HitScan", 1; //The generic damage type of hitscan attacks.
		DamageFactor "Fire", 1;
		DamageFactor "Crush", 1;
		DamageFactor "Disintegrate", 1;
		DamageFactor "Railgun", 1;
		DamageFactor "Falling", 1;
		//Damage factors specific to the Smart Marines.
		DamageFactor "MarineHMG", 1;
		DamageFactor "MarineGrenade", 1;
		DamageFactor "MarineRifle", 1;
		//Vehicle damage factors
		DamageFactor "Autocannon", 1;
		DamageFactor "RifleBullet", 1;
	}
	
	Bool ExtremePain;
	
	Override Bool ShouldAttack(Bool NoStateJump)
	{
		If (!MVP_BaseTurret.ShouldAttack()) Return False;
		//If (Health <= SpawnHealth()/4)
			//Increase triple shot chance perhaps ?
		
		If (Target != Self && MVP_CheckMissileRange(Target) && !IsDead (Target) && IsHostile (Target) && DiCokkaLOFCheck())
		{
			If (!NoStateJump) SetStateLabel ("Fire");
			Return True;
		}
		
		Return False;
	}
	
	Override Void PostBeginPlay ()
	{
		Super.PostBeginPlay();
		
		MissileState = FindState ("Fire");
	}
	
	Bool DiCokkaLOFCheck()
	{
		Let Check = New ("MVP_ProjectileLOFCheck");
		
		Vector3 Direction = (AngleToVector(Angle, Cos(Pitch)), -Sin(Pitch));
		
		Double Distance = Target ? Distance3D (Target)+32 : MaxTargetRange;
		Check.Shooter = Self;
		Check.SplashRadius = 128;
		Check.PropHealthThreshold = 200;
		Check.Trace ((Pos.X,Pos.Y,Pos.Z+14),CurSector,Direction,Distance,0);
		
		If (Check.BadLOF)
		{a_log ("bad lof");
			bDontStayAround = True;
			Check.Destroy();
			Return False;
		}
		
		bDontStayAround = False;
		Check.Destroy();
		Return True;
	}
	
	States
	{
		Spawn:
			MSV1 A 0;
			MSV1 # 1
			{
				RotateToVehicle();
				A_LookEx (maxseedist:MaxTargetRange,DEFAULT_HEARDISTANCE);
				Frame = UpdateTurretElevation (10,6,8,8); //K, G, I, I
			}
			Goto Spawn+1;
		See:
			MSV1 # 1
			{a_log ("in the see state");
				A_FaceTarget (3,3,flags:FAF_MIDDLE);
				RotateToVehicle();
				A_Chase (Null,Null,CHF_DONTIDLE|CHF_DONTMOVE|CHF_NODIRECTIONTURN);
				MVP_Chase (MVPC_NOCHASE);
				UpdateTurretSnapTimer();
				Frame = UpdateTurretElevation (10,6,8,8); //K, G, I, I
			}
			Loop;
		//TODO: Add the 3 shot attack. Massively decrease the rate of fire to something reasonable, maybe also add a check so the tank only fires when the target is in the LOF.
		Fire:
			MSV1 ######## 1
			{
				A_FaceTarget (3,3,flags:FAF_MIDDLE);
				Frame = UpdateTurretElevation (10,6,8,8); //K, G, I, I
				//console.printf ("the pitch is %d",pitch);
			}
			//MSV1 # 0 A_JumpIf (!TargetInLOF(),"Fire"); //Wait for the target to be in the line of fire.
			MSV1 # 6
			{
				Bool B; Actor Proj;
				A_StartSound (AttackSound,CHAN_WEAPON,CHANF_OVERLAP,1.0,0.6);
				
				Int TurretVisualElevation = UpdateTurretElevation (11,7,9,9); //L, H, J, J
				
				//Spawn the standalone firing effect of the turret. But at the appropriate spawn height.
				Double FireEffectZ = 8;
				Switch (TurretVisualElevation)
				{
					Case 11: //Facing down
						FireEffectZ = 2;
						Break;
					Case 7:  //Facing forwards
						FireEffectZ = 8;
						Break;
					Case 9: //Facing up
						FireEffectZ = 24;
						Break;
					Default:
						Break;
				}
				[B,Proj] = A_SpawnItemEx ("MVP_DiCokkaShotEffect",60,zofs:FireEffectZ);
				If (Proj) Proj.A_SetScale (FRandom (1.1,1.75));
				Proj = Null;
				//======================================================================================
				
				Proj = A_SpawnProjectile ("MVP_DiCokkaShell",14,flags:CMF_AIMDIRECTION,Pitch); //TODO: Adjust the spawn height to fit the cannons' height.
				HandleTargetPrediction (Proj,(0.1,-0.1),(0.15,-0.15),128);
				Frame = TurretVisualElevation;console.printf ("the pitch is %d",pitch);
			}
			MSV1 ######## 2
			{
				//If you have no target, or it's dead.
				If (!Target || IsDead (Target))
				{
					A_ClearTarget();
					LookForPlayers (True); //Look for a new target.
				}
				
				If (ElevationState != ELEVATION_INBOUNDS) A_ClearTarget();
				
				If (!DiCokkaLOFCheck())
				{a_log ("vibe check failed");
					A_ClearTarget();
					Return ResolveState ("See");
				}
				
				HandleChaseTimer();
				
				Frame = UpdateTurretElevation (10,6,8,8); //K, G, I, I
				Return State (Null);
			}
			MSV1 # 0 A_MonsterRefire (25,"See");
			Loop;
		Pain:
			TNT1 A 0
			{a_log ("oof ouch");
				//Might make the turret able to be placed without the Di-Cokka itself or something.
				If (!Master)
					A_StartSound (PainSound,CHAN_BODY,CHANF_OVERLAP);
			}
			MSV1 M 6;
			TNT1 A 0 A_JumpIf (ExtremePain,3);
			MSV1 N 12;
			MSV1 M 6;
			Goto See;
			//If in extreme pain, push the turret back even more.
			MSV1 N 6 a_log ("aaaaaaaaaaaaaaa");
			MSV1 OP 8;
			MSV1 Q Random (24,48); //K.O.
			MSV1 Q 0
			{
				ExtremePain = False;
				Angle -= 135; //Change the turrets' angle to match the angle it visually ended up at.
				TurretSnapDelay = 70; //Give the turret time to slowly rotate around, instead of snapping back to its masters' angle.
			}
			//MSV1 G 200; //DEBUG: Just here to make sure the angle change above works.
			Goto See;
		Death:
			MSV1 WXY 10;
			MSV1 Y -1;
			Stop;
	}
}

//Textured particles defined in ANIMDEFS all animate in unison. So they are useless for this.
Class MVP_DiCokkaFireParticle : Actor
{
	Default
	{
		+Bright;
		+NoBlockmap;
	}
	
	//Fun fact, an empty or totally custom tick override doesn't actually provide a noticeable performance improvement.
	Override Void Tick()
	{
		If (IsFrozen()) Return;
		// Copied from FastProjectile.
		if (tics != -1)
		{
			if (tics > 0) tics--;
			while (!tics)
			{
				if (!SetState (CurState.NextState))
				{ // mobj was removed
					return;
				}
			}
		}
	}
	States
	{
		Spawn:
			MSX3 ABDEFGHIJKLMNOPQRSTUVXYZ 3;
			Stop;
	}
}

Class MVP_DiCokkaDebris : Actor
{
	Default
	{
		Radius 4;
		Height 8;
		+ThruActors;
	}
	Override Void Tick()
	{
		Super.Tick();
		If (Pos.Z <= FloorZ || BlockingLine)
		{
			If (Frame >= 7 && Random (0,256) < 48) A_StartSound ("Vehicle/Di-Cokka/MetalHit",volume:FRandom (0.3,0.8),ATTN_STATIC);
			Destroy();
		}
	}
	States
	{
		Spawn:
			TNT1 A 0 NoDelay A_Jump (255,"Debris1","Debris2","Debris3");
		Debris1:
			MSDB ABCDEFGH 3;
			Loop;
		Debris2:
			MSDB IJKLMNOP 3;
			Loop;
		Debris3:
			MSDB QRSTUVWX 3;
			Loop;
	}
}

Class MVP_MetalSlugExplosion : MVP_BigExplosion
{
	States
	{
		Spawn:
			MSX1 A 2 NoDelay
			{
				A_Explode (MaxTargetRange,Damage,XF_HURTSOURCE|XF_NOTMISSILE|XF_EXPLICITDAMAGETYPE,True,MeleeRange,damagetype:'Explosion');
				A_QuakeEx (2,2,2,35*5,0,768,flags:QF_SCALEDOWN|QF_3D);
				A_StartSound ("SFX/MSExplosion",CHAN_AUTO,attenuation:0.2);
			}
			MSX1 B 2;
			MSX2 CDEFGHIJ 4;
			MSX2 KLMNOPQRSTUVWX 6;
			Stop;
	}
}

Class MVP_DiCokkaShotEffect : Actor
{
	Default
	{
		+NoInteraction;
	}
	States
	{
		Spawn:
			MSFX AB 1 Bright Light ("MSExplosion2");
			MSFX CEGIKMO 2; //Removed half the frames for speed.
			//MSFX CDEFGHIJKLMNO 2; //All the fire effect frames.
			Stop;
	}
}

Class MVP_DiCokkaShell : MVP_BaseProjectile
{
	Default
	{
		Speed 25;
		FastSpeed 35;
		Damage 30;
		ProjectileKickback 128;
		Scale 0.9; //Scaled just right so that the shell visually fits into the barrel.
		Obituary "%o was blown up by a Rebel tank.";
		Decal "BigScorch";
		DamageType "Autocannon"; //Using a tank shell damage type may lead to weird results, considering my future plans with the mod. I may change it to an HEShell type or something though.
		+StrifeDamage;
	}
	
	Void DoDiCokkaShellSplash (Int LiquidType, Bool UpsideDown = False)
	{
		If (LiquidType == LIQUID_NONE) Return;
		HitLiquid = True;
		Actor Splash = SpawnLiquidSplash (LiquidType,explosiondamage:96,48,0,'Explosive', True);
		
		Double Size = FRandom (1.5,2.0);
		Splash.Scale.X = Splash.Scale.Y = (UpsideDown ? -Size : Size);
		Splash.bXFlip = Random (False,True);
	}
	
	DynamicLight Light;
	Bool HitLiquid; //Removes the shell if it hit a liquid texture.
	States
	{
		Spawn:
			MSPJ ABCD 2 Bright;
			MSPJ EFGGFE 2;
			MSPJ DCBA 2 Bright;
			Loop;
		Death:
			TNT1 A 0
			{
				//The floor was hit.
				If (Pos.Z <= FloorZ)
					DoDiCokkaShellSplash(CheckLiquid(FloorPic));
				//The ceiling was hit.
				Else If (Pos.Z + Height >= CeilingZ)
					DoDiCokkaShellSplash(CheckLiquid(CeilingPic),True);
				
				If (HitLiquid) Destroy(); //Splash was spawned, so just delete yourself.
				
				If (Pos.Z + Height >= CeilingZ) Scale.Y = -1.0; //If a ceiling was hit, invert the explosion.
				
				If (Pos.Z <= FloorZ + 24) SetOrigin ((Pos.XY,FloorZ),False);
			}
			MSX1 A 1 Bright A_SetScale (1.3);
			MSX1 B 1 Bright
			{
				Light = DynamicLight(Spawn ("PointLight",Vec3Offset (0,0,8)));
				If (Light)
				{
					Light.Args[3] = 128; //Intensity
					Light.Args[0] = 248; Light.Args[1] = 206; Light.Args[2] = 96; //RGB
				}
				
				A_StartSound ("SFX/MSExplosion",volume:0.7,0.5);
				MakeAlliesImmuneToExplosion (128);
				A_Explode (128,128,XF_EXPLICITDAMAGETYPE,True,32,damagetype:'Explosive');
				RemoveAllyExplosionImmunity();
			}
			MSX1 CDEFGHIJKLMNOPQR 2 Bright {If (Light) Light.Args[3]-= 5;}
			MSX1 STUVW 3 {If (Light) Light.Args[3]-= 5;}
			MSX1 XYZ[] 1 {If (Light) Light.Args[3]-= 5;}
			MSXL ] 0 {If (Light) Light.Destroy();}
			Stop;
	}
}
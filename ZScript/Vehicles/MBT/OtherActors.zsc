Class MVP_MBTFireEffect : KAI_MixinActor
{
	Default
	{
		RenderStyle "Add";
		DamageType "Explosive";
		MaxTargetRange 224; //The maximum range of the explosion.
		MeleeRange 96; //The range around the explosion in which actors take it's full damage.
		Damage 500; //The damage of the explosion, this property can only be changed with the SetDamage() function.
		RadiusDamageFactor 0.35; //How much distance off the ground affects the firing effect. 1 is a direct conversion of: 1 MU of the ground = 1 less dust cloud
		ReactionTime 64; //How much smoke to spawn.
		Threshold 256; //How far to spawn dust.
		
		+NeverTarget;
		+NotAutoaimed;
		+Bright;
		+NoGravity;
		+AlwaysPuff; //Spawn default shockwave ring.
	}
	DynamicLight Light;
	States
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
				If (bAlwaysPuff) //Can be set to false when spawning to not spawn a ring, and/or spawn your own.
				{
					Actor Ring = Spawn ("MVP_ShockwaveRing",Pos);
					If (Ring)
					{
						Ring.Speed = 1;
						Ring.FloatSpeed = 0.1;
						Ring.ReactionTime = (GameTicRate/2);
					}
				}
				
				A_StartSound ("SFX/BigExplosion",CHAN_VOICE,attenuation:0.1);
				A_QuakeEx (2,2,2,16,0,1024,"world/quake",QF_SCALEDOWN|QF_GROUNDONLY,falloff:128,rollintensity:2);
				Light = DynamicLight(Spawn("DynamicLight",Pos));
				If (Light)
				{
					Light.Args[3] = 192;
					Light.Args[0] = 231; //RGB
					Light.Args[1] = 207;
					Light.Args[2] = 13;
				}
				
				Actor Duster = Spawn ("MVP_GroundDustSpawner",Pos);
				//Pass parameters to spawner.
				Duster.RadiusDamageFactor = RadiusDamageFactor;
				Duster.ReactionTime = ReactionTime;
				Duster.Threshold = Threshold;
			}
			MBTF A 1
			{
				Light.Args[3] += 24;
				MakeAlliesImmuneToExplosion (Target, MaxTargetRange);
				A_Explode (Damage,MaxTargetRange,0,True,MeleeRange);
				RemoveAllyExplosionImmunity();
			}
			MBTF BCD 1 {Light.Args[3] += 24;}
			MBTF EF 2 {Light.Args[3] += 24;}
			MBTF G 2 {Light.Args[3] = 96;}
			TNT1 A 0 {If (Light) Light.Destroy();} //Fire over, get rid of the light.
			MBTF HI 2;
			Stop;
	}
}

//Spawns ground dust around an explosion.
Class MVP_GroundDustSpawner : Actor
{
	Default
	{
		RadiusDamageFactor 0.35; //How much distance off the ground affects the firing effect. 1 is a direct conversion of: 1 MU of the ground = 1 less dust cloud
		ReactionTime 64; //How much smoke to spawn.
		Threshold 256; //How far to spawn dust.
	}
	Override Void PostBeginPlay ()
	{
		Super.PostBeginPlay();
		Int SmokeFactor = (Pos.Z - FloorZ) * RadiusDamageFactor;
		Int DustCount = ReactionTime - SmokeFactor; //Decrement the dust to spawn the further off the ground the blast is.
		Console.Printf ("Ground height: %.2f, Dust count %d, SmokeFactor %d",(Pos.Z - FloorZ),DustCount,SmokeFactor);
		Actor Dust;
		Class<Actor> DustClasses[] = {"MVP_GroundDust","MVP_GroundDust2","MVP_GroundDust3"};
		//Spawn random dust actors on the ground, the closer to the ground, the more dust spawned.
		For (Int I = DustCount; 0 <= I; I--)
		{
			Dust = Spawn (DustClasses[Random(0,DustClasses.Size()-1)],Vec3Offset (FRandom (Threshold,-Threshold),FRandom(Threshold,-Threshold),0));
			Dust.SetOrigin ((Dust.Pos.XY,GetZAt (Dust.Pos.X,Dust.Pos.Y,flags:GZF_ABSOLUTEPOS)),False);
			//If the dust is out of bounds, or the height difference from the explosions' ground level is too high, remove it.
			If (!Level.IsPointInLevel (Dust.Pos) || (FloorZ - Dust.Pos.Z) > 64 || Dust.Pos.Z > Pos.Z+16|| Distance2DSquared (Dust) > Threshold*Threshold)
				Dust.Destroy();
			
			Dust.Scale *= FRandom (0.6,1.25);
			Dust.Speed *= FRandom (0.75,1.25); //Set roll speed, doesn't work for MVP_GroundDust3 though, which doesn't use it.
		}
		Destroy();
	}
}

//Gray circular cloud.
Class MVP_GroundDust : Actor
{
	Default
	{
		Speed 2;
		RenderStyle "Add";
		+NoBlockmap;
		+NoInteraction;
		+NoGravity;
		+RollSprite;
	}
	
	Override Void PostBeginPlay ()
	{
		Super.PostBeginPlay();
		If (!bSynchronized) Tics = 1 + (Random(0,255) % Tics); //Randomize the dust a bit.
	}
	
	States
	{
		Spawn:
			SMK3 ABCDEFGHIJKLM 2 A_SetRoll (Roll+Speed);
			Stop;
	}
}

//Dark circular cloud.
Class MVP_GroundDust2 : Actor
{
	States
	{
		Spawn:
			SMK6 ABCDEFGHIJKLM 2 A_SetRoll (Roll+Speed);
			Stop;
	}
}

//Light gray dust puff.
Class MVP_GroundDust3 : Actor
{
	States
	{
		Spawn:
			SMOK ABCDEFGHIJKLMNOPQR 2;
			Stop;
	}
}

Class MVP_HEATShell : MVP_BaseProjectile
{
	Default
	{
		Radius 16;
		Height 22;
		Speed 300;
		FastSpeed 350;
		XScale 0.5;
		YScale 0.416666; //0.5 / 1.2
		DamageFunction (Random(600,1000));
		ProjectileKickback 512;
		Obituary "%o was sent straight to god by a HEAT shell";
		Decal "HEATScorch";
		DamageType "Shell";
		KAI_BaseProjectile.TrailActor "MVP_Tracer";
		KAI_BaseProjectile.InitialTrailsSkipped 24;
		KAI_BaseProjectile.MaxTrails 256;
	}
	Void DoSplash (Int LiquidType, Bool UpsideDown = False)
	{
		If (LiquidType == LIQUID_NONE) Return;
		HitLiquid = True;
		Actor Splash = SpawnLiquidSplash (LiquidType,"SFX/AltLiquidExplosion",attenuation:0.25,1000,384,128,'Explosive', True);
		
		Splash.A_QuakeEx (1,1,1,24,0,1024,"",QF_SCALEDOWN|QF_GROUNDONLY,rollintensity:1);
		Double Size = FRandom (4,6);
		Splash.Scale.X = Splash.Scale.Y = (UpsideDown ? -Size : Size);
		Splash.Scale.X *= UpsideDown ? FRandom (-1.2,-2.5) : FRandom (1.2,2.5);
		Splash.bXFlip = Random (False,True);
	}
	Override Void Tick()
	{
		Super.Tick();
		If (IsFrozen()) Return;
		If (bMissile) PlayFlybySound ("SFX/BulletFlyby",CHAN_VOICE,CHANF_NOSTOP,1,2.0,distance:600);
	}
	Bool HitLiquid;
	DynamicLight Light;
	States
	{
		Spawn:
			MBTP A 0 NoDelay
			{
				A_SpawnItemEx ("MVP_HEATShellPetal",yvel:FRandom(2,4));
				A_SpawnItemEx ("MVP_HEATShellPetal",yvel:FRandom(-2,-4));
			}
			MBTP # 1
			{
				A_FaceMovementDirection ();
				Frame = UpdateProjectileElevation (2,2,0,1,1); //C, C, A, B, B
			}
			Wait;
		Death:
			TNT1 A 1
			{
				//The floor was hit.
				If (Pos.Z <= FloorZ)
					DoSplash(CheckLiquid(FloorPic));
				//The ceiling was hit.
				Else If (Pos.Z + Height >= CeilingZ)
					DoSplash(CheckLiquid(CeilingPic),True);
				
				If (HitLiquid) Destroy(); //Splash was spawned, so just delete yourself.
			}
			TNT1 A 0
			{
				A_SetScale (1,1);
				A_SetRenderStyle (1.0,Style_Add);
				If (Pos.Z + Height >= CeilingZ) Scale.Y = -1; //If a ceiling was hit, invert the explosion.
				Else If (Pos.Z >= FloorZ+88) Return ResolveState ("Death.Air"); //If the explosion happened above 24 map units from the ground, trigger the air explosion.
				Return State (Null);
			}
			TNT1 A 0
			{
				SetZ (FloorZ); //Stick to the ground to explode properly.
				Light = DynamicLight(Spawn("DynamicLight",Pos));
				If (Light)
				{
					Light.Args[3] = 128;
					Light.Args[0] = 231; //RGB
					Light.Args[1] = 207;
					Light.Args[2] = 13;
				}
				Actor Ring = Spawn ("MVP_ShockwaveRing",Pos);
				If (Ring)
				{
					Ring.Speed = 1;
					Ring.FloatSpeed = 0.1;
					Ring.ReactionTime = (GameTicRate/2);
				}
				A_QuakeEx (3,3,3,GameTicRate*2,0,2048,"",QF_SCALEDOWN|QF_GROUNDONLY,falloff:128,rollintensity:3);
				A_StartSound ("SFX/BigExplosion",flags:CHANF_OVERLAP,attenuation:0.2);
				MakeAlliesImmuneToExplosion (Target, 512);
				A_Explode (1200,512,XF_EXPLICITDAMAGETYPE,True,256,damagetype:"Explosive");
				RemoveAllyExplosionImmunity();
				
				Actor Duster = Spawn ("MVP_GroundDustSpawner",Pos);
				Duster.ReactionTime = 128;
				Duster.Threshold = 512;
			}
			MBTF JKL 1 {Light.Args[3] += 48;}
			MBTF MNO 4 {Light.Args[3] += 48;}
			MBTF P 6 {Light.Args[3] += 48;}
			MBTF Q 16 {If (Light) Light.Destroy();}
			Stop;
		Death.Air:
			TNT1 A 0
			{
				Actor Boom = Spawn ("MVP_MBTFireEffect",Pos);
				Boom.Scale *= 1.5;
				Boom.Target = Target;
				Boom.MaxTargetRange = 512;
				Boom.MeleeRange = 256;
				Boom.SetDamage(1500);
			}
			Stop;
	}
}

Class MVP_APFSDSShell : MVP_BaseProjectile
{
	Default
	{
		Radius 16;
		Height 22;
		Speed 400;
		FastSpeed 500;
		XScale 0.5;
		YScale 0.416666; //0.5 / 1.2
		DamageFunction (2500);
		ProjectileKickback 512;
		RipperLevel 12;
		
		KAI_BaseProjectile.RipDepth 32;
		KAI_BaseProjectile.TrailActor "MVP_Tracer";
		KAI_BaseProjectile.InitialTrailsSkipped 24;
		KAI_BaseProjectile.MaxTrails 256;

		Obituary "%o was penetrated by a depleted uranium rod";
		Decal "50CalChip";
		DamageType "APShell";
		+HitTracer; //Store the actor that killed the round as the tracer, used by the god mode code.
		+ExtremeDeath;
		+FoilInvul;
		+FoilBuddha;
		+CausePain;
		+Ripper;
		+KAI_BaseProjectile.RipOnce;
	}
	
	Override Void TrailSpawn (Actor Trail)
	{
		Super.TrailSpawn (Trail);
		If (!Trail) Return;
		
		Trail.A_SetTranslation ("Tracer_White"); //Cum blast
	}
	
	//P_RipperBlood() is not exposed to ZScriot, like most useful functions apparently. So I had to copy it here for the DU dart.
	//It does ignore the cl_bloodtype checks however, since P_DrawSplash2 isn't exposed either.
	Void ShitOutBlood (Actor AnnihilatedRemains)
	{
		Let Blud = AnnihilatedRemains.GetBloodType(0);
		
		Double XO = Random2 [pr_ripperblood](255) / 8.;
		Double YO = Random2 [pr_ripperblood](255) / 8.;
		Double ZO = Random2 [pr_ripperblood](255) / 8.;
		Vector3 BloodPos = Vec3Offset (XO,YO,ZO);
		
		If (Blud)
		{
			Actor Mo = Spawn (Blud,BloodPos);
			If (AnnihilatedRemains.bPuffGetsOwner) Mo.Target = AnnihilatedRemains;
			If (GameInfo.GameType == GAME_HERETIC) Mo.bNoGravity;
			Mo.Vel.X = Vel.X / 4; //Natively it's divided by two. But that's too fast for the APFSDS shell.
			Mo.Vel.Y = Vel.Y / 4;
			Mo.Tics = Random2 [pr_ripperblood](255) & 3;
			
			If (!Mo.bDontTranslate)
				Mo.Translation = AnnihilatedRemains.BloodTranslation;
		}
	}
	
	Override Int SpecialMissileHit (Actor Victim)
	{
		Int Num = Super.SpecialMissileHit(Victim);
		
		If (!Victim) Return 1; //Ignore apparently nonexistent victim.
		
		//DEBUG: How much damage does the tank get from its' own shells.
		//console.printf ("heat impact %d, heat blast %d, heat total %d",victim.ApplyDamageFactor("Shell",1000),victim.ApplyDamageFactor("Explosive",1200),
		//(victim.ApplyDamageFactor("Shell",1000)+victim.ApplyDamageFactor("Explosive",1200)));
		//console.printf ("apfsds damage %d",getmissiledamage(0,0));
		//console.printf ("victim is %s",victim.getclassname());
		//Godkilling handling.
		bNoExtremeDeath = False;
		ProjectileKickback = Default.ProjectileKickback;
		If (Victim.Player) KilledCheater = False;
		
		If (Num == -1 && !Victim.bNoBlood && !Victim.bReflective && !bBloodlessImpact && !Victim.bInvulnerable && !Victim.bDormant)
		{a_log ("My blood ! He-he punched out ALL my blood !");
			For (Int I = 128; I >= 0; I--)
				ShitOutBlood (Victim);
		}
		
		Bool HostileVictim = IsHostileToShooter (Victim);
		
		//Skill issue.
		If (Victim.Player && HostileVictim && (Victim.Player.Cheats & (CF_GODMODE|CF_BUDDHA) || Victim.bBuddha || Victim.bInvulnerable))
		{
			//Nice try Graf.
			Let FuckYou = Victim.GiveInventoryType ("MVP_APFSDS_CheatBypass");
			If (Victim.Player.Cheats & CF_GODMODE) FuckYou.bFoilInvul = True;
			If (Victim.Player.Cheats & CF_BUDDHA) FuckYou.bFoilBuddha = True;
			FuckYou.bBuddha = Victim.bBuddha;
			FuckYou.bInvulnerable = bInvulnerable;
			
			//Lol, lmfao even.
			Victim.Player.Cheats &= ~(CF_GODMODE|CF_BUDDHA);
			Victim.bInvulnerable = Victim.bInvulnerable = False;
			KilledCheater = bNoExtremeDeath = True;
		}
		
		If (Victim.Player && HostileVictim && Victim.Player.Cheats & CF_GODMODE2 || Victim.bNoDamage)
		{A_LOG ("I AM A GOD");
			ProjectileKickBack *= 2; //Weee
			bBloodlessImpact = True;
			ExplodeMissile(Null,Victim);
		}
		
		Return Num;
	}
	
	Void DoAPFSDSSplash (Int LiquidType, Bool UpsideDown = False)
	{
		If (LiquidType == LIQUID_NONE) Return;
		HitLiquid = True;
		Actor Splash = SpawnLiquidSplash (LiquidType,volume:0.4,0.8);
		
		Double Size = FRandom (0.8,1.2);
		Splash.Scale.X = Splash.Scale.Y = (UpsideDown ? -Size : Size);
		Splash.Scale.Y *= UpsideDown ? FRandom (-1.2,-2.5) : FRandom (1.2,2.5);
		Splash.bXFlip = Random (False,True);
	}
	Bool HitLiquid;
	Bool KilledCheater;
	States
	{
		Spawn:
			MBTP H 0 NoDelay
			{
				A_SpawnItemEx ("MVP_APFSDSShellPetal",yvel:FRandom(2,4));
				A_SpawnItemEx ("MVP_APFSDSShellPetal",yvel:FRandom(-2,-4));
			}
			MBTP # 1
			{
				A_FaceMovementDirection ();
				Frame = UpdateProjectileElevation (9,9,7,8,8); //J, J, H, I, I
			}
			Wait;
		Death: //Bullet hit level geometry.
			TNT1 A 1
			{
				A_StopSound (CHAN_BODY);
				//The floor was hit.
				If (Pos.Z <= FloorZ)
					DoAPFSDSSplash(CheckLiquid(FloorPic));
				//The ceiling was hit.
				Else If (Pos.Z + Height >= CeilingZ)
					DoAPFSDSSplash(CheckLiquid(CeilingPic),True);
				
				If (HitLiquid) Destroy(); //Splash was spawned, so just delete yourself.
				Else A_StartSound ("Vehicle/APC/MGImpact",CHAN_WEAPON);
				A_QuakeEx (1,1,1,GameTicRate,0,256,falloff:32,rollintensity:1);
			}
			Stop;
		XDeath: //Bullet hit a bleeding actor.
			TNT1 A 1; //Don't play the impact sound on bleeding actors.
			tnt1 a 0 {console.printf ("i hit %s",Tracer.getclassname());}
			TNT1 A 0 A_JumpIf ((Tracer.Player && Tracer.Player.Cheats & CF_GODMODE2 || Tracer.bNoDamage),"XDeath.God"); //Go to non-bleeding state for super indestructible actors.
			Stop;
		XDeath.God:
			TNT1 A 1
			{
				A_StartSound ("Vehicle/Tank/APFSDSShatter",CHAN_WEAPON);
				For (Int I = 0; I <= 8; I++)
					A_SpawnItemEx ("MVP_APFSDSShard",yvel:FRandom(6,-6),FRandom(6,-6),FRandom(6,-6));
			}
			TNT1 A 17 A_QuakeEx (1,1,1,GameTicRate,0,256,falloff:32,rollintensity:1);
			Stop;
		Crash: //Bullet hit a non bleeding actor.
			TNT1 A 1 A_StartSound ("Vehicle/APC/MGImpact",CHAN_WEAPON);
			TNT1 A 17 A_QuakeEx (1,1,1,GameTicRate,0,256,falloff:32,rollintensity:1);
			Stop;
	}
}

//Once the APFSDS shell disables the basic god modes, this function turns them back one 1 tick after the impact.
//FoilInvul: Give the owner CF_GODMODE.
//FoilBuddha: Give the owner CF_BUDDHA.
//Invulnerable: Give the player bInvulnerable.
//Buddha: Give the player bBuddha.
Class MVP_APFSDS_CheatBypass : Inventory
{
	Override Void DoEffect ()
	{
		If (GetAge() >= 1 && Owner.Player)
		{
			If (bFoilInvul) Owner.Player.Cheats |= CF_GODMODE;
			If (bFoilBuddha) Owner.Player.Cheats |= CF_BUDDHA;
			Owner.bInvulnerable = bInvulnerable;
			Owner.bBuddha = bBuddha;
			GoAwayAndDie();
		}
	}
}

Class MVP_APFSDSShard : Actor
{
	Default
	{
		Scale 0.2;
		Radius 4;
		Height 8;
		+ThruActors;
	}
	Override Void Tick()
	{
		Super.Tick();
		If (Pos.Z <= FloorZ || BlockingLine)
		{
			If (Frame >= 7 && Random (0,256) < 48) A_StartSound ("Vehicle/Di-Cokka/MetalHit",volume:FRandom (0.3,0.8),ATTN_STATIC);
			Destroy();
		}
	}
	States
	{
		Spawn:
			MSDB QRSTUVWX 1;
			Loop;
	}
}

Class MVP_HEATShellPetal : Actor
{
	Default
	{
		XScale 0.5;
		YScale 0.416666; //0.5 / 1.2
		+NoBlockmap;
	}
	Double RotAng;
	Override Void PostBeginPlay ()
	{
		Super.PostBeginPlay();
		RotAng = Random (1,6);
		RotAng *= Random (1,-1);
	}
	
	Override Void Tick ()
	{
		Super.Tick();
		If (!IsFrozen() && !InStateSequence (CurState,FindState("Death"))) Angle += RotAng;
	}
	
	States
	{
		Spawn:
			MBTP DDDDEEEEFFFF 1 A_CheckFloor ("Death");
			Loop;
		Death:
			MBTP G -1;
			Stop;
	}
}

Class MVP_APFSDSShellPetal : MVP_HEATShellPetal
{
	States
	{
		Spawn:
			MBTP KKKKLLLLMMMM 1 A_CheckFloor ("Death");
			Loop;
		Death:
			MBTP N -1;
			Stop;
	}
}

Class MVP_ATGM : MVP_BaseProjectile
{
	Default
	{
		XScale 0.5;
		YScale 0.416666; //0.5 / 1.2
		//PLACEHOLDER
		Radius 16;
		Height 16;
		Speed 80;
		FastSpeed 120;
		DamageFunction (Random(500,800));
		Decal "ATGMScorch";
		DamageType "Missile";
		Projectile;
		Obituary "%o failed to outrun a guided missile";
		MissileType "MVP_RocketFlame";
		//KAI_BaseProjectile.TrailActor "MVP_RocketFlame";
		//KAI_BaseProjectile.InitialTrailsSkipped 32;
		//KAI_BaseProjectile.MaxTrails 33;
		KAI_BaseProjectile.TrailDelay 12; //Delay until the missile unfolds.
		+SeekerMissile;
		+CastSpriteShadow; //I mean, it's big and slow enough.
		+KAI_BaseProjectile.NoTrailLine;
	}
	
	Mixin MVP_MarineFunctions;
	Actor WarnZone;
	Vector3 WarnPos;
	KAI_LOFActorFinder MarineWarner;
	Bool HitLiquid;
	DynamicLight Light;
	
	Void DoSplash (Int LiquidType, Bool UpsideDown = False)
	{
		If (LiquidType == LIQUID_NONE) Return;
		HitLiquid = True;
		Actor Splash = SpawnLiquidSplash (LiquidType,"SFX/AltLiquidExplosion",attenuation:0.35,600,256,96,'Explosive', True);
		
		Splash.A_QuakeEx (1,1,1,24,0,768,"",QF_SCALEDOWN|QF_GROUNDONLY,rollintensity:1);
		Double Size = FRandom (2,4);
		Splash.Scale.X = Splash.Scale.Y = (UpsideDown ? -Size : Size);
		Splash.Scale.X *= UpsideDown ? FRandom (-1.2,-2.5) : FRandom (1.2,2.5);
		Splash.bXFlip = Random (False,True);
	}
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		WarnZone = WarnMarines (MWRN_ALLIESTOO,512,Self);
		MarineWarner = New ("KAI_LOFActorFinder");
		MarineWarner.Shooter = Self;
	}
	
	//Rocket trail.
	Override Void TrailSpawn (Actor Trail)
	{
		Super.TrailSpawn(Trail);
		Trail.bStandStill = True;
		Trail.SetOrigin (KAI_Math.Vec3OffsetRelative (Self,(-48,0,0)),False);
		Trail.Roll = FRandom(-180,180);
		Trail.A_SetScale (Trail.Scale.X*FRandom(0.7,1.2));
		Trail.Vel.X = FRandom (-2,2);
		Trail.Vel.Y = FRandom (-2,2);
		Trail.Vel.Z = FRandom (-0.5,3);
	}
	
	Override Void Die (Actor Source, Actor Inflictor, Int DmgFlags, Name MeansOfDeath)
	{
		If (WarnZone) WarnZone.Destroy();
		If (Flare) Flare.Destroy();
		Super.Die (Source, Inflictor, DmgFlags, MeansOfDeath);
	}
	
	Override Void OnDestroy()
	{
		Super.OnDestroy();
		If (WarnZone) WarnZone.Destroy();
		If (Flare) Flare.Destroy();
	}
	
	//Update the in-flight sprites.
	Int UpdateATGMSprites()
	{
		If (SteerDir == STEER_NONE)
			Return UpdateProjectileElevation (21,21,20,21,21,True); //V, V, U, V, V
		Else If (SteerDir == STEER_RIGHT)
			Return UpdateProjectileElevation (23,23,22,23,23,True); //X, X, W, X, X;
		Else If (SteerDir == STEER_LEFT)
			Return UpdateProjectileElevation (25,25,24,25,25,True); //Z, Z, Y, Z, Z;
		
		Return UpdateProjectileElevation (21,21,20,21,21,True); //V, V, U, V, V
	}
	
	Double OldAngle;
	Bool SteerDir;
	Actor Flare;
	
	Enum SteerDirections
	{
		STEER_RIGHT = -1,
		STEER_NONE	= 0,
		STEER_LEFT	= 1
	}
	
	Override Void Tick ()
	{
		OldAngle = Angle;
		Super.Tick();
		If (IsFrozen()) Return;
		console.printf ("angle difference %f",DeltaAngle (Angle,OldAngle));
		If (DeltaAngle (Angle,OldAngle) < -0.1)
			{a_log ("steering right");SteerDir = STEER_RIGHT;}
		Else If (DeltaAngle (Angle,OldAngle) > 0.1)
			{a_log ("steering left");SteerDir = STEER_LEFT;}
		Else
			SteerDir = STEER_NONE;
		
		If (Flare)
			Flare.SetOrigin (KAI_Math.Vec3OffsetRelative(Self,(-40,0,0)),True);
		
		Vector3 Direction = (AngleToVector(Angle, Cos(Pitch)), -Sin(Pitch));
		
		MarineWarner.Trace (Pos.PlusZ(Height/2),CurSector,Direction,768,0);
		//Check all the actors the trace hit.
		Name TheMarine = "SmartMarine";
		ForEach (Mobj : MarineWarner.Mobjs)
			If (Mobj && !IsDead (Mobj) && Mobj Is TheMarine && IsHostileToShooter(Mobj))
				WarnSpecificMarine(Mobj); //Then warn them.
		FSpawnParticleParams P; P.Color1 = "Red"; P.Style = STYLE_None; P.Lifetime = 1; P.Size = 8; P.StartAlpha = 1; P.FadeStep = -1; P.Flags = SPF_FULLBRIGHT;
		KAI_LOFRaycast.VisualizeTracePath(Pos.PlusZ(Height/2),MarineWarner.Results.HitPos,MarineWarner.Results.Distance,4,p);
		
		If (WarnZone) WarnZone.SetOrigin (MarineWarner.Results.HitPos,True); //And move the detonation zone to the position the trace hit.
	}
	States
	{
		//Deploy the wings.
		Spawn:
			MBTP O 0 NoDelay A_ScaleVelocity (0.5);
			MBTP # 5
			{
				A_FaceMovementDirection();
				Frame = UpdateProjectileElevation (15,15,14,15,15,True); //P, P, O, P, P
			}
			MBTP # 5
			{
				A_FaceMovementDirection();
				Frame = UpdateProjectileElevation (17,17,16,17,17,True); //R, R, Q, R, R
			}
			MBTP # 2
			{
				A_FaceMovementDirection();
				Frame = UpdateProjectileElevation (19,19,18,19,19,True); //T, T, S, T, T
			}
			MBTP # 0
			{
				A_ScaleVelocity (2.0);
				A_StartSound ("Vehicle/Tank/RocketMotor",flags:CHANF_LOOPING,0.5,0.5);
				Flare = Spawn ("MVP_FireLens",KAI_Math.Vec3OffsetRelative(Self,(-40,0,0)));
				If (Flare)
				{
					Flare.bAlwaysFast = True;
					Flare.Scale *= 1.2;
				}
				A_AttachLight ('ATGMLight',DynamicLight.FlickerLight,"F1F1A0",76,88,DynamicLight.LF_ATTENUATE,(-40,0,0));
			}
			Goto Fly;
		Fly:
			MBTP # 1 Bright
			{
				A_SeekerMissile (0,1,SMF_PRECISE);
				Frame = UpdateATGMSprites();
				A_FaceMovementDirection();
				If (Vel.Length() < 100) //Accelerate over time to 100, when FastMonsters is off of course.
					A_ScaleVelocity (1.01);
			}
			Wait;
		//Like the HEAT shell, the missile produces a large explosion, however it's explosion is smaller.
		Death:
			TNT1 A 1
			{
				If (Flare) Flare.Destroy();
				A_StopSound (CHAN_BODY);
				bCastSpriteShadow = bYFlip = False;
				
				//The floor was hit.
				If (Pos.Z <= FloorZ)
					DoSplash(CheckLiquid(FloorPic));
				//The ceiling was hit.
				Else If (Pos.Z + Height >= CeilingZ)
					DoSplash(CheckLiquid(CeilingPic),True);
				
				If (HitLiquid) Destroy(); //Splash was spawned, so just delete yourself.
			}
			TNT1 A 0
			{
				A_SetScale (0.75,0.75);
				A_SetRenderStyle (1.0,Style_Add);
				If (Pos.Z + Height >= CeilingZ) Scale.Y = -0.75; //If a ceiling was hit, invert the explosion.
				Else If (Pos.Z >= FloorZ+88) Return ResolveState ("Death.Air"); //If the explosion happened above 88 map units from the ground, trigger the air explosion.
				Return State (Null);
			}
			TNT1 A 0
			{
				SetZ (FloorZ); //Stick to the ground to explode properly.
				Light = DynamicLight(Spawn("DynamicLight",Pos));
				If (Light)
				{
					Light.Args[3] = 96;
					Light.Args[0] = 231; //RGB
					Light.Args[1] = 207;
					Light.Args[2] = 13;
				}
				Actor Ring = Spawn ("MVP_ShockwaveRing",Pos);
				If (Ring)
				{
					Ring.Speed = 0.75;
					Ring.FloatSpeed = 0.2;
					Ring.ReactionTime = (GameTicRate/2);
				}
				A_QuakeEx (2,2,2,GameTicRate*2,0,1536,"",QF_SCALEDOWN|QF_GROUNDONLY,falloff:64,rollintensity:1.5);
				A_StartSound ("SFX/BigExplosion",flags:CHANF_OVERLAP,attenuation:0.2);
				MakeAlliesImmuneToExplosion (Target, 448);
				A_Explode (1000,448,XF_EXPLICITDAMAGETYPE,True,128,damagetype:"Explosive");
				RemoveAllyExplosionImmunity();
				
				Actor Duster = Spawn ("MVP_GroundDustSpawner",Pos);
				Duster.ReactionTime = 128;
				Duster.Threshold = 384;
			}
			MBTF JKL 1 {Light.Args[3] += 32;}
			MBTF MNO 4 {Light.Args[3] += 32;}
			MBTF P 6 {Light.Args[3] += 32;}
			MBTF Q 16 {If (Light) Light.Destroy();}
			Stop;
		Death.Air:
			TNT1 A 0
			{
				Actor Boom = Spawn ("MVP_MBTFireEffect",Pos);
				Boom.Scale *= 1.2;
				Boom.Target = Target;
				Boom.MaxTargetRange = 512;
				Boom.MeleeRange = 256;
				Boom.SetDamage(1150);
				Boom.RadiusDamageFactor = 0.2;
				Boom.ReactionTime = 128; //How much smoke to spawn.
				Boom.Threshold = 384; //How far to spawn dust.
				Boom.bAlwaysPuff = False; //We use our own ring.
				
				Actor Ring = Spawn ("MVP_ShockwaveRing",Pos);
				If (Ring)
				{
					Ring.Speed = 0.75;
					Ring.FloatSpeed = 0.1;
					Ring.ReactionTime = GameTicRate;
				}
			}
			Stop;
	}
}

Class MVP_RocketFlame : MVP_Tracer
{
	Default
	{
		+WindThrust; //Doesn't work for some reason ? There's nothing internally that should stop wind from working on the smoke particles.
		+RollSprite;
		+NoInteraction;
		Translation "BrightZDoomFire";
		Alpha 0.75;
		Scale 0.5;
		ReactionTime 35;
	}
	
	Override Void Tick()
	{
		Actor.Tick();
		Super.Tick();
	}
	
	States
	{
		Spawn:
			RSMK A 1; //Bright flame.
			RSMK A 1 //Normal flame.
			{
				A_SetTranslation ("ZDoomFire");
				A_SetRenderStyle (1,STYLE_ADD);
			}
			RSMK A 0 //Smoke
			{
				A_SetRenderStyle (0.8,STYLE_TRANSLUCENT);
				A_SetTranslation ("");
			}
			RSMK BC 1;
			RSMK DE 1;
			Stop;
	}
}
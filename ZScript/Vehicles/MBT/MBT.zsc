//VARIANT IDEAS:
//General
//The different tank types should be handled with separate hull actors based on MVP_MBT, with different tags, speed, and health.
//The SPAAG and artillery tanks should not try to intentionally run over enemies as an attack, and back off like normal vehicles instead.
//Normal turret
	//Make an alternate 3-barrel chaingun RWS for the tank. That fires MVP_RifleBullet instead of MVP_50CalBullet. Twice as fast, for painlocking enemies.
//A BMPT Terminator.
	//It'll overall be weaker than the MBT, maybe having like 2000 health.
	//Two autocannons, or maybe machine guns instead (Probably that), and armed with ATGMs with a reload time of maybe like, 10 seconds or so.
	//It'll be limited to like -10 to 15/20 degrees of elevation.
	/*Maybe give it the ability to kinda use its' missiles sparingly. e.g if it's firing its' guns at an enemy, but a strong enemy is nearby, like in 1024 MU,
	then the turret will target the powerful enemy, and fire a missile at it, once the next missile is ready.*/
	/*Make it so if it's near an MBT, it will begin following it. And for as long as they are in sight of each other. The BMPT will only focus on attacking
	weak enemies with its' machine guns, unless a missile is ready. While the MBT turret will only focus on powerful enemies if there are any around.
	Basically, give the BMPT it's real world role as tank support, instead of just having it be shittier MBT.*/
//A SPAAG variant, like the Gepard and Type 87. With airburst shells like the APC.
	//It'll overall be weaker than the MBT, maybe having like 2000 health.
	//It has an extreme elevation range of -10 to 90 degrees.
	//It can see 360 degrees.
	//Maybe add an animation of the destructible back radar rising and lowering when the tank sees an enemy. It won't lower the rader if its' destroyed.
	//It has a dual autocannon, like the APC's autocannon, but fires a little faster, and has a far faster traverse speed.
	//The sheels are a bit smaller than the APCs, and weaker, but can airburst, and produce hitscan shrapnel with a longer range than the airbburst explosion.
	//Maybe remove the airburst from the APC's autocannon, to justify using the SPAAG instead.
	//Add a radar in front of the turret, that elevates with the cannons. And a smaller radar on top, that is a separate actor instead of part of the sprite.
	//The top radar should not be cosmetic, and when destroyed halve the accuracy and sight range of the SPAAG, and limit its' FOV.
	//It will only target flying enemies, unless there's literally none of them in sight, in which case it'll start sounding at ground enemies too.

//TODO
//Add damage factors to the hull and turret.
//Maybe make it so the tank hull doesn't try chasing enemies faster than it, particularly if that enemy is running away from them ?
//Probably move the APCs' bullets and shells, and the tanks' ATGM, into a generic projectiles file for reused projectile types.
Class MVP_MBT : MVP_BaseVehicle
{
	Default
	{
		//$Title Main Battle Tank
		//$Category Vehicles/Tanks
		//$Sprite MMBT[1
		Health 6000;
		WoundHealth 1500;
		Speed 10;
		XScale 1;
		YScale 0.833333; //1 / 1.2
		Radius 96;
		Height 56;
		MeleeRange 88;
		MaxSlopeSteepness 0.65;
		Mass 30000;
		FriendlySeeBlocks 128;
		MaxTargetRange 16384;
		KAI_Actor.ThreatLevel THREAT_VERYDANGEROUS;
		KAI_Actor.ThreatLevelThreshold THREAT_VERYDANGEROUS;
		KAI_BaseVehicle.VehicleTurret "MVP_MBTTurret"; //Normal tank turret.
		KAI_BaseVehicle.MaxPushMass 25000;
		KAI_BaseVehicle.MaxPushRadius 128;
		KAI_BaseVehicle.MaxPushHeight 128;
		KAI_BaseVehicle.CrushDamage 12;
		KAI_BaseVehicle.MaxCrushRadius 64;
		KAI_BaseVehicle.MaxCrushHeight /*64*/ 192; //The height is kinda fucky, but it's for the tank to be able to drive over street lights in gz_bigcity.
		KAI_BaseVehicle.MaxCorpseRadius 88;
		KAI_BaseVehicle.MaxCorpseHeight 64;
		Tag "M6V3-EX Main Battle Tank"; //TODO: Change the tags for the different tank variants too.
		ActiveSound "Vehicle/Tank/Move";
		//Armor, yes, good luck, lmao.
		DamageFactor 0.6; //Generic damage factor.
		DamageFactor "ExplosiveImpact", 0.5;
		DamageFactor "Explosion", 0.5;
		DamageFactor "Explosive", 0.5;
		DamageFactor "Grenade", 0.4;
		DamageFactor "HitScan", 0.55; //The generic damage type of hitscan attacks.
		DamageFactor "Fire", 0.3;
		//Damage factors specific to the Smart Marines.
		DamageFactor "MarineHMG", 0.5;
		DamageFactor "MarineGrenade", 0.5;
		DamageFactor "MarineRifle", 0.55;
		//Vehicle damage factors
		DamageFactor "Autocannon", 0.5;
		DamageFactor "RifleBullet", 0.6;
		+DontSquash;
		+DontBlast;
	}
	
	Override Void PostBeginPlay ()
	{
		TurretOffsets = (0,0,4.8);
		Super.PostBeginPlay();
		//Decide movement sound for this tank instance.
		If (Random (False,True) == True) ActiveSound = "Vehicle/Tank/AltMove";
		
		/*I just overheard a secure access transmission...soldiers have arrived and they're coming to rescue us.
		Of course, I have my doubts that we'll live long enough to greet them.*/
		If (Random(0,255) < 16)
		{
			ActiveSound = "Vehicle/Tank/MoveOriginal";
			Turret.TurnSound = "Vehicle/Tank/TurretTurnOriginal";
			Turret.bTurnSoundNoStop = False;
		}
		WarningZone = WarnMarines (MWRN_WARP|MWRN_ALLIESTOO,128,Self,(96,0,Height/2));
		console.printf ("active sound is %s",activesound);
	}
	
	Override Void Tick ()
	{
		Super.Tick();
		If (IsFrozen() || !WarningZone) Return;
		//Disable the warning zone if crushing is disabled or the tank isn't moving in the first place.
		WarningZone.bDormant = (bNoCrushing || IsInState (Self,"Spawn"));
	}
	
	Override Void UserVariableDefaults ()
	{
		If (User_RetreatDistance == 0) User_RetreatDistance = 768;
		Super.UserVariableDefaults();
		
		//If (TankCrushRange > 0) User_RetreatDistance = -1; //If you are going to crush your enemies, don't run away from them.
		If (User_CrushMode == CRUSH_NONE) bNoCrushing = True;
	}
	
	Override Void SpawnVehicleTurret ()
	{
		If (VehicleTurret)
		{
			SpawnTurret (VehicleTurret);
			If (User_RWS ~== "MG" || User_RWS ~== "MachineGun" || User_RWS ~== "Machine Gun")
				Turret.VehicleTurret = "MVP_MBTRWS";
			Else If (User_RWS ~== "Minigun" || User_RWS ~== "Gatling")
				Turret.VehicleTurret = "MVP_MBTRWSMinigun";
		}
	}
	
	Override Bool CanAttack()
	{
		Return True; //The tank always has a turret on it to attack with. Plus it might also be able to crush enemies on its; own.
	}
	
	//Don't use the threat assessment of MVP vehicles, which considers players and marines on turrets as huge deal. Since they do little against the tank.
	Override Int AssessThreatLevel (Actor Other, Bool CheckPlayers)
	{
		//TODO: Make the player not be considered that much of a threat if they only have God or Buddha 1, and the hull has the standard turret.
		Return KAI_BaseVehicle.AssessThreatLevel(Other, CheckPlayers);
	}
	
	Override Bool SpawnDamageSmoke()
	{
		If (!Super.SpawnDamageSmoke()) Return False;
		Vector3 SpawnPos = Vec3Angle (96,GetNearestCardinalAngle(True));
		SpawnPos = Level.Vec3Offset (SpawnPos,(FRandom(-16,16),FRandom(-16,16),48));
		SpawnPos.XY = KAI_Math.RotateAround (Pos.XY,SpawnPos.XY,SpriteRotation);
		Let FX = (WoundHealth/2 >= Health) ? "MVP_BrightFireParticle" : "MVP_DamageSmoke";
		For (Int I; I < 2; I++)
		{
			Actor Smoke = Spawn (FX,SpawnPos);
			Smoke.Roll = FRandom(-180,180);
			Smoke.A_SetScale (FRandom(0.7,1.2));
			Smoke.Vel.Z = FRandom (1,4);
		}
		Return True;
	}
	
	Override Void SpawnHeadlights ()
	{
		Headlights.Push (SpawnVehicleHeadlight (Self,(64,48,32),VHSF_SPRITEROT|VHSF_CARDINALS|VHSF_16ANGLES,lightcolor:(255,195,165),512,spotlightangles:(25,50)));
		Headlights.Push (SpawnVehicleHeadlight (Self,(64,-48,32),VHSF_SPRITEROT|VHSF_CARDINALS|VHSF_16ANGLES,lightcolor:(255,195,165),512,spotlightangles:(25,50)));
		Headlights.Push (SpawnVehicleHeadlight (Self,(128,56,32),VHSF_SPRITEROT|VHSF_BACKLIGHT|VHSF_CARDINALS|VHSF_16ANGLES,lightcolor:(255,150,0),64,spotlightangles:(45,90)));
		Headlights.Push (SpawnVehicleHeadlight (Self,(128,-56,32),VHSF_SPRITEROT|VHSF_BACKLIGHT|VHSF_CARDINALS|VHSF_16ANGLES,lightcolor:(255,150,0),64,spotlightangles:(45,90)));
	}
	
	Override Void Die (Actor Source, Actor Inflictor, Int DmgFlags, Name MeansOfDeath)
	{
		If (WarningZone) WarningZone.Destroy();
		If (Retreating)
		{
			A_SetSpriteRotation (0);
			A_SetAngle (Angle+180);
			Retreating = False;
			RetreatLoops = 0;
		}
		Super.Die (Source, Inflictor, DmgFlags, MeansOfDeath);
	}
	
	Override Void OnDestroy()
	{
		Super.OnDestroy();
		If (WarningZone) WarningZone.Destroy();
	}
	
	//Produce crushing related obituaries for players.
	Override String GetObituary (Actor Victim, Actor Inflictor, Name MOD, Bool PlayerAttack)
	{
		String MeleeObituaries[] = {
		"%o was ran over by a tank",
		"%o didn't check both ways when crossing the street",
		"%o became roadkill",
		"%o is practicing their skidmark impression"
		};
		If (Inflictor == Self && (MOD == 'Crush' || MOD == 'TankCrush'))
		{
			Bool Placeholder = True;
			//Print a "special" obituary if the player was intentionally crushed by the tank.
			If (Target == Victim && User_CrushMode == CRUSH_ACTIVE && Random (0,255) < 255/4) //4/6/1989
			{
				Let Checker = SM_MarineChecker(EventHandler.Find ("SM_MarineChecker"));
				String PlayerName;
				If (Victim && Victim.Player)
					PlayerName = Victim.Player.GetUsername();
				Else If (Victim)
					PlayerName = Victim.GetTag();
				Return String.Format ("%s 没有被压碎 %s",PlayerName,Checker.ScopeHack.Date);
			}
			Else
				Return MeleeObituaries[Random(0,MeleeObituaries.Size()-1)];
		}
		
		Return Super.GetObituary (Victim, Inflictor, MOD, PlayerAttack);
	}
	
	Bool IsMeleeOnlyEnemy (Actor Other)
	{
		Return (Other && Other.MeleeState && !Other.MissileState);
	}
	
	//Bool IsRangedEnemy (Actor Other)
	
	//Finds a living enemy to crush within Range, and sets it as the tanks' target.
	//FOV: The FOV to use for the sight check.
	//Range: The range to find a victim to run over in.
	//MaxTurretRange: If the turrets' target is outside of this range from it, begin chasing that target instead.
	Void MBT_RunShitOver (Double FOV = 45, Double Range = 512, Double MaxTurretRange = 2048)
	{
		If (Range <= 0 || bNoCrushing) Return;
		//The turrets' target is too far from it or out of sight. So start chasing that instead.
		If (Turret && Turret.Target && (Turret.Distance3DSquared (Turret.Target) > MaxTurretRange || !Turret.CheckSight(Turret.Target)))
		{
			Target = Turret.Target;
			Return;
		}
		If (Health < 1000) Return;
		Actor Mobj;
		Array <Actor> Candidates;
		Let Roadkills = BlockThingsIterator.Create (Self,Range);
		While (Roadkills.Next())
		{
			Mobj = RoadKills.Thing;
			
			If (!Mobj || Mobj == Self) Continue;
			If (IsDead (Mobj) || IsInanimateObject (Mobj) || IsFlying (Mobj) || !IsCollidable (Mobj,Self) || !CanBeTargeted(Self,Mobj) || !IsActorHostile (Mobj)) Continue;
			
			Int Level = AssessThreatLevel (Mobj,True);
			
			//Don't fuck with super dangerous enemies.
			Switch (Level)
			{
				Case THREAT_DANGEROUS:
				Case THREAT_VERYDANGEROUS:
				Case THREAT_SUPERDANGER:
				Case THREAT_UNSTOPPABLE:
					a_log ("too dangerous");
					Continue;
				Default:
					Break;
			}
			
			//If it's not a really weak enemy and they have some kind of range attack, avoid them. If they are weak, ignore that they have a range attack.
			If (Level >= THREAT_NORMAL && Mobj.MissileState) {a_log ("ranged");Continue;}
			
			//And at last, the distance and sight checks.
			If (Distance3DSquared (Mobj) > Range*Range || !CheckSight (Mobj)) {a_log ("distance and sight");Continue;}
			
			Candidates.Push(Mobj);
		}
		
		If (!Candidates.Size())
		{a_log ("no crushees"); Return;}
		
		//LastEnemy = Target;
		Target = GetClosestActor (Candidates,Self.Pos,Range);
	}
	
	Void A_MBTLook ()
	{
		If (User_CrushMode != CRUSH_PASSIVE)
			MBT_RunShitOver (220,TankCrushRange); //Find something to run over.
		If (!Target) //Nothing found, just look for actors normally.
			KAI_Look (User_Stationary ? LOF_NOJUMP : 0,maxseedist:MaxTargetRange,8192,220);
		If (Turret && Turret.Target && !IsDead(Turret.Target)) //Still no target, so get your turrets' target instead.
		{
			Target = Turret.Target;
			If (!User_Stationary) SetStateLabel ("See");
		}
	}
	
	//TODO: Make a generic A_TankFire() function that has 3 different firing types maybe ?
	/*
	Enum AmmoTypes
	{
		TYPE_HEAT 	= 0, //Standard ammo type, used for weak (Relatively) enemies, groups, etc.
		TYPE_APFSDS	= 1, //Ripper that does a shitton of damage. Used for powerful enemies, like Cyberdemons and players with god/buddha mode 1.
		TYPE_ATGM	= 2, //Homing missiles, have a chance to be fired at powerful enemies, and distant and/or fast enemies.
	}
	Void A_TankFire (Vector3 Offset, Int Type = TYPE_HEAT){}
	*/
	// Use +YFLIP for the aiming down elevations of the ATGM (And maybe rocket too), to save on frames and file size.
	// For the SPAAG, make it do more damage to flying actors using DoSpecialDamage on both the projectile and hitscan shrapnel puffs.
	// Design wise, the back radar of the SPAAG should have a separate REAL hitbox that receives damage. Whose relative position snaps based on the turret angle.
	Enum TurretTypes
	{
		TURRET_NORMAL	= 0, //The normal MBT variant.
		TURRET_TOS1		= 1, //Thermobaric rocket artillery variant, no gravity affected rockets because I'm not THAT nuts (Actually good at programming).
		TURRET_BMPT		= 3, //Light tank-ish variant of the tank. With only machine guns and rockets, and less health.
		TURRET_SPAAG	= 4, //AA variant of the tank, with a functional top radar.
	}
	
	Const TankAngleLimit = 3; //How much the tank can turn per step.
	Const TankCrushRange = 640;
	Bool Retreating;
	Int RetreatLoops;
	Actor WarningZone;
	
	Bool HasAltHull;
	
	Bool User_FocusFire; //Should the tanks' remote weapon station, if any, not always try to not have the same target as the turret ?
	Bool User_Stationary; //The tank always stays in place, similar to the HECU M1 Abrams tanks from Half-Life 1.
	//Original code donut stael.
	//Main difference is that this control both corpse AND live enemy crushing.
	Int User_CrushMode;
	Enum CorpseCrushModes
	{
		CRUSH_NONE = -1, //No crushing at all, only pushing.
		CRUSH_ACTIVE = 0, //Actively seek corpses and enemies.
		CRUSH_PASSIVE = 1 //Crush enemies and corpses, but only by happenstance.
	};
	String User_RWS; //What remote weapon station should the tank use ? The two types are MG and Minigun.
	States
	{
		Sprites:
			AMBT ABCDEF 0;
		Spawn:
			MMBT A 0 NoDelay {Sprite = !HasAltHull ? GetSpriteIndex ("MMBT") : GetSpriteIndex ("AMBT");}
			#### A 1
			{
				A_StopSound (CHAN_MOVING);
				A_StartSound("Vehicle/Tank/Idle",CHAN_IDLING,CHANF_LOOPING,attenuation:0.5);
				A_MBTLook();
			}
			Loop;
		//High quality code rips.
		Idle:
			#### ABCDEF 2
			{
				A_QuakeEx (1,1,1,2,0,512,flags:QF_GROUNDONLY);
				A_StopSound (CHAN_IDLING);
				A_StartSound (ActiveSound,CHAN_MOVING,CHANF_LOOPING,attenuation:0.6);
				
				A_MBTLook();
				
				//Archvile trolling move activated.
				If (User_CrushMode == CRUSH_ACTIVE)
				{
					If (CorpseTarget && CorpseTarget.bDontGib) CorpseTarget = Null; //Disgard crushed corpses.
					//Don't have a corpse to crush already.
					If (!CorpseTarget)
					{
						CorpseTarget = FindNearestCorpse(); //Nearby corpse found, go and crush it.
						If (CorpseTarget) 
							KAI_MoveTowards (CorpseTarget.Pos,0.8,8);
						Else //Still no corpse found, so just begin wandering around.
							KAI_Wander(48,1024,128,0.5,TankAngleLimit);
					}
					
					//There is an available corpse to head to and crush.
					If (CorpseTarget)
						KAI_MoveTowards (CorpseTarget.Pos,0.8,8);
				}
				Else
					KAI_Wander(48,1024,128,0.5,TankAngleLimit);
				
				FollowPlayerControl (512);
				
				If (User_CrushMode != CRUSH_NONE) KAI_CrushCorpses();
			}
			Loop;
		See:
			#### ABCDEF 2
			{
				A_QuakeEx (1,1,1,2,0,512,flags:QF_GROUNDONLY);
				If (User_Stationary) //Shouldn't be here.
					Return State (SpawnState);
				//Console.Printf ("Sprite angle offset %d",SpriteRotation);
				A_StopSound (CHAN_IDLING);
				A_StartSound (ActiveSound,CHAN_MOVING,CHANF_LOOPING,attenuation:0.5);
				//Try to find someone else to run over before the stock retargeting code runs.
				If (User_CrushMode == CRUSH_ACTIVE)
					If (!Target || Distance3DSquared (Target) > TankCrushRange*TankCrushRange || IsFlying(Target))
						MBT_RunShitOver (360,TankCrushRange);
				MoveToParams Params;//console.printf ("retreat dist %d",retreatrange);
				Params.DetourFactor = 0.25;
				Params.Attempts = 32;
				Params.StepThreshold = 32;
				Params.RunRad = 384;
				Int RealRange = RetreatRange;
				//If moving to a target that is below the threat threshold, never retreat. In other words, don't retreat when trying to run over someone.
				If (AssessThreatLevel (Target) < ThreatLevelThreshold && User_CrushMode == CRUSH_ACTIVE && Health >= 1000) RetreatRange = 0;
				KAI_LandVehicleChase (flags:LVC_USERETREATSTATE|LVC_PLAYERSASTHREATS|LVC_MAKEFRIENDSIDLE,turnradius:TankAngleLimit,512);
				RetreatRange = RealRange;
				If (User_CrushMode != CRUSH_NONE) KAI_CrushCorpses();
				Return State (Null);
			}
			Loop;
		//Retreat by "reversing", AKA calling KAI_VehicleRetreat, but using SpriteRotation and an inverted move animation to appear as facing the target.
		Retreat:
			#### A 0
			{
				If (User_Stationary) //Shouldn't be here.
					Return State (SpawnState);
				Retreating = True;
				A_SetSpriteRotation (180);
				A_SetAngle (Angle-180);
				Return State (Null);
			}
		Retreat.Move:
			#### FEDCBA 2
			{
				A_QuakeEx (1,1,1,2,0,512,flags:QF_GROUNDONLY);
				A_StopSound (CHAN_IDLING);
				A_StartSound (ActiveSound,CHAN_MOVING,CHANF_LOOPING,attenuation:0.5);
				KAI_VehicleRetreat (Target,96,512,32,0.25,TankAngleLimit);
				If (User_CrushMode != CRUSH_NONE) KAI_CrushCorpses();
			}
		Retreat.End:
			#### A 0
			{
				//Target no longer in sight, keep retreating for a bit before moving forward again.
				If (!RetreatLoops && RetreatLoops != -1)
				{
					If (!CheckSight(Target))
						RetreatLoops = Random (12,24);
					If (!RetreatLoops && !FindNearestEnemy (RetreatRange))
						RetreatLoops = Random (4,8);
					If (!RetreatLoops && Turret && Turret.Target && Turret.ElevationState != Turret.ELEVATION_TOOHIGH)
						RetreatLoops = Random (6,12);
					
					RetreatLoops = Random (12,24);
				}
					//console.printf ("loops %d",retreatloops);
				If (RetreatLoops > 0 && Target && !IsDead (Target))
				{
					RetreatLoops--;
					If (RetreatLoops == 0)
						RetreatLoops--;
					Return FindState ("Retreat.Move",True);
				}
					
				A_SetSpriteRotation (0);
				A_SetAngle (Angle+180);
				RetreatLoops = 0;
				Retreating = False;
				Return State (Null);
			}
			Goto See;
	}
}

//Normal tank turret. Can attack with its' attached RWS (If any), it's 130mm cannon with 3 shell types, and its' 7.62mm coaxial machine gun.
Class MVP_MBTTurret : MVP_BaseTurret
{
	Default
	{
		XScale 1;
		YScale 0.833333; //1 / 1.2
		Health 2500;
		Height 32;
		Radius 72;
		FriendlySeeBlocks 128;
		MaxTargetRange 16384;
		Mass 30000;
		Tag "M6V3-EX Turret";
		KAI_BaseTurret.MaximumPitch -50;
		KAI_BaseTurret.MinimumPitch 15;
		KAI_BaseTurret.TurnSoundRadius 0.5;
		//TODO: These attack speed for the target prediction will dynamically change based on the ammo type. For example APFSDS will be faster than HEAT.
		//While the ATGM will be the slowest of the bunch, but will lock unto enemies.
		KAI_BaseTurret.AttackSpeed 300;
		KAI_BaseTurret.FastAttackSpeed 350;
		KAI_BaseTurret.CombatAngleTurnRate 40;
		KAI_BaseTurret.CombatPitchTurnRate 30;
		KAI_BaseTurret.TurnSound "Vehicle/Tank/TurretTurn";
		KAI_Actor.ThreatLevel THREAT_VERYDANGEROUS;
		+KAI_BaseTurret.TransferDamage;
		+KAI_BaseTurret.TurnSoundNoStop;
		
		//"Armor"
		DamageFactor 0.6; //Generic damage factor.
		DamageFactor "ExplosiveImpact", 0.5;
		DamageFactor "Explosion", 0.5;
		DamageFactor "Explosive", 0.5;
		DamageFactor "Grenade", 0.4;
		DamageFactor "HitScan", 0.55; //The generic damage type of hitscan attacks.
		DamageFactor "Fire", 0.3;
		//Damage factors specific to the Smart Marines.
		DamageFactor "MarineHMG", 0.5;
		DamageFactor "MarineGrenade", 0.5;
		DamageFactor "MarineRifle", 0.55;
		//Vehicle damage factors
		DamageFactor "Autocannon", 0.5;
		DamageFactor "RifleBullet", 0.6;
	}
	
	Override Void PostBeginPlay ()
	{
		Vector3 Original = TurretOffsets;
		/*NOTE: The RWS can never look perfect due to the tank being made out of sprites. A Z offset of 0 looks like the station is sunken into its' platform
		from the front, but from the side makes it look actually attached. While a Z of 3 looks normal from the front, but makes the RWS float on the side.*/
		TurretOffsets = (-6,7.5,3);
		Super.PostBeginPlay();
		TurretOffsets = Original;
		
		MissileState = FindState ("Fire");
		AttackStates.Push (FindState("Fire",True));
	}
	
	Override Void Tick()
	{
		If (IsFrozen()) Return;
		
		//Reverse the direction of the turret when retreating, calling this before Super.Tick() makes the transition seamless.
		If (!IsDead (Self) && Master && Master Is "MVP_MBT")
			TurretRotationOffset = MVP_MBT(Master).Retreating ? -180 : 0;
		
		Super.Tick();
	}
	
	States
	{
		Spawn:
			MMBT G 1 RotateToVehicle(RTVF_ADDANGLE|RTVF_NOTARGETCHECK);
			Loop;
	}
}

Class MVP_MBTRWS : MVP_BaseTurret
{
	Default
	{
		Health 200;
		Radius 16;
		Height 16;
		DeathHeight 16;
		XScale 0.5; //The remote weapon stations are rendered at double the resolution of the rest of the tank hull and turret, for extra detail.
		YScale 0.416666;
		Mass 50;
		FriendlySeeBlocks 64;
		MaxTargetRange 8192;
		KAI_BaseTurret.MaximumPitch -50;
		KAI_BaseTurret.MinimumPitch 15;
		KAI_BaseTurret.TurnSoundRadius 1.5;
		KAI_BaseTurret.AttackSpeed 230;
		KAI_BaseTurret.FastAttackSpeed 250;
		KAI_BaseTurret.CombatAngleTurnRate 50;
		KAI_BaseTurret.CombatPitchTurnRate 37;
		KAI_Actor.ThreatLevel THREAT_ABOVENORMAL;
		AttackSound "Vehicle/APC/MGFire";
		Tag "M20 Remote Weapon Station";
		Obituary "%o was gunned down by a tanks' remote weapon station";
		DamageFactor "Autocannon", 0.95;
		DamageFactor "Melee", 0.4;
		DamageFactor "Electric", 0.4;
		DamageFactor "ExplosiveImpact", 0.825;
		DamageFactor "Explosion", 0.825;
		DamageFactor "HitScan", 0.9;
		+MissileMore;
		+MissileEvenMore;
	}
	
	Bool FocusFire; //Makes the MG not actively avoid sharing the same target as the turret, even if the shared target isn't a powerful enemy.
	//ULTRA HIGH DEFINITION QUALITY DOLBY ATMOS RIPS.
	Const RWSAttackHeight = 12;
	Array <Actor> HitActors;
	
	Override Bool ShouldAttack (Bool NoStateJump)
	{
		If (!KAI_BaseTurret.ShouldAttack()) Return False;
		If (Target && !CheckFOV (Target,90/2)) Return False; //KLUDGE: We need to do the null check here, because as of GZDoom 4.10, it's not done internally. Crashing the game.
		If (IsOverPitchLimits (Target,RWSAttackHeight,Target.Height/2) != ELEVATION_INBOUNDS) Return False;
		
		If (Target != Self && KAI_CheckMissileRange(Target) && !IsDead (Target) && IsActorHostile (Target) && RWSLOFCheck())
		{
			If (!NoStateJump) SetStateLabel ("Fire");
			Return True;
		}
		
		Return False;
	}
	
	MVP_APCMachineGunLOFCheck MarineWarner; //A permanent pointer to a MG LOF check tracer. So that it can be fired when the turret is firing to warn marines.
	Bool RWSLOFCheck()
	{
		Let Check = New ("MVP_APCMachineGunLOFCheck");
		TurretAimPos = UpdateTurretAimPos();
		Vector3 Direction;
		//If you have a target, fire the LOF check straight at the actor for the LOF check.
		If (Target)
		{
			Double PitchTo = PitchTo (Target,14,GetTurretAimPosOffset());
			Direction = (AngleToVector(AngleTo(Target), Cos(PitchTo)), -Sin(PitchTo));
		}
		//If no target, fire it at the actual aiming direction. This is how it used to be done, but because turrets now (12/5/2023) actually rotate ahead
		//of their target, that would lead to issues with the LOF returning false.
		Else
			Direction = (AngleToVector(Angle, Cos(Pitch)), -Sin(Pitch));
		
		Double Distance = Target ? Distance3D (Target)+32 : MaxTargetRange;
		Check.Shooter = Self;
		Check.Other = Target;
		Check.Trace ((Pos.X,Pos.Y,Pos.Z+RWSAttackHeight),CurSector,Direction,Distance,0);
		
		If (Check.BadLOF)
		{
			bDontStayAround = True;
			Check.Destroy();
			Return False;
		}
		bDontStayAround = False;
		Check.Destroy();
		Return True;
	}
	
	Override Void Tick()
	{
		Super.Tick();
		
		If (IsFrozen()) Return;
		//When shooting, fire a ray that alerts any marines that would be caught in the line of fire.
		If (IsInAttackState() && GetAge() % 2 == 0) //KLUDGE: This second check prevents infinite recursion when the turret stops firing.
		{
			Vector3 Direction = (AngleToVector(Angle, Cos(Pitch)), -Sin(Pitch));
			
			Double Distance = Target ? Distance3D (Target)+32 : MaxTargetRange;
			MarineWarner.Shooter = Self;
			MarineWarner.Other = Target;
			MarineWarner.OnlyFindActors = True;
			MarineWarner.Trace ((Pos.X,Pos.Y,Pos.Z+RWSAttackHeight),CurSector,Direction,Distance,0);
			HitActors.Move(MarineWarner.Mobjs);
			//Check all the actors the trace hit.
			Name TheMarine = "SmartMarine";
			ForEach (Mobj : HitActors)
				If (Mobj && !IsDead (Mobj) && Mobj Is TheMarine && IsHostile(Mobj))
					WarnSpecificMarine(Mobj); //Then warn them.
			HitActors.Clear();
		}
	}
	
	Override Void Die (Actor Source, Actor Inflictor, Int DmgFlags, Name MeansOfDeath)
	{
		Super.Die (Source, Inflictor, DmgFlags, MeansOfDeath);
		If (MarineWarner) MarineWarner.Destroy();
		If (Master) Master.SetTag (Master.Default.GetTag());
	}
	
	Override Void OnDestroy()
	{
		If (Master) Master.SetTag (Master.Default.GetTag());
		If (MarineWarner) MarineWarner.Destroy();
		Super.OnDestroy();
	}
	//====================================================
	
	Override Void PostBeginPlay ()
	{
		Super.PostBeginPlay();
		
		MissileState = FindState ("Fire");
		AttackStates.Push (FindState("Fire",True));
		MarineWarner = New ("MVP_APCMachineGunLOFCheck"); //Create the warning trace for marines.
	}
	
	States
	{
		Spawn:
			MMBT S 0;
			MMBT # 1
			{
				RotateToVehicle();
				KAI_Look (maxseedist:MaxTargetRange,DEFAULT_HEARDISTANCE,extraflags:KAIL_CHASETARGET);
				Frame = UpdateTurretElevation (24,18,20,22); //Y, S, U, W
			}
			Wait;
		See:
			MMBT # 1;
			MMBT # 1
			{
				DoCombatTraverse();
				RotateToVehicle();
				MoveToParams Params;
				Params.RunRad = 256;
				Params.DetourFactor = 1.0;
				Params.Attempts = 32;
				Params.StepThreshold = 32;
				KAI_LandVehicleChase (chaseflags:CHF_DONTIDLE|CHF_DONTMOVE,moveparams:params);
				UpdateTurretSnapTimer();
				Frame = UpdateTurretElevation (24,18,20,22); //Y, S, U, W
			}
			Loop;
		Fire:
			MMBT ## 1 {Frame = UpdateTurretElevation (24,18,20,22); /*Y, S, U, W*/}
			MMBT # 3 Light ("50CalFiringLight") Bright
			{
				A_StartSound (AttackSound,CHAN_WEAPON,CHANF_OVERLAP,1.0,0.3);
				Actor Proj = A_SpawnProjectile ("MVP_50CalBullet",12,-8,flags:CMF_AIMDIRECTION,Pitch); //pew pew
				AddProjectileSpread (Proj,(0.8,-0.8),(1.0,-1.0));
				A_SpawnItemEx ("MVP_BulletCasing",-32,32,8,FRandom(2,-2),FRandom(8,14),FRandom(6,12));
				Frame = UpdateTurretElevation (25,19,21,23); //Z, T, V, X
			}
			MMBT # 1
			{
				//If you have no target, or it's dead.
				If (!Target || IsDead (Target))
				{
					A_ClearTarget();
					LookForPlayers (True); //Look for a new target.
				}
				
				//If you share a target with the turret, then try finding a different one.
				//Unless the shared target is stronger than the turret, in which case don't force yourself to attack a different target.
				If (!FocusFire && Target && Master && Target == Master.Target && AssessThreatLevel (Master.Target, False) <= KAI_Actor(Master).ThreatLevel)
				{
					Actor NewTarget = PickDifferentTarget (Master.Target,Master.Target,2048,512);
					If (NewTarget)
						Target = NewTarget;
				}
				
				If (Random2[pr_monsterrefire]() < 48 &&
				//If the target is too high or low to shoot.
				((Target && IsOverPitchLimits (Target,12,Target.Height/2) != ELEVATION_INBOUNDS) ||
				!RWSLOFCheck()))
				{
					A_ClearTarget();
					Return ResolveState ("See");
				}
				
				HandleChaseTimer();
				
				Frame = UpdateTurretElevation (24,18,20,22); //Y, S, U, W
				Return State (Null);
			}
			MMBT # 0 KAI_TurretRefire (48,"See",True,fov:90/2);
			Goto Fire+2;
		Death:
			MBTD Q 1
			{
				If (Master)
				{
					Angle = Master.Angle;
					TurretRotationOffset = 0;
				}
				RotateToVehicle (RTVF_NOTARGETCHECK);
				Actor Boom = Spawn ("MVP_Explosion",Pos);
				Boom.Scale *= 0.6;
				Boom.SetDamage (32);
				Boom.MaxTargetRange = 96;
				Boom.MeleeRange = 12;
				Boom.bNoGravity = True;
			}
			MBTD Q 1 RotateToVehicle (RTVF_NOTARGETCHECK);
			Wait;
		XDeath:
			TNT1 A 0
			{
				Actor Boom = Spawn ("MVP_Explosion",Pos);
				Boom.Scale *= 0.9;
				Boom.SetDamage (56);
				Boom.MaxTargetRange = 128;
				Boom.MeleeRange = 48;
				Boom.bNoGravity = True;
				
				SmokeCounter = 48;
				Bool b; Actor Debris;
				For (Int I; I <= SmokeCounter; I++)
				{
					[B, Debris] = A_SpawnItemEx ("MVP_DiCokkaDebris",FRandom (Radius,-Radius),FRandom(Radius,-Radius),FRandom (0,Height),FRandom (-12,12),FRandom (-12,12),FRandom (6,16));
					If (Debris)
					{
						Debris.Scale *= FRandom (0.1,0.3);
						Debris.bXFlip = Random (False,True);
					}
				}
			}
			Stop;
		GenericFreezeDeath:
			MMBT # 0 {Frame = UpdateTurretElevation (24,18,20,22); /*Y, S, U, W*/}
			Goto Super::GenericFreezeDeath;
	}
}

Class MVP_MBTRWSMinigun : MVP_MBTRWS
{
	Default
	{
		FriendlySeeBlocks 48;
		MaxTargetRange 6144;
		KAI_BaseTurret.AttackSpeed 200;
		KAI_BaseTurret.FastAttackSpeed 220;
		Obituary "%o drowned in lead";
		Tag "M20 Minigun Remote Weapon Station";
	}
	
	Mixin MVP_AutocannonWarningZoneHandling; //Listen, the minigun works basically the same way as this. It just fires normal non-ripping bullet projectiles.
	
	Int ShotsFired;
	
	Override Bool ShouldAttack (Bool NoStateJump)
	{
		If (!KAI_BaseTurret.ShouldAttack()) Return False;
		If (Target && !CheckFOV (Target,90/2)) Return False;
		If (IsOverPitchLimits (Target,8,Target.Height/2) != ELEVATION_INBOUNDS) Return False;
		
		If (Target != Self && KAI_CheckMissileRange(Target) && !IsDead (Target) && IsActorHostile (Target) && KAI_TurretCheckLOF (Target,150,0,(0,0,8)))
		{
			If (!NoStateJump)
			{
				SetStateLabel ("Fire");
				WarningZone = WarnMarines (0,48); //Create a warning zone to warn marines of wherever the machine gun is aiming.
				If (WarningZone) WarningZone.SetOrigin (GetAttackLocation(),True);
			}
			Return True;
		}
		
		Return False;
	}
	
	States
	{
		Spawn:
			AMBT G 0;
			AMBT # 1
			{
				RotateToVehicle();
				KAI_Look (maxseedist:MaxTargetRange,DEFAULT_HEARDISTANCE,extraflags:KAIL_CHASETARGET);
				Frame = UpdateTurretElevation (12,6,8,10); //M, G, I, K
			}
			Loop;
		See:
			AMBT # 1
			{
				If (ShotsFired > 0) ShotsFired--;
				If (ShotsFired > 40) ThreatLevel = THREAT_DANGEROUS;
				Else ThreatLevel = Default.ThreatLevel;
				If (WarningZone) WarningZone.Destroy();
				DoCombatTraverse();
				RotateToVehicle();
				KAI_LandVehicleChase (chaseflags:CHF_DONTIDLE|CHF_DONTMOVE);
				UpdateTurretSnapTimer();
				Frame = UpdateTurretElevation (12,6,8,10); //M, G, I, K
			}
			Loop;
		Fire:
			AMBT ######## 1 {Frame = UpdateTurretElevation (12,6,8,10); /*M, G, I, K*/}
			AMBT # 4 Light ("RifleFiringLight") Bright
			{
				//The minigun also becomes more dangerous when it reaches max fire rate.
				If (ShotsFired > 200)
				{
					ThreatLevel = THREAT_DANGEROUS;
					A_SetTics (1);
				}
				Else If (ShotsFired > 40) A_SetTics (2);
				Else If (ShotsFired > 10) A_SetTics (3);
				If (ShotsFired <= 40) ThreatLevel = Default.ThreatLevel;
				//console.printf ("tics are %d",tics);
				Actor Proj = A_SpawnProjectile ("MVP_RifleBullet",8,flags:CMF_AIMDIRECTION,Pitch);
				AddProjectileSpread (Proj,(0.8,-0.8),(1.0,-1.0));
				A_StartSound (AttackSound,CHAN_WEAPON,CHANF_OVERLAP,1.0,0.4);
				Actor Casing; Bool B;
				[B, Casing] = A_SpawnItemEx ("MVP_BulletCasing",-16,-3,8,FRandom(1,-1),FRandom(-6,-10),FRandom(6,10));
				Casing.Scale.X = 0.125; Casing.Scale.Y = 0.104166;
				Frame = UpdateTurretElevation (13,7,9,11); //N, H, J, L
				ShotsFired++;
			}
			AMBT # 1
			{
				//If you have no target, or it's dead.
				If (!Target || IsDead (Target))
				{
					Actor Prev = Target;
					A_ClearTarget();
					LookForPlayers (True); //Look for a new target.
					If (!Target) //If the sight check didn't return something like it tends to do sometimes, try finding a target right around the old one.
						Target = PickDifferentTarget (Prev,Prev,512);
				}
				
				//If you share a target with the autocannon, then try finding a different one.
				//Unless the shared target is stronger than the turret you are on, in which case don't force yourself to attack a different target.
				If (!FocusFire && Target && Master && Target == Master.Target && AssessThreatLevel (Master.Target, False) <= KAI_Actor(Master).ThreatLevel)
				{
					Actor NewTarget = PickDifferentTarget (Master.Target,Master.Target,2048,512);
					If (NewTarget)
						Target = NewTarget;
				}
				
				If (Random2[pr_monsterrefire]() < 128 &&
				((Target && IsOverPitchLimits (Target,12,Target.Height/2) != ELEVATION_INBOUNDS) || Target && Distance3DSquared (Target) > MaxTargetRange*MaxTargetRange||
				!KAI_TurretCheckLOF (Target,150,0,(0,0,8))))
				{
					Actor Prev = Target;
					A_ClearTarget();
					LookForPlayers (True); //Look for a new target.
					If (!Target || IsOverPitchLimits (Prev,12,Prev.Height/2))
						Target = PickDifferentTarget (Prev,Prev,512);
					Return ResolveState ("See");
				}
				
				HandleChaseTimer();
				
				Frame = UpdateTurretElevation (12,6,8,10); //M, G, I, K
				Return State (Null);
			}
			AMBT # 0 KAI_TurretRefire (24,"See",True,fov:90/2);
			Goto Fire+8;
		Death:
			MBTD R 1
			{
				If (Master)
				{
					Angle = Master.Angle;
					TurretRotationOffset = 0;
				}
				RotateToVehicle (RTVF_NOTARGETCHECK);
				Actor Boom = Spawn ("MVP_Explosion",Pos);
				Boom.Scale *= 0.6;
				Boom.SetDamage (32);
				Boom.MaxTargetRange = 96;
				Boom.MeleeRange = 12;
				Boom.bNoGravity = True;
			}
			MBTD R 1 RotateToVehicle (RTVF_NOTARGETCHECK);
			Wait;
		XDeath:
			TNT1 A 0
			{
				Actor Boom = Spawn ("MVP_Explosion",Pos);
				Boom.Scale *= 0.9;
				Boom.SetDamage (56);
				Boom.MaxTargetRange = 128;
				Boom.MeleeRange = 48;
				Boom.bNoGravity = True;
			}
			Stop;
		GenericFreezeDeath:
			MMBT # 0 {Frame = UpdateTurretElevation (12,6,8,10); /*M, G, I, K*/}
			Goto Super::GenericFreezeDeath;
	}
}
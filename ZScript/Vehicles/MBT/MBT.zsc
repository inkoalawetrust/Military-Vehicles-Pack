//VARIANT IDEAS:
//General
//The different tank types should be handled with separate hull actors based on MVP_MBT, with different tags, speed, and health.
//The SPAAG and artillery tanks should not try to intentionally run over enemies as an attack, and back off like normal vehicles instead.
//Normal turret
	//Make an alternate 3-barrel chaingun RWS for the tank. That fires MVP_RifleBullet instead of MVP_50CalBullet. Twice as fast, for painlocking enemies.
//A BMPT Terminator.
	//It'll overall be weaker than the MBT, maybe having like 2000 health.
	//Two autocannons, or maybe machine guns instead (Probably that), and armed with ATGMs with a reload time of maybe like, 10 seconds or so.
	//It'll be limited to like -10 to 15/20 degrees of elevation.
	/*Maybe give it the ability to kinda use its' missiles sparingly. e.g if it's firing its' guns at an enemy, but a strong enemy is nearby, like in 1024 MU,
	then the turret will target the powerful enemy, and fire a missile at it, once the next missile is ready.*/
	/*Make it so if it's near an MBT, it will begin following it. And for as long as they are in sight of each other. The BMPT will only focus on attacking
	weak enemies with its' machine guns, unless a missile is ready. While the MBT turret will only focus on powerful enemies if there are any around.
	Basically, give the BMPT it's real world role as tank support, instead of just having it be shittier MBT.*/
//A SPAAG variant, like the Gepard and Type 87. With airburst shells like the APC.
	//It'll overall be weaker than the MBT, maybe having like 2000 health.
	//It has an extreme elevation range of -10 to 90 degrees.
	//It can see 360 degrees.
	//Maybe add an animation of the destructible back radar rising and lowering when the tank sees an enemy. It won't lower the rader if its' destroyed.
	//It has a dual autocannon, like the APC's autocannon, but fires a little faster, and has a far faster traverse speed.
	//The sheels are a bit smaller than the APCs, and weaker, but can airburst, and produce hitscan shrapnel with a longer range than the airbburst explosion.
	//Maybe remove the airburst from the APC's autocannon, to justify using the SPAAG instead.
	//Add a radar in front of the turret, that elevates with the cannons. And a smaller radar on top, that is a separate actor instead of part of the sprite.
	//The top radar should not be cosmetic, and when destroyed halve the accuracy and sight range of the SPAAG, and limit its' FOV.
	//It will only target flying enemies, unless there's literally none of them in sight, in which case it'll start sounding at ground enemies too.

//TODO
//Probably move the APCs' bullets and shells, and the tanks' ATGM, into a generic projectiles file for reused projectile types.
Class MVP_MBT : MVP_BaseVehicle
{
	Default
	{
		//$Title Main Battle Tank
		//$Category Vehicles/Tanks
		//$Sprite MMBT[1
		Health 6000;
		WoundHealth 1500;
		Speed 10;
		FastSpeed 16;
		XScale 1;
		YScale 0.833333; //1 / 1.2
		Radius 96;
		Height 61;
		MeleeRange 88;
		MaxSlopeSteepness 0.65;
		Mass 30000;
		FriendlySeeBlocks 128;
		MaxTargetRange 16384;
		RipLevelMin 16;
		KAI_Actor.ThreatLevel THREAT_VERYDANGEROUS;
		KAI_Actor.ThreatLevelThreshold THREAT_VERYDANGEROUS;
		KAI_BaseVehicle.VehicleTurret "MVP_MBTTurret"; //Normal tank turret.
		KAI_BaseVehicle.MaxPushMass 25000;
		KAI_BaseVehicle.MaxPushRadius 128;
		KAI_BaseVehicle.MaxPushHeight 128;
		KAI_BaseVehicle.CrushDamage 12;
		KAI_BaseVehicle.MaxCrushRadius 64;
		KAI_BaseVehicle.MaxCrushHeight /*64*/ 192; //The height is kinda fucky, but it's for the tank to be able to drive over street lights in gz_bigcity.
		KAI_BaseVehicle.MaxCorpseRadius 88;
		KAI_BaseVehicle.MaxCorpseHeight 64;
		Tag "M6V3-EX Main Battle Tank"; //TODO: Change the tags for the different tank variants too.
		ActiveSound "Vehicle/Tank/Move";
		//Armor, yes, good luck, lmao.
		DamageFactor 0.6; //Generic damage factor.
		DamageFactor "ExplosiveImpact", 0.5;
		DamageFactor "Explosion", 0.5;
		DamageFactor "Explosive", 0.5;
		DamageFactor "TankShell", 0.5;
		DamageFactor "Shell", 0.7;
		DamageFactor "APShell", 1.0; //Super susceptible to APFSDS.
		DamageFactor "Grenade", 0.4;
		DamageFactor "HitScan", 0.55; //The generic damage type of hitscan attacks.
		DamageFactor "Shrapnel", 0.2;
		DamageFactor "Fire", 0.3;
		DamageFactor "Plasma", 0.5;
		//Damage factors specific to the Smart Marines.
		DamageFactor "MarineHMG", 0.2;
		DamageFactor "MarineGrenade", 0.5;
		DamageFactor "MarineRifle", 0.55;
		//Vehicle damage factors
		DamageFactor "Autocannon", 0.25;
		DamageFactor "RifleBullet", 0.1;
		DamageFactor "Missile", 0.7;
		+DontSquash;
		+DontBlast;
	}
	
	Override Void PostBeginPlay ()
	{
		TurretOffsets = (0.1,0,-0.2);
		Super.PostBeginPlay();
		//Decide movement sound for this tank instance.
		If (Random (False,True) == True) ActiveSound = "Vehicle/Tank/AltMove";
		
		/*I just overheard a secure access transmission...soldiers have arrived and they're coming to rescue us.
		Of course, I have my doubts that we'll live long enough to greet them.*/
		If (Random(0,255) < 16)
		{
			ActiveSound = "Vehicle/Tank/MoveOriginal";
			Turret.TurnSound = "Vehicle/Tank/TurretTurnOriginal";
			Turret.bTurnSoundNoStop = False;
		}
		WarningZone = WarnMarines (MWRN_WARP|MWRN_ALLIESTOO,128,Self,(96,0,Height/2));
		console.printf ("active sound is %s",activesound);
	}
	
	Override Void Tick ()
	{
		Super.Tick();
		If (IsFrozen() || !WarningZone) Return;
		//Disable the warning zone if crushing is disabled or the tank isn't moving in the first place.
		WarningZone.bDormant = (bNoCrushing || IsInState (Self,"Spawn"));
	}
	
	Override Void UserVariableDefaults ()
	{
		If (User_RetreatDistance == 0) User_RetreatDistance = 1024;
		Super.UserVariableDefaults();
		
		//If (TankCrushRange > 0) User_RetreatDistance = -1; //If you are going to crush your enemies, don't run away from them.
		If (User_CrushMode == CRUSH_NONE) bNoCrushing = True;
	}
	
	Override Void SpawnVehicleTurret ()
	{
		If (VehicleTurret)
		{
			SpawnTurret (VehicleTurret);
			If (User_RWS ~== "MG" || User_RWS ~== "MachineGun" || User_RWS ~== "Machine Gun")
				Turret.VehicleTurret = "MVP_MBTRWS";
			Else If (User_RWS ~== "Minigun" || User_RWS ~== "Gatling")
				Turret.VehicleTurret = "MVP_MBTRWSMinigun";
		}
	}
	
	Override Bool CanAttack()
	{
		Return True; //The tank always has a turret on it to attack with. Plus it might also be able to crush enemies on its; own.
	}
	
	//Don't use the threat assessment of MVP vehicles, which considers players and marines on turrets as huge deal. Since they do little against the tank.
	Override Int AssessThreatLevel (Actor Other, Bool CheckPlayers)
	{
		If (!Other) Return THREAT_NONE;
		Int ThreatLvl = KAI_BaseVehicle.AssessThreatLevel(Other, CheckPlayers);
		//If the hull has the normal turret, and the unstoppable threat is a player with god or buddha mode 1. Or an invulnerable but non-NODAMAGE NPC.
		//Then don't consider them as much of a threat, since the turret can kill them using APFSDS anyway.
		If (Turret Is "MVP_MBTTurret" && ThreatLvl == THREAT_UNSTOPPABLE)
		{
			//Downgrade the threat if it doesn't have god or buddha 2, or NODAMAGE. And also if it doesn't have an esoteric flag combo that makes it untouchable.
			If (Other.Player && !(Other.Player.Cheats & (CF_GODMODE2|CF_BUDDHA2)) && !Other.bNoDamage && !(Other.bNonShootable && Other.bNoBlockmap && Other.bNoRadiusDmg))
				Return THREAT_SUPERDANGER; //It's not unstoppable, merely insanely dangerous.
		}
		Return ThreatLvl;
	}
	
	Override Bool SpawnDamageSmoke()
	{
		If (!Super.SpawnDamageSmoke()) Return False;
		Vector3 SpawnPos = Vec3Angle (96,GetNearestCardinalAngle(True));
		SpawnPos = Level.Vec3Offset (SpawnPos,(FRandom(-16,16),FRandom(-16,16),48));
		SpawnPos.XY = KAI_Math.RotateAround (Pos.XY,SpawnPos.XY,SpriteRotation);
		Let FX = (WoundHealth/2 >= Health) ? "MVP_BrightFireParticle" : "MVP_DamageSmoke";
		For (Int I; I < 2; I++)
		{
			Actor Smoke = Spawn (FX,SpawnPos);
			Smoke.Roll = FRandom(-180,180);
			Smoke.A_SetScale (FRandom(0.7,1.2));
			Smoke.Vel.Z = FRandom (1,4);
		}
		Return True;
	}
	
	Override Void SpawnHeadlights ()
	{
		Headlights.Push (SpawnVehicleHeadlight (Self,(64,48,32),VHSF_SPRITEROT|VHSF_CARDINALS|VHSF_16ANGLES,lightcolor:(255,195,165),512,spotlightangles:(25,50)));
		Headlights.Push (SpawnVehicleHeadlight (Self,(64,-48,32),VHSF_SPRITEROT|VHSF_CARDINALS|VHSF_16ANGLES,lightcolor:(255,195,165),512,spotlightangles:(25,50)));
		Headlights.Push (SpawnVehicleHeadlight (Self,(128,56,32),VHSF_SPRITEROT|VHSF_BACKLIGHT|VHSF_CARDINALS|VHSF_16ANGLES,lightcolor:(255,150,0),64,spotlightangles:(45,90)));
		Headlights.Push (SpawnVehicleHeadlight (Self,(128,-56,32),VHSF_SPRITEROT|VHSF_BACKLIGHT|VHSF_CARDINALS|VHSF_16ANGLES,lightcolor:(255,150,0),64,spotlightangles:(45,90)));
	}
	
	Override Void Die (Actor Source, Actor Inflictor, Int DmgFlags, Name MeansOfDeath)
	{
		If (WarningZone) WarningZone.Destroy();
		If (Retreating)
		{
			A_SetSpriteRotation (0);
			A_SetAngle (Angle+180);
			Retreating = False;
			RetreatLoops = 0;
		}
		Super.Die (Source, Inflictor, DmgFlags, MeansOfDeath);
	}
	
	Override Void OnDestroy()
	{
		Super.OnDestroy();
		If (WarningZone) WarningZone.Destroy();
	}
	
	//Produce crushing related obituaries for players.
	Override String GetObituary (Actor Victim, Actor Inflictor, Name MOD, Bool PlayerAttack)
	{
		String MeleeObituaries[] = {
		"%o was ran over by a tank",
		"%o didn't check both ways when crossing the street",
		"%o became roadkill",
		"%o is practicing their skidmark impression"
		};
		If (Inflictor == Self && (MOD == 'Crush' || MOD == 'TankCrush'))
		{
			//Print a "special" obituary if the player was intentionally crushed by the tank.
			If (Target == Victim && User_CrushMode == CRUSH_ACTIVE && Random (0,255) < 255/4) //4/6/1989
			{
				Let Checker = SM_MarineChecker(EventHandler.Find ("SM_MarineChecker"));
				String PlayerName;
				If (Victim && Victim.Player)
					PlayerName = Victim.Player.GetUsername();
				Else If (Victim)
					PlayerName = Victim.GetTag();
				Return String.Format ("%s 没有被压碎 %s",PlayerName,Checker.ScopeHack.Date);
			}
			Else
				Return MeleeObituaries[Random(0,MeleeObituaries.Size()-1)];
		}
		
		Return Super.GetObituary (Victim, Inflictor, MOD, PlayerAttack);
	}
	
	//If too many ranged enemies are near the target, especially powerful ones, avoid crushing.
	Int DoNotCrush (Actor Other)
	{
		If (!Other) Return 0;
		Int Penalty;
		Actor Mobj;
		Let Enemies = BlockThingsIterator.Create (Other,768);
		While (Enemies.Next())
		{
			Mobj = Enemies.Thing;
			
			If (!Mobj || Mobj == Self || Mobj == Other || IsInanimateObject (Mobj) || IsDead (Mobj) || !IsActorHostile (Mobj)) Continue;
			
			If (IsMeleeOnlyEnemy (Mobj) || Other.Distance3DSquared (Mobj) > 768*768 || !CheckSight (Mobj)) Continue;
			
			//Increase the penalty in accordance to how dangerous the enemies around the Other actor are.
			Switch (AssessThreatLevel (Mobj))
			{
				Case THREAT_UNSTOPPABLE:
					Penalty += 1000;
					Break;
				Case THREAT_SUPERDANGER:
					Penalty += 200;
					Break;
				Case THREAT_VERYDANGEROUS:
					Penalty += 50;
					Break;
				Case THREAT_DANGEROUS:
					Penalty += 25;
					Break;
				Default:
					Break;
			}
		}
		Return Penalty;
	}
	
	Bool IsMeleeOnlyEnemy (Actor Other)
	{
		Return (Other && Other.MeleeState && !Other.MissileState);
	}
	
	//Finds a living enemy to crush within Range, and sets it as the tanks' target.
	//FOV: The FOV to use for the sight check.
	//Range: The range to find a victim to run over in.
	//MaxTurretRange: If the turrets' target is outside of this range from it, begin chasing that target instead.
	Void MBT_RunShitOver (Double FOV = 45, Double Range = 512, Double MaxTurretRange = 2048)
	{
		If (Range <= 0 || bNoCrushing) Return;
		//The turrets' target is too far from it or out of sight. So start chasing that instead.
		If (Turret && Turret.Target && (Turret.Distance3DSquared (Turret.Target) > MaxTurretRange || !Turret.CheckSight(Turret.Target)))
		{
			Target = Turret.Target;
			Return;
		}
		If (Health < 1000) Return;
		Actor Mobj;
		Array <Actor> Candidates;
		Let Roadkills = BlockThingsIterator.Create (Self,Range);
		While (Roadkills.Next())
		{
			Mobj = RoadKills.Thing;
			
			If (!Mobj || Mobj == Self) Continue;
			If (IsDead (Mobj) || IsInanimateObject (Mobj) || IsFlying (Mobj) || !IsCollidable (Mobj,Self) || !CanBeTargeted(Self,Mobj) || !IsActorHostile (Mobj)) Continue;
			
			If (Mobj.Speed >= Speed*2 || Mobj.Speed >= Speed && Mobj.Target && Mobj.bFrightened) Continue; //Too fast to catch. Or faster than you and running away.
			
			Int Level = AssessThreatLevel (Mobj,True);
			
			//Don't fuck with super dangerous enemies.
			Switch (Level)
			{
				Case THREAT_DANGEROUS:
				Case THREAT_VERYDANGEROUS:
				Case THREAT_SUPERDANGER:
				Case THREAT_UNSTOPPABLE:
					Continue;
				Default:
					Break;
			}
			
			//If it's not a really weak enemy and they have some kind of range attack, avoid them. If they are weak, ignore that they have a range attack.
			If (Level >= THREAT_NORMAL && Mobj.MissileState) {a_log ("ranged");Continue;}
			
			//And at last, the distance and sight checks.
			If (Distance3DSquared (Mobj) > Range*Range || !CheckSight (Mobj)) {a_log ("distance and sight");Continue;}
			
			Candidates.Push(Mobj);
		}
		
		If (!Candidates.Size())
			Return;
		
		Target = GetClosestActor (Candidates,Self.Pos,Range);
	}
	
	Void A_MBTLook ()
	{
		If (User_CrushMode != CRUSH_PASSIVE)
			MBT_RunShitOver (220,TankCrushRange); //Find something to run over.
		If (!Target) //Nothing found, just look for actors normally.
			KAI_Look (User_Stationary ? LOF_NOJUMP : 0,maxseedist:MaxTargetRange,8192,220);
		If (Turret && Turret.Target && !IsDead(Turret.Target)) //Still no target, so get your turrets' target instead.
		{
			Target = Turret.Target;
			If (!User_Stationary) SetStateLabel ("See");
		}
	}
	
	// For the SPAAG, make it do more damage to flying actors using DoSpecialDamage on both the projectile and hitscan shrapnel puffs.
	// Design wise, the back radar of the SPAAG should have a separate REAL hitbox that receives damage. Whose relative position snaps based on the turret angle.
	Enum TurretTypes
	{
		TURRET_NORMAL	= 0, //The normal MBT variant.
		TURRET_TOS1		= 1, //Thermobaric rocket artillery variant, no gravity affected rockets because I'm not THAT nuts (Actually good at programming).
		TURRET_BMPT		= 3, //Light tank-ish variant of the tank. With only machine guns and rockets, and less health.
		TURRET_SPAAG	= 4, //AA variant of the tank, with a functional top radar.
	}
	
	Const TankAngleLimit = 3; //How much the tank can turn per step.
	Const TankCrushRange = 640;
	Bool Retreating;
	Int RetreatLoops;
	Actor WarningZone;
	
	Bool HasAltHull;
	
	Bool User_FocusFire; //Should the tanks' remote weapon station, if any, not always try to not have the same target as the turret ?
	Bool User_Stationary; //The tank always stays in place, similar to the HECU M1 Abrams tanks from Half-Life 1.
	//Original code donut stael.
	//Main difference is that this control both corpse AND live enemy crushing.
	Int User_CrushMode;
	Enum CorpseCrushModes
	{
		CRUSH_NONE = -1, //No crushing at all, only pushing.
		CRUSH_ACTIVE = 0, //Actively seek corpses and enemies.
		CRUSH_PASSIVE = 1 //Crush enemies and corpses, but only by happenstance.
	};
	String User_RWS; //What remote weapon station should the tank use ? The two types are MG and Minigun.
	States
	{
		Sprites:
			AMBT ABCDEF 0;
		Spawn:
			MMBT A 0 NoDelay {Sprite = !HasAltHull ? GetSpriteIndex ("MMBT") : GetSpriteIndex ("AMBT");}
			#### A 1
			{
				A_StopSound (CHAN_MOVING);
				A_StartSound("Vehicle/Tank/Idle",CHAN_IDLING,CHANF_LOOPING,attenuation:0.5);
				A_MBTLook();
			}
			Loop;
		//High quality code rips.
		Idle:
			#### ABCDEF 2
			{
				A_QuakeEx (1,1,1,2,0,512,flags:QF_GROUNDONLY,rollintensity:0.2);
				A_StopSound (CHAN_IDLING);
				A_StartSound (ActiveSound,CHAN_MOVING,CHANF_LOOPING,attenuation:0.6);
				
				A_MBTLook();
				
				//Archvile trolling move activated.
				If (User_CrushMode == CRUSH_ACTIVE)
				{
					If (CorpseTarget && CorpseTarget.bDontGib) CorpseTarget = Null; //Disgard crushed corpses.
					//Don't have a corpse to crush already.
					If (!CorpseTarget)
					{
						CorpseTarget = FindNearestCorpse(); //Nearby corpse found, go and crush it.
						If (CorpseTarget) 
							KAI_MoveTowards (CorpseTarget.Pos,0.8,8);
						Else //Still no corpse found, so just begin wandering around.
							KAI_Wander(48,1024,128,0.5,TankAngleLimit);
					}
					
					//There is an available corpse to head to and crush.
					If (CorpseTarget)
						KAI_MoveTowards (CorpseTarget.Pos,0.8,8);
				}
				Else
					KAI_Wander(48,1024,128,0.5,TankAngleLimit);
				
				FollowPlayerControl (512);
				
				If (User_CrushMode != CRUSH_NONE) KAI_CrushCorpses();
			}
			Loop;
		See:
			#### ABCDEF 2
			{
				A_QuakeEx (1,1,1,2,0,512,flags:QF_GROUNDONLY,rollintensity:0.2);
				If (User_Stationary) //Shouldn't be here.
					Return State (SpawnState);
				//Console.Printf ("Sprite angle offset %d",SpriteRotation);
				A_StopSound (CHAN_IDLING);
				A_StartSound (ActiveSound,CHAN_MOVING,CHANF_LOOPING,attenuation:0.5);
				//Try to find someone else to run over before the stock retargeting code runs.
				If (User_CrushMode == CRUSH_ACTIVE)
					If (!Target || Distance3DSquared (Target) > TankCrushRange*TankCrushRange || IsFlying(Target))
						MBT_RunShitOver (360,TankCrushRange);
				
				MoveToParams Params;//console.printf ("retreat dist %d",retreatrange);
				Params.DetourFactor = 0.25;
				Params.Attempts = 32;
				Params.StepThreshold = 32;
				Params.RunRad = 384;
				Bool TargetLevel = AssessThreatLevel (Target);
				//Zig zag around target as long as you are far away to not need to move straight to it. Or if the target is too dangerous or you're weak.
				Bool DoZigZag = (Target && (TargetLevel < ThreatLevelThreshold && Health >= 1000 && Distance3DSquared(Target) > 768*768 && CheckSight(Target)));
				Int RealRange = RetreatRange;
				//If moving to a target that is below the threat threshold, never retreat. In other words, don't retreat when trying to run over someone.
				//But do retreat if there's too many dangerous enemies around the target, or you are going to fire an explosive shell and are too close.
				If (DoNotCrush (Target) >= 50 || MVP_MBTTurret(Turret).ShellType == MVP_MBTTurret(Turret).TYPE_APFSDS || Target && Turret.Distance3DSquared (Target) <= 640*640)
					If (TargetLevel < ThreatLevelThreshold && User_CrushMode == CRUSH_ACTIVE && Health > 1000) RetreatRange = 0;
				KAI_LandVehicleChase (flags:LVC_USERETREATSTATE|LVC_PLAYERSASTHREATS|LVC_MAKEFRIENDSIDLE|(DoZigZag ? LVC_ZIGZAGGING : 0),turnradius:TankAngleLimit,512);
				RetreatRange = RealRange;
				If (User_CrushMode != CRUSH_NONE) KAI_CrushCorpses();
				Return State (Null);
			}
			Loop;
		//Retreat by "reversing", AKA calling KAI_VehicleRetreat, but using SpriteRotation and an inverted move animation to appear as facing the target.
		Retreat:
			#### A 0
			{
				If (User_Stationary) //Shouldn't be here.
					Return State (SpawnState);
				Retreating = True;
				A_SetSpriteRotation (180);
				A_SetAngle (Angle-180);
				Return State (Null);
			}
		Retreat.Move:
			#### FEDCBA 2
			{
				A_QuakeEx (1,1,1,2,0,512,flags:QF_GROUNDONLY,rollintensity:0.2);
				A_StopSound (CHAN_IDLING);
				A_StartSound (ActiveSound,CHAN_MOVING,CHANF_LOOPING,attenuation:0.5);
				KAI_VehicleRetreat (Target,96,512,32,VRF_ZIGZAG,0.25,TankAngleLimit);
				If (User_CrushMode != CRUSH_NONE) KAI_CrushCorpses();
			}
		Retreat.End:
			#### A 0
			{
				//Target no longer in sight, keep retreating for a bit before moving forward again.
				If (!RetreatLoops && RetreatLoops != -1)
				{
					If (!CheckSight(Target))
						RetreatLoops = Random (12,24);
					If (!RetreatLoops && !FindNearestEnemy (RetreatRange))
						RetreatLoops = Random (4,8);
					If (!RetreatLoops && Turret && Turret.Target && Turret.ElevationState != Turret.ELEVATION_TOOHIGH)
						RetreatLoops = Random (6,12);
					
					RetreatLoops = Random (12,24);
				}
					//console.printf ("loops %d",retreatloops);
				If (RetreatLoops > 0 && Target && !IsDead (Target))
				{
					RetreatLoops--;
					If (RetreatLoops == 0)
						RetreatLoops--;
					Return FindState ("Retreat.Move",True);
				}
					
				A_SetSpriteRotation (0);
				A_SetAngle (Angle+180);
				RetreatLoops = 0;
				Retreating = False;
				Return State (Null);
			}
			Goto See;
	}
}

//Normal tank turret. Can attack with its' attached RWS (If any), it's 130mm cannon with 3 shell types, and its' 7.62mm coaxial machine gun.
Class MVP_MBTTurret : MVP_BaseTurret
{
	Default
	{
		XScale 1;
		YScale 0.833333; //1 / 1.2
		Health 2500;
		Height 32;
		Radius 72;
		FriendlySeeBlocks 128;
		MaxTargetRange 16384;
		Mass 30000;
		Tag "M6V3-EX Turret";
		Obituary "%o was blown up by a tank turret";
		KAI_BaseTurret.MaximumPitch -20;
		KAI_BaseTurret.MinimumPitch 10;
		KAI_BaseTurret.TurnSoundRadius 0.5;
		KAI_BaseVehicle.SearchTime 175;
		//The attack speeds for the target prediction dynamically change based on the ammo type. For example APFSDS will be faster than HEAT.
		KAI_BaseTurret.AttackSpeed 300;
		KAI_BaseTurret.FastAttackSpeed 350;
		KAI_BaseTurret.CombatAngleTurnRate 40;
		KAI_BaseTurret.CombatPitchTurnRate 30;
		KAI_BaseTurret.TurnSound "Vehicle/Tank/TurretTurn";
		KAI_Actor.ThreatLevel THREAT_VERYDANGEROUS;
		+KAI_BaseTurret.TransferDamage;
		+KAI_BaseTurret.TurnSoundNoStop;
		+MissileMore;
		+MissileEvenMore;
		
		//"Armor"
		DamageFactor 0.6; //Generic damage factor.
		DamageFactor "ExplosiveImpact", 0.5;
		DamageFactor "Explosion", 0.5;
		DamageFactor "Explosive", 0.5;
		DamageFactor "TankShell", 0.5;
		DamageFactor "Shell", 0.7;
		DamageFactor "APShell", 1.0; //Super susceptible to APFSDS.
		DamageFactor "Grenade", 0.4;
		DamageFactor "HitScan", 0.55; //The generic damage type of hitscan attacks.
		DamageFactor "Shrapnel", 0.2;
		DamageFactor "Fire", 0.3;
		DamageFactor "Plasma", 0.5;
		//Damage factors specific to the Smart Marines.
		DamageFactor "MarineHMG", 0.5;
		DamageFactor "MarineGrenade", 0.5;
		DamageFactor "MarineRifle", 0.55;
		//Vehicle damage factors
		DamageFactor "Autocannon", 0.5;
		DamageFactor "RifleBullet", 0.6;
		DamageFactor "Missile", 0.7;
	}
	
	Int UpdateTankElevation (Int FaceDown, Int FaceStraight, Int FaceUp, Int FaceUp2)
	{
		If (Pitch >= 10 && Pitch >= 5)
			Return FaceDown;
		Else If (Pitch < 10 && Pitch >= -10)
			Return FaceStraight;
		Else If (Pitch < -10 && Pitch >= -17)
			Return FaceUp;
		Else If (Pitch <= -20)
			Return FaceUp2;
		
		Return FaceStraight;
	}
	
	Override Void OnDestroy()
	{
		Super.OnDestroy();
		If (WarningZone) WarningZone.Destroy();
	}
	
	Override Void Die (Actor Source, Actor Inflictor, Int DmgFlags, Name MeansOfDeath)
	{
		If (WarningZone) WarningZone.Destroy();
		Super.Die (Source, Inflictor, DmgFlags, MeansOfDeath);
	}
	
	Override String GetObituary (Actor Victim, Actor Inflictor, Name MOD, Bool PlayerAttack)
	{
		String GodKillObituaries[] = {
		"%o got that shit eating grin wiped off %p face",
		"%o got %p cheating award",
		"%o discovered that cheaters never prosper",
		"%o isn't as indestructible as %g thinks"};
		
		If (Inflictor Is "MVP_MBTFireEffect") //Caught in the firing blast.
			Return "%o stood too close to a tank";
		If (Inflictor Is "MVP_RifleBullet") //Coaxial
			Return "%o was gunned down by a tanks' coaxial machine gun";
		If (Inflictor Is "MVP_HEATShell") //Took 10 kilos of explosive to the face.
			Return Inflictor.Obituary;
		
		//Print special obituaries for players with god mode or the bInvulnerable flag who got killed by the APFSDS round.
		If (Inflictor Is "MVP_APFSDSShell" && MVP_APFSDSShell(Inflictor).KilledCheater)
			Return GodKillObituaries[Random(0,GodKillObituaries.Size()-1)];
		
		If (Inflictor Is "MVP_APFSDSShell") //APFSDS killed normal player.
			Return Inflictor.Obituary;
		Return Super.GetObituary (Victim, Inflictor, MOD, PlayerAttack);
	}
	
	Override Void PostBeginPlay ()
	{
		Vector3 Original = TurretOffsets;
		/*NOTE: The RWS can never look perfect due to the tank being made out of sprites. A Z offset of 0 looks like the station is sunken into its' platform
		from the front, but from the side makes it look actually attached. While a Z of 3 looks normal from the front, but makes the RWS float on the side.*/
		TurretOffsets = (-6,7.5,3);
		Super.PostBeginPlay();
		TurretOffsets = Original;
		
		MissileState = FindState ("Fire",True);
		AttackStates.Push (FindState("Fire",True));
		AttackStates.Push (FindState("Fire.Coaxial",True));
		WarningZone = WarnMarines (0,48,Self); //Default radius for the coaxial.
	}
	
	//Don't use the threat assessment of MVP vehicles, which considers players and marines on turrets as huge deal. Since they do little against the tank.
	Override Int AssessThreatLevel (Actor Other, Bool CheckPlayers)
	{
		If (!Other) Return THREAT_NONE;
		Int ThreatLvl = KAI_BaseVehicle.AssessThreatLevel(Other, CheckPlayers);
		//If the unstoppable threat is a player with god or buddha mode 1. Or an invulnerable but non-NODAMAGE NPC.
		//Then don't consider them as much of a threat, since APFSDS still kills them.
		If (ThreatLvl == THREAT_UNSTOPPABLE)
		{
			//Downgrade the threat if it doesn't have god or buddha 2, or NODAMAGE. And also if it doesn't have an esoteric flag combo that makes it untouchable.
			If (Other.Player && !(Other.Player.Cheats & (CF_GODMODE2|CF_BUDDHA2)) && !Other.bNoDamage && !(Other.bNonShootable && Other.bNoBlockmap && Other.bNoRadiusDmg))
				Return THREAT_SUPERDANGER; //It's not unstoppable, merely insanely dangerous.
		}
		Return ThreatLvl;
	}
	
	Override Bool ShouldAttack (Bool NoStateJump)
	{
		If (!KAI_BaseTurret.ShouldAttack()) Return False;
		If (Target && !CheckFOV (Target,60/2)) Return False; //KLUDGE: We need to do the null check here, because as of GZDoom 4.10, it's not done internally. Crashing the game.
		If (IsOverPitchLimits (Target,8,Target.Height/2) != ELEVATION_INBOUNDS) Return False;
		If (Target == Self || !KAI_CheckMissileRange(Target,CMR_INVERTDIST) || IsDead (Target) || !IsActorHostile (Target)) Return False;
		
		Int Threat = AssessThreatLevel (Target);
		
		//If the cannon is busy loading, use the coaxial instead.
		If (ReloadTime)
		{
			MaxTargetRange = 8192; //Lower the range for the coaxial.
			CoaxialShots = Random (1,2)*10;
			If (Distance3DSquared (Target) < MaxTargetRange*MaxTargetRange && KAI_TurretCheckLOF (Target,150,0,(0,-10,20)))
				If (!NoStateJump) SetStateLabel ("Fire.Coaxial");
			MaxTargetRange = Default.MaxTargetRange;
			Return True;
		}
		
		//Fire, the shell type to use should be decided in Tick() by DecideAmmoType().
		If (!ReloadTime)
		{
			//Try targeting a stronger enemy.
			Actor OldTarg = Target;
			A_FindStrongEnemy (Target, Target, 1024);
			If (Random (0,255) < 192)
				Target = OldTarg;
			If (Target != OldTarg) a_log ("found something stronger to hit");
			If (!NoStateJump) SetStateLabel ("Fire");
		}
		
		Return False;
	}
	
	//Fire a ray from the direction the turret is facing and return a position to where the ray stopped, which should also be where the projectile with hit.
	Override Vector3 GetAttackLocation ()
	{
		Let Check = New ("MVP_GenericWarnMarineCheck");
		
		Vector3 Direction = (AngleToVector(Angle, Cos(Pitch)), -Sin(Pitch));
		
		Check.Shooter = Self;
		Check.Other = Target;
		Check.Trace ( Level.Vec3Offset (Pos,(0,0,14)), CurSector, Direction, MaxTargetRange, 0 );
		
		Return Check.Results.HitPos;
	}
	
	Override Void Tick()
	{
		If (IsFrozen()) Return;
		
		//Reverse the direction of the turret when retreating, calling this before Super.Tick() makes the transition seamless.
		If (!IsDead (Self) && Master && Master Is "MVP_MBT")
			TurretRotationOffset = MVP_MBT(Master).Retreating ? -180 : 0;
		
		Super.Tick();
		
		WarningZone.SetOrigin (GetAttackLocation(),True); //Track warn zone to aim direction.
		
		//Decide an attack type every half a second.
		If (ReadyToDecide && GetAge() % GameTicRate/2 == 0)
		{
			ShellType = DecideAmmoType();
			//if (shelltype == type_heat)
				//console.printf ("chose HEAT");
			//else if (shelltype == type_apfsds)
				//console.printf ("chose APFSDS");
			//else if (shelltype == type_atgm)
				//console.printf ("chose ATGM");
			//else if (shelltype == type_none)
				//console.printf ("chose none (coaxial)");
		}
		
		If (ReloadTime)
			ReloadTime--;
			
		//console.printf ("reload time %d",reloadtime);
	}
	
	//Finds a strong enemy around the origin, and sets it as the turrets' target, so that the APFSDS round can destroy it.
	Bool A_FindStrongEnemy (Actor Avoid, Actor Origin, Double CheckRange)
	{
		If (!Avoid || !CheckRange || !Origin) Return False;
		
		Array <Actor> TargetList;
		
		BlockThingsIterator EnemyFinder = BlockThingsIterator.Create (Origin,CheckRange);
		
		CheckRange *= CheckRange; //Do the multiplication for Distance3DSquared only once.
		
		While (EnemyFinder.Next())
		{
			Actor Mobj = EnemyFinder.Thing;
			
			If (!Mobj || Mobj == Avoid) Continue; //AVOID THIS TARGET.
			
			If (Mobj.bDormant || IsInanimateObject (Mobj)) Continue; //Don't attack dormant or inanimate object actors.
			
			If (AssessThreatLevel (Mobj) < ThreatLevelThreshold) Continue; //Not strong enough to target.
			
			If (!CanBeTargeted(Self, Mobj)) Continue; //Can't be targeted. (Duh)
			
			If (IsDead (Mobj)) Continue; //Is dead (Duuuuuuuuuuh)
			
			If (Origin.Distance3DSquared(Mobj) > CheckRange) Continue; //Too out of reach.
			
			If (!IsActorHostile (Mobj)) Continue; //Actor isn't hostile.
			
			If (!CheckSight(Mobj)) Continue; //Actor is not visible.
			console.printf ("relationship ended with %s, now %s is my worst enemy",target.getclassname(),mobj.getclassname());
			Target = Mobj;
			Return True;
		}
		Return False;
	}
	
	//Finds the nearest visible enemy vehicle.
	Actor A_FindEnemyVehicle()
	{
		Let VehFind = ThinkerIterator.Create ("KAI_BaseVehicle");
		Actor Mobj;
		While (Mobj = Actor(VehFind.Next()))
		{
			If (Mobj.bDormant || IsInanimateObject (Mobj)) Continue; //Don't attack dormant or inanimate object actors.
			
			If (AssessThreatLevel (Mobj) < THREAT_ABOVENORMAL) Continue; //Not strong enough to target.
			
			If (!CanBeTargeted(Self, Mobj)) Continue; //Can't be targeted. (Duh)
			
			If (IsDead (Mobj)) Continue; //Is dead (Duuuuuuuuuuh)
			
			If (!IsActorHostile (Mobj)) Continue; //Actor isn't hostile.
			
			If (!CheckSight(Mobj)) Continue; //Actor is not visible.
			
			Return Mobj;
		}
		Return Null;
	}
	
	//The generic projectile check does have ripper checks, but whatever, this will do for a million dollar lawn dart that goes through everything.
	Bool A_CheckAPFSDSLOF()
	{
		If (!CheckSight(Target)) Return False;
		Array <Actor> Targ;
		KAI_FindInLOF (FIL_FACETARGET|FIL_MISSILEHIT,MaxTargetRange,32,(0,0,16),Target,Targ);
		For (Int I = Targ.Size()-1; I >= 0; I--)
			If (Targ[I] == Target)
				Return True;
		a_log ("wah wah waaaaaaah");
		Return False;
	}
	
	//Decide and return what ammunition type to use for the tank. And also change the target prediction speeds appropriately.
	Int DecideAmmoType()
	{
		If (!Target) Return ShellType;
		Int Threat = AssessThreatLevel (Target);
		
		//High chance that if your target is strong or a strong enemy is near it, the tank will fire the APFSDS shell.
		If (Random (0,255) < 200 && (Threat >= ThreatLevelThreshold || A_FindStrongEnemy (Target, Target, 1024)) && A_CheckAPFSDSLOF())
		{a_log ("getting ready for APFSDS");
			//Very small chance to fire a missile instead of a HEAT shell.
			If (Random (0,255) < 4)
			{
				TurretAttackSpeed = GetDefaultByType("MVP_ATGM").Speed; FastTurretAttackSpeed = GetDefaultByType("MVP_ATGM").FastSpeed;
				Return TYPE_ATGM;
			}
			TurretAttackSpeed = GetDefaultByType("MVP_APFSDSShell").Speed; FastTurretAttackSpeed = GetDefaultByType("MVP_APFSDSShell").FastSpeed;
			Return TYPE_APFSDS;
		}
		
		//MAYDO: Have the LOF check call TLOF_FACEOTHER, since this is a homing projectile anyway ?
		//Fire a guided missile at crowds of enemies, or monsters that fit these conditions:
		Bool FastBoi = (Target.Speed >= 50); //Too fast, and likely unpredictable, to hit with a shell.
		Bool FastDistantBoi = (Target.Speed >= 25 && Distance3DSquared(Target) > 8192*8192); //Same, but for less fast enemies, that are still very far.
		Bool Is3ZipcodesAway = (Distance3DSquared(Target) > 14000*14000); //Even the smallest movement would cause a shell to miss.
		If ((Random (0,255) < 64 || FastBoi || FastDistantBoi || Is3ZipcodesAway) && (Threat > THREAT_MILD || AttackByQuantity (Target, 512) >= 200)
		&& KAI_TurretCheckLOF (Target,0,512,(0,0,16)))
		{
			TurretAttackSpeed = GetDefaultByType("MVP_ATGM").Speed; FastTurretAttackSpeed = GetDefaultByType("MVP_ATGM").FastSpeed;
			Return TYPE_ATGM;
		}
		
		//If your enemy isn't ridiculously weak, or there's enough enemies around it to justify it, then fire the HEAT shell.
		If ((Threat > THREAT_NORMAL || AttackByQuantity (Target, 512) >= 250) && KAI_TurretCheckLOF (Target,0,512,(0,0,16),TLOF_OnlyAhead))
		{console.printf ("getting ready for HEAT");
			//Small chance to fire a missile instead of a HEAT shell.
			If (Random (0,255) < 8)
			{
				TurretAttackSpeed = GetDefaultByType("MVP_ATGM").Speed; FastTurretAttackSpeed = GetDefaultByType("MVP_ATGM").FastSpeed;
				Return TYPE_ATGM;
			}
			TurretAttackSpeed = GetDefaultByType("MVP_HEATShell").Speed; FastTurretAttackSpeed = GetDefaultByType("MVP_HEATShell").FastSpeed;
			Return TYPE_HEAT;
		}
		//Otherwise get the coaxial gun to fire a few shots at it.
		Else
		{
			MaxTargetRange = 8192; //Lower the range for the coaxial.
			If (KAI_CheckMissileRange(Target,CMR_INVERTDIST) && KAI_TurretCheckLOF (Target,150,0,(0,-10,20)))
			{a_log ("getting ready for coaxial");
				TurretAttackSpeed = GetDefaultByType("MVP_RifleBullet").Speed; FastTurretAttackSpeed = GetDefaultByType("MVP_RifleBullet").FastSpeed;
				a_log ("firing the coaxial");
				CoaxialShots = Random (2,4)*10;
				MaxTargetRange = Default.MaxTargetRange; //Reset the max range to normal.
				Return TYPE_NONE;
			}
		}
		MaxTargetRange = Default.MaxTargetRange;
		TurretAttackSpeed = Default.TurretAttackSpeed; //When falling back to HEAT, use the default speeds, since they are for heat.
		FastTurretAttackSpeed = Default.FastTurretAttackSpeed;

		Return TYPE_HEAT;
	}
	
	Enum AmmoTypes
	{
		TYPE_NONE	= 0, //Special none type. If ShellType is this, then it likely means that the tank should use the coax gun.
		TYPE_HEAT 	= 1, //Standard ammo type, used for weak (Relatively) enemies, groups, etc.
		TYPE_APFSDS	= 2, //Ripper that does a shitton of damage. Used for powerful enemies, like Cyberdemons and players with god/buddha mode 1.
		TYPE_ATGM	= 3, //Homing missiles, have a chance to be fired at powerful enemies, and distant and/or fast enemies.
	}
	
	Void A_TankFire (Int Type = TYPE_HEAT)
	{
		Double Vol = (Type == TYPE_ATGM) ? 0.5 : 1.0; //Quiet the firing sound when firing guided missiles.
		A_StartSound ("Vehicle/Tank/CannonFire",CHAN_WEAPON,CHANF_OVERLAP,Vol,0.1);
		
		Actor Shell;
		//Normal high explosive shell. The stock exploding projectiles tanks usually fire in media.
		If (Type == TYPE_HEAT)
			Shell = A_SpawnProjectile ("MVP_HEATShell",16,flags:CMF_AIMDIRECTION,Pitch);
		//Depleted uranium dart, useful for individual powerful enemies like bosses and cheaters.
		Else If (Type == TYPE_APFSDS)
			A_SpawnProjectile ("MVP_APFSDSShell",16,flags:CMF_AIMDIRECTION,Pitch);
		//Gun launched homing missile. For fast and/or distant targets.
		Else If (Type == TYPE_ATGM)
			A_SpawnProjectile ("MVP_ATGM",16,flags:CMF_AIMDIRECTION,Pitch);
		
		Vector3 FXPos = (224,0,0);
		Vector3 BorePos = (188,0,0);
		//The closer the tank fires to the ground, the more smoke and dust it kicks up.
		Switch (Frame)
		{
			Case 14: //Aiming up (very).
				SmokeCounter = 0;
				FXPos.Z = 64;
				BorePos.X -= 6;
				BorePos.Z = 48;
				Break;
			Case 11: //Aiming up.
				SmokeCounter = 8;
				FXPos.Z = 40;
				BorePos.X -= 16;
				BorePos.Z = 32;
				Break;
			Case 8: //Aiming ahead.
				SmokeCounter = 16;
				FXPos.Z = 16;
				BorePos.Z = 24;
				Break;
			Case 17: //Aiming down.
				SmokeCounter = 32;
				FXPos.Z = -16;
				BorePos.X -= 8;
				BorePos.Z = -6;
				Break;
			Default:
				SmokeCounter = 32; //Default ground smoke and dust amount.
				FXPos.Z = 16;
				BorePos.Z = 24;
				Break;
		}console.printf ("z axis is %d",fxpos.z);
		
		If (Type != TYPE_ATGM) //The gun launched missile has no firing effect, it's just spat out the barrel like a grenade, since it's self propelled.
		{
			//Firing effect.
			Int Trash; Double SpriteAngle = GetNearestCardinalAngle (True)-180;
			Actor FX;
			[Trash, FX] = A_SpawnItemEx ("MVP_MBTFireEffect",FXPos.X,FXPos.Y,FXPos.Z,angle:SpriteAngle,SXF_ABSOLUTEANGLE);
			FX.bAlwaysPuff = False; //Spawn our own, smaller shockwave ring. Or maybe none at all.
			FX.Scale *= 0.75;
			FX.Target = Self; //So enemies caught in the firing blast know who to blame.
			
			//Dust control.
			FX.RadiusDamageFactor = 0.5; //How much dust is not spawned, based on height off the ground.
			FX.ReactionTime = 88; //Extra dusty.
			FX.Threshold = 196; //Dust spawn radius.
			
			//Bore evacuator smoke.
			For (Int I = 0; I < 16; I++)
			{
				//Vector3 SpawnPos = Vec3Offset (BorePos.X,BorePos.Y,BorePos.Z);
				Quat Dir = Quat.FromAngles (SpriteAngle,0,0);
				Vector3 SpawnPos = Level.Vec3Offset (Pos,Dir * BorePos);
				FX = Spawn ("MVP_DamageSmoke",Level.Vec3Offset (SpawnPos,(FRandom (6,-6),FRandom (6,-6),0)));
				FX.Scale *= FRandom (0.35,0.55);
				FX.Roll = FRandom(-180,180);
				FX.Vel.X = FRandom (2,-2);
				FX.Vel.Y = FRandom (2,-2);
				FX.Vel.Z = FRandom (1,2);
			}
		}
	}
	
	Actor WarningZone; //After the tank is finished, the marines' crude warning system will be turned into a generic hazard system for the library.
	Int ShellType; //What the turret will fire.
	Bool ReadyToDecide; //Tells the turret to decide what shell to fire during the 2 second firing delay.
	Int ReloadTime; //How long until the turret is ready to fire.
	Int CoaxialShots; //How many shots to fire in the coaxial state before stopping.
	
	States
	{
		Spawn:
			MMBT G 0;
			MMBT # 1
			{
				RotateToVehicle();
				KAI_Look (maxseedist:MaxTargetRange,8196,120,extraflags:KAIL_CHASETARGET);
				Frame = UpdateTankElevation (15,6,9,12); //P, G, J, M
			}
			Loop;
		See:
			MMBT # 1
			{
				DoCombatTraverse();
				RotateToVehicle();
				KAI_LandVehicleChase (LVC_NOTURRETRETARGET,chaseflags:CHF_DONTIDLE|CHF_DONTMOVE);
				RetargetVehicleHull (RVHF_STRONGERHULL); //Target the enemy vehicles' hull if it is healthier than the turret. Especially useful for APFSDS.
				UpdateTurretSnapTimer();

				Frame = UpdateTankElevation (15,6,9,12); //P, G, J, M
			}
			Loop;
		//Firing the cannon.
		Fire:
			MMBT # 0 A_JumpIf (ReloadTime > 0,"See");
			//The calm before the storm.
			MMBT # 0
			{
				A_StartSound ("Vehicle/Tank/Reload",CHAN_WEAPON,attenuation:0.7);
				ReadyToDecide = True; //Start deciding what to shoot in the last 2 seconds before firing.
				If (WarningZone) WarningZone.MaxTargetRange = 512; //Set the range of the marine warn zone to the HEAT shells' blast radius.
				DecideAmmoType();
				If (!(Target Is "KAI_BaseVehicle"))
				{
					Actor New = A_FindEnemyVehicle();
					If (New) Target = New;
				}
			}
			MMBT ###################################################################### 1
			{
				DoCombatTraverse(); //Soon
				Frame = UpdateTankElevation (15,6,9,12); //P, G, J, M
			}
			MMBT # 0
			{
				If (ShellType == TYPE_NONE)
				{
					If (WarningZone) WarningZone.MaxTargetRange = 48;
					TurretAttackSpeed = GetDefaultByType("MVP_RifleBullet").Speed; FastTurretAttackSpeed = GetDefaultByType("MVP_RifleBullet").FastSpeed;
					Return FindState ("Fire.Coaxial");
				}
				Return State (Null);
			}
			//Perish
			MMBT # 2
			{
				ReadyToDecide = False;
				Frame = UpdateTankElevation (17,8,11,14); //R, I, L, O
				A_TankFire (ShellType); //This is where the magic happens.
				
				//Revert to the coaxial until next load.
				If (WarningZone) WarningZone.MaxTargetRange = 48;
				ShellType = TYPE_NONE;
				TurretAttackSpeed = GetDefaultByType("MVP_RifleBullet").Speed; FastTurretAttackSpeed = GetDefaultByType("MVP_RifleBullet").FastSpeed;
			}
			MMBT ## 2 {Frame = UpdateTankElevation (17,8,11,14);} //R, I, L, O
			MMBT ## 2 {Frame = UpdateTankElevation (15,6,9,12);} //P, G, J, M
			MMBT # 8
			{
				ReloadTime = 5*GameTicRate;
				Frame = UpdateTankElevation (15,6,9,12); //P, G, J, M
			}
			Goto See;
		//Firing the coaxial gun.
		Fire.Coaxial:
			MMBT # 2 Light ("CoaxialFiringLight") //Firing state.
			{
				Actor Proj = A_SpawnProjectile ("MVP_RifleBullet",20,-10,flags:CMF_AIMDIRECTION,Pitch);
				AddProjectileSpread (Proj,(0.4,-0.4),(0.55,-0.55));
				A_StartSound ("Vehicle/Tank/CoaxialFire",CHAN_WEAPON,CHANF_OVERLAP,1.0,0.4);
				Frame = UpdateTankElevation (16,7,10,13); //Q, H, K, N
			}
			MMBT ### 1 //Refiring state
			{
				//Quick retarget attempt.
				If (!Target || IsDead (Target))
				{
					A_ClearTarget();
					LookForPlayers (True); //Look for a new target.
				}
				//console.printf ("coaxial obligations %d",coaxialshots);
				//The gun is loaded, and you are no longer forced to fire the coaxial at some weakling.
				If (!ReloadTime && CoaxialShots <= 0)
				{
					Return ResolveState ("ExitCoaxial");
				}
				
				//Recycled logic from the APCs' small autocannon MG, since the coaxial gun is the same thing, but part of the tank turret itself.
				If (Random2[pr_monsterrefire]() < 128 &&
				((Target && IsOverPitchLimits (Target,8,Target.Height/2) != ELEVATION_INBOUNDS) ||
				!KAI_TurretCheckLOF (Target,150,0,(0,-8,8))))
				{
					A_ClearTarget();
					Return ResolveState ("ExitCoaxial");
				}
				
				HandleChaseTimer();
				
				KAI_TurretRefire (128,"ExitCoaxial",True,4,fov:120);
				If (CoaxialShots > 0)
				{
					//Finish firing the coaxial if forced to fast when the current target is dangerous.
					If (AssessThreatLevel (Target) < THREAT_DANGEROUS)
						CoaxialShots--;
					Else
						CoaxialShots -= 3;
				}
				
				Frame = UpdateTankElevation (15,6,9,12); //P, G, J, M
				Return State (Null);
			}
			Loop;
		ExitCoaxial:
			TNT1 A 0 {CoaxialShots = 0;}
			Goto See;
	}
}

Class MVP_MBTRWS : MVP_BaseTurret
{
	Default
	{
		Health 200;
		Radius 16;
		Height 16;
		DeathHeight 16;
		XScale 0.5; //The remote weapon stations are rendered at double the resolution of the rest of the tank hull and turret, for extra detail.
		YScale 0.416666;
		Mass 50;
		FriendlySeeBlocks 64;
		MaxTargetRange 8192;
		KAI_BaseTurret.MaximumPitch -35;
		KAI_BaseTurret.MinimumPitch 15;
		KAI_BaseTurret.TurnSoundRadius 1.5;
		KAI_BaseTurret.AttackSpeed 230;
		KAI_BaseTurret.FastAttackSpeed 250;
		KAI_BaseTurret.CombatAngleTurnRate 50;
		KAI_BaseTurret.CombatPitchTurnRate 37;
		KAI_Actor.ThreatLevel THREAT_ABOVENORMAL;
		AttackSound "Vehicle/APC/MGFire";
		Tag "M20 Remote Weapon Station";
		Obituary "%o was gunned down by a tanks' remote weapon station";
		DamageFactor "Autocannon", 0.95;
		DamageFactor "Melee", 0.4;
		DamageFactor "Electric", 0.4;
		DamageFactor "ExplosiveImpact", 0.825;
		DamageFactor "Explosion", 0.825;
		DamageFactor "HitScan", 0.9;
		+MissileMore;
		+MissileEvenMore;
	}
	
	Int UpdateRWSElevation (Int FaceDown, Int FaceStraight, Int FaceUp, Int FaceUp2)
	{console.printf ("pitch is %d",pitch);
		If (Pitch >= 8 && Pitch >= 0)
			Return FaceDown;
		Else If (Pitch < 8 && Pitch >= -17.5)
			Return FaceStraight;
		Else If (Pitch < -17.5 && Pitch >= -25)
			{a_log ("facing up");Return FaceUp;}
		Else If (Pitch <= -25)
		{a_log ("facing very up");
			Return FaceUp2;}
		
		Return FaceStraight;
	}
	
	Bool FocusFire; //Makes the MG not actively avoid sharing the same target as the turret, even if the shared target isn't a powerful enemy.
	//ULTRA HIGH DEFINITION QUALITY DOLBY ATMOS RIPS.
	Const RWSAttackHeight = 12;
	Array <Actor> HitActors;
	
	Override Bool ShouldAttack (Bool NoStateJump)
	{
		If (!KAI_BaseTurret.ShouldAttack()) Return False;
		If (Target && !CheckFOV (Target,90/2)) Return False; //KLUDGE: We need to do the null check here, because as of GZDoom 4.10, it's not done internally. Crashing the game.
		If (IsOverPitchLimits (Target,RWSAttackHeight,Target.Height/2) != ELEVATION_INBOUNDS) Return False;
		
		If (Target != Self && KAI_CheckMissileRange(Target) && !IsDead (Target) && IsActorHostile (Target) && KAI_TurretCheckLOF (Target,0,0,(0,-8,12),0,"MVP_50CalBullet"))
		{
			If (!NoStateJump) SetStateLabel ("Fire");
			Return True;
		}
		
		Return False;
	}
	
	MVP_APCMachineGunLOFCheck MarineWarner; //A permanent pointer to a MG LOF check tracer. So that it can be fired when the turret is firing to warn marines.
	Override Void Tick()
	{
		Super.Tick();
		
		If (IsFrozen()) Return;
		//When shooting, fire a ray that alerts any marines that would be caught in the line of fire.
		If (IsInAttackState())
		{
			Vector3 Direction = (AngleToVector(Angle, Cos(Pitch)), -Sin(Pitch));
			
			Double Distance = Target ? Distance3D (Target)+32 : MaxTargetRange;
			MarineWarner.Shooter = Self;
			MarineWarner.Other = Target;
			MarineWarner.OnlyFindActors = True;
			MarineWarner.Trace ((Pos.X,Pos.Y,Pos.Z+RWSAttackHeight),CurSector,Direction,Distance,0);
			HitActors.Move(MarineWarner.Mobjs);
			//Check all the actors the trace hit.
			Name TheMarine = "SmartMarine";
			ForEach (Mobj : HitActors)
				If (Mobj && !IsDead (Mobj) && Mobj Is TheMarine && IsHostile(Mobj))
					WarnSpecificMarine(Mobj); //Then warn them.
			HitActors.Clear();
		}
	}
	
	Override Void Die (Actor Source, Actor Inflictor, Int DmgFlags, Name MeansOfDeath)
	{
		Super.Die (Source, Inflictor, DmgFlags, MeansOfDeath);
		If (MarineWarner) MarineWarner.Destroy();
		If (Master) Master.SetTag (Master.Default.GetTag());
	}
	
	Override Void OnDestroy()
	{
		If (Master) Master.SetTag (Master.Default.GetTag());
		If (MarineWarner) MarineWarner.Destroy();
		Super.OnDestroy();
	}
	//====================================================
	
	Override Void PostBeginPlay ()
	{
		Super.PostBeginPlay();
		
		MissileState = FindState ("Fire");
		AttackStates.Push (FindState("Fire",True));
		MarineWarner = New ("MVP_APCMachineGunLOFCheck"); //Create the warning trace for marines.
	}
	
	States
	{
		Spawn:
			MMBT S 0;
			MMBT # 1
			{
				RotateToVehicle();
				KAI_Look (maxseedist:MaxTargetRange,DEFAULT_HEARDISTANCE,extraflags:KAIL_CHASETARGET);
				Frame = UpdateRWSElevation (24,18,20,22); //Y, S, U, W
			}
			Wait;
		See:
			MMBT # 1;
			MMBT # 1
			{
				DoCombatTraverse();
				RotateToVehicle();
				MoveToParams Params;
				Params.RunRad = 256;
				Params.DetourFactor = 1.0;
				Params.Attempts = 32;
				Params.StepThreshold = 32;
				KAI_LandVehicleChase (chaseflags:CHF_DONTIDLE|CHF_DONTMOVE,moveparams:params);
				UpdateTurretSnapTimer();
				Frame = UpdateRWSElevation (24,18,20,22); //Y, S, U, W
			}
			Loop;
		Fire:
			MMBT ## 1 {Frame = UpdateRWSElevation (24,18,20,22); /*Y, S, U, W*/}
			MMBT # 3 Light ("50CalFiringLight") Bright
			{
				A_StartSound (AttackSound,CHAN_WEAPON,CHANF_OVERLAP,1.0,0.3);
				Actor Proj = A_SpawnProjectile ("MVP_50CalBullet",12,-8,flags:CMF_AIMDIRECTION,Pitch); //pew pew
				AddProjectileSpread (Proj,(0.8,-0.8),(1.0,-1.0));
				A_SpawnItemEx ("MVP_BulletCasing",-32,32,8,FRandom(2,-2),FRandom(8,14),FRandom(6,12));
				Frame = UpdateRWSElevation (25,19,21,23); //Z, T, V, X
			}
			MMBT # 1
			{
				//If you have no target, or it's dead.
				If (!Target || IsDead (Target))
				{
					A_ClearTarget();
					LookForPlayers (True); //Look for a new target.
				}
				
				//If you share a target with the turret, then try finding a different one.
				//Unless the shared target is stronger than the turret, in which case don't force yourself to attack a different target.
				If (!FocusFire && Target && Master && Target == Master.Target && AssessThreatLevel (Master.Target, False) <= KAI_Actor(Master).ThreatLevel)
				{
					Actor NewTarget = PickDifferentTarget (Master.Target,Master.Target,2048,512);
					If (NewTarget)
						Target = NewTarget;
				}
				
				If (Random2[pr_monsterrefire]() < 48 &&
				//If the target is too high or low to shoot.
				((Target && IsOverPitchLimits (Target,12,Target.Height/2) != ELEVATION_INBOUNDS) ||
				!KAI_TurretCheckLOF (Target,0,0,(0,-8,12),0,"MVP_50CalBullet")))
				{
					A_ClearTarget();
					Return ResolveState ("See");
				}
				
				HandleChaseTimer();
				
				Frame = UpdateRWSElevation (24,18,20,22); //Y, S, U, W
				Return State (Null);
			}
			MMBT # 0 KAI_TurretRefire (48,"See",True,fov:90/2);
			Goto Fire+2;
		Death:
			MBTD Q 1
			{
				If (Master)
				{
					Angle = Master.Angle;
					TurretRotationOffset = 0;
				}
				RotateToVehicle (RTVF_NOTARGETCHECK);
				Actor Boom = Spawn ("MVP_Explosion",Pos);
				Boom.Scale *= 0.6;
				Boom.SetDamage (32);
				Boom.MaxTargetRange = 96;
				Boom.MeleeRange = 12;
				Boom.bNoGravity = True;
			}
			MBTD Q 1 RotateToVehicle (RTVF_NOTARGETCHECK);
			Wait;
		XDeath:
			TNT1 A 0
			{
				Actor Boom = Spawn ("MVP_Explosion",Pos);
				Boom.Scale *= 0.9;
				Boom.SetDamage (56);
				Boom.MaxTargetRange = 128;
				Boom.MeleeRange = 48;
				Boom.bNoGravity = True;
				
				SmokeCounter = 48;
				Bool b; Actor Debris;
				For (Int I; I <= SmokeCounter; I++)
				{
					[B, Debris] = A_SpawnItemEx ("MVP_DiCokkaDebris",FRandom (Radius,-Radius),FRandom(Radius,-Radius),FRandom (0,Height),FRandom (-12,12),FRandom (-12,12),FRandom (6,16));
					If (Debris)
					{
						Debris.Scale *= FRandom (0.1,0.3);
						Debris.bXFlip = Random (False,True);
					}
				}
			}
			Stop;
		GenericFreezeDeath:
			MMBT # 0 {Frame = UpdateRWSElevation (24,18,20,22); /*Y, S, U, W*/}
			Goto Super::GenericFreezeDeath;
	}
}

Class MVP_MBTRWSMinigun : MVP_MBTRWS
{
	Default
	{
		FriendlySeeBlocks 48;
		MaxTargetRange 6144;
		KAI_BaseTurret.AttackSpeed 200;
		KAI_BaseTurret.FastAttackSpeed 220;
		AttackSound "Vehicle/Tank/CoaxialFire";
		Obituary "%o drowned in lead";
		Tag "M20 Minigun Remote Weapon Station";
	}
	
	Mixin MVP_AutocannonWarningZoneHandling; //Listen, the minigun works basically the same way as this. It just fires normal non-ripping bullet projectiles.
	
	Int ShotsFired;
	
	Override Bool ShouldAttack (Bool NoStateJump)
	{
		If (!KAI_BaseTurret.ShouldAttack()) Return False;
		If (Target && !CheckFOV (Target,90/2)) Return False;
		If (IsOverPitchLimits (Target,8,Target.Height/2) != ELEVATION_INBOUNDS) Return False;
		
		If (Target != Self && KAI_CheckMissileRange(Target) && !IsDead (Target) && IsActorHostile (Target) && KAI_TurretCheckLOF (Target,150,0,(0,0,8)))
		{
			If (!NoStateJump)
			{
				SetStateLabel ("Fire");
				WarningZone = WarnMarines (0,48); //Create a warning zone to warn marines of wherever the machine gun is aiming.
				If (WarningZone) WarningZone.SetOrigin (GetAttackLocation(),True);
			}
			Return True;
		}
		
		Return False;
	}
	
	States
	{
		Spawn:
			AMBT G 0;
			AMBT # 1
			{
				RotateToVehicle();
				KAI_Look (maxseedist:MaxTargetRange,DEFAULT_HEARDISTANCE,extraflags:KAIL_CHASETARGET);
				Frame = UpdateRWSElevation (12,6,8,10); //M, G, I, K
			}
			Loop;
		See:
			AMBT # 1
			{
				If (ShotsFired > 0) ShotsFired--;
				If (ShotsFired > 40) ThreatLevel = THREAT_DANGEROUS;
				Else ThreatLevel = Default.ThreatLevel;
				If (WarningZone) WarningZone.Destroy();
				DoCombatTraverse();
				RotateToVehicle();
				KAI_LandVehicleChase (chaseflags:CHF_DONTIDLE|CHF_DONTMOVE);
				UpdateTurretSnapTimer();
				Frame = UpdateRWSElevation (12,6,8,10); //M, G, I, K
			}
			Loop;
		Fire:
			AMBT ######## 1 {Frame = UpdateRWSElevation (12,6,8,10); /*M, G, I, K*/}
			AMBT # 4 Light ("RifleFiringLight") Bright
			{
				//The minigun also becomes more dangerous when it reaches max fire rate.
				If (ShotsFired > 200)
				{
					ThreatLevel = THREAT_DANGEROUS;
					A_SetTics (1);
				}
				Else If (ShotsFired > 40) A_SetTics (2);
				Else If (ShotsFired > 10) A_SetTics (3);
				If (ShotsFired <= 40) ThreatLevel = Default.ThreatLevel;
				//console.printf ("tics are %d",tics);
				Actor Proj = A_SpawnProjectile ("MVP_RifleBullet",8,flags:CMF_AIMDIRECTION,Pitch);
				AddProjectileSpread (Proj,(0.8,-0.8),(1.0,-1.0));
				A_StartSound (AttackSound,CHAN_WEAPON,CHANF_OVERLAP,1.0,0.4);
				Actor Casing; Bool B;
				[B, Casing] = A_SpawnItemEx ("MVP_BulletCasing",-16,-3,8,FRandom(1,-1),FRandom(-6,-10),FRandom(6,10));
				Casing.Scale.X = 0.125; Casing.Scale.Y = 0.104166;
				Frame = UpdateRWSElevation (13,7,9,11); //N, H, J, L
				ShotsFired++;
			}
			AMBT # 1
			{
				//If you have no target, or it's dead.
				If (!Target || IsDead (Target))
				{
					Actor Prev = Target;
					A_ClearTarget();
					LookForPlayers (True); //Look for a new target.
					If (!Target) //If the sight check didn't return something like it tends to do sometimes, try finding a target right around the old one.
						Target = PickDifferentTarget (Prev,Prev,512);
				}
				
				//If you share a target with the autocannon, then try finding a different one.
				//Unless the shared target is stronger than the turret you are on, in which case don't force yourself to attack a different target.
				If (!FocusFire && Target && Master && Target == Master.Target && AssessThreatLevel (Master.Target, False) <= KAI_Actor(Master).ThreatLevel)
				{
					Actor NewTarget = PickDifferentTarget (Master.Target,Master.Target,2048,512);
					If (NewTarget)
						Target = NewTarget;
				}
				
				If (Random2[pr_monsterrefire]() < 128 &&
				((Target && IsOverPitchLimits (Target,12,Target.Height/2) != ELEVATION_INBOUNDS) || Target && Distance3DSquared (Target) > MaxTargetRange*MaxTargetRange||
				!KAI_TurretCheckLOF (Target,150,0,(0,0,8))))
				{
					Actor Prev = Target;
					A_ClearTarget();
					LookForPlayers (True); //Look for a new target.
					If (!Target || IsOverPitchLimits (Prev,12,Prev.Height/2))
						Target = PickDifferentTarget (Prev,Prev,512);
					Return ResolveState ("See");
				}
				
				HandleChaseTimer();
				
				Frame = UpdateRWSElevation (12,6,8,10); //M, G, I, K
				Return State (Null);
			}
			AMBT # 0
			{
				Int Chance;
				If (ShotsFired > 200) Chance = 1;
				Else If (ShotsFired > 40) Chance = 12;
				Else If (ShotsFired > 10) Chance = 24;
				KAI_TurretRefire (Chance,"See",True,fov:90/2);
			}
			Goto Fire+8;
		Death:
			MBTD R 1
			{
				If (Master)
				{
					Angle = Master.Angle;
					TurretRotationOffset = 0;
				}
				RotateToVehicle (RTVF_NOTARGETCHECK);
				Actor Boom = Spawn ("MVP_Explosion",Pos);
				Boom.Scale *= 0.6;
				Boom.SetDamage (32);
				Boom.MaxTargetRange = 96;
				Boom.MeleeRange = 12;
				Boom.bNoGravity = True;
			}
			MBTD R 1 RotateToVehicle (RTVF_NOTARGETCHECK);
			Wait;
		XDeath:
			TNT1 A 0
			{
				Actor Boom = Spawn ("MVP_Explosion",Pos);
				Boom.Scale *= 0.9;
				Boom.SetDamage (56);
				Boom.MaxTargetRange = 128;
				Boom.MeleeRange = 48;
				Boom.bNoGravity = True;
			}
			Stop;
		GenericFreezeDeath:
			MMBT # 0 {Frame = UpdateRWSElevation (12,6,8,10); /*M, G, I, K*/}
			Goto Super::GenericFreezeDeath;
	}
}
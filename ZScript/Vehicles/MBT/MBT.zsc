//VARIANT IDEAS:
//General
//The SPAAG and artillery tanks should not try to intentionally run over enemies as an attack, and back off like normal vehicles instead.
//Normal turret
	//Make an alternate 3-barrel chaingun RWS for the tank. That fires MVP_RifleBullet instead of MVP_50CalBullet. Twice as fast, for painlocking enemies.
//A BMPT Terminator.
	//It'll overall be weaker than the MBT, maybe having like 2000 health.
	//Two autocannons, or maybe machine guns instead (Probably that), and armed with ATGMs with a reload time of maybe like, 10 seconds or so.
	//It'll be limited to like -10 to 15/20 degrees of elevation.
	/*Maybe give it the ability to kinda use its' missiles sparingly. e.g if it's firing its' guns at an enemy, but a strong enemy is nearby, like in 1024 MU,
	then the turret will target the powerful enemy, and fire a missile at it, once the next missile is ready.*/
	/*Make it so if it's near an MBT, it will begin following it. And for as long as they are in sight of each other. The BMPT will only focus on attacking
	weak enemies with its' machine guns, unless a missile is ready. While the MBT turret will only focus on powerful enemies if there are any around.
	Basically, give the BMPT it's real world role as tank support, instead of just having it be shittier MBT.*/
//A SPAAG variant, like the Gepard and Type 87. With airburst shells like the APC.
	//It'll overall be weaker than the MBT, maybe having like 2000 health.
	//It has an extreme elevation range of -10 to 90 degrees.
	//It can see 360 degrees.
	//Maybe add an animation of the destructible back radar rising and lowering when the tank sees an enemy. It won't lower the rader if its' destroyed.
	//It has a dual autocannon, like the APC's autocannon, but fires a little faster, and has a far faster traverse speed.
	//The sheels are a bit smaller than the APCs, and weaker, but can airburst, and produce hitscan shrapnel with a longer range than the airbburst explosion.
	//Maybe remove the airburst from the APC's autocannon, to justify using the SPAAG instead.
	//Add a radar in front of the turret, that elevates with the cannons. And a smaller radar on top, that is a separate actor instead of part of the sprite.
	//The top radar should not be cosmetic, and when destroyed halve the accuracy and sight range of the SPAAG, and limit its' FOV.
	//It will only target flying enemies, unless there's literally none of them in sight, in which case it'll start sounding at ground enemies too.

Class MVP_MBT : MVP_BaseVehicle
{
	Default
	{
		//$Title Main Battle Tank
		//$Category Vehicles/Tanks
		Health 6000;
		WoundHealth 1500;
		Speed 10;
		XScale 1;
		YScale 0.833333; //1 / 1.2
		Radius 96;
		Height 88; //For now, this is the combined height of the hull and main turret.
		MeleeRange 88;
		MaxSlopeSteepness 0.65;
		//TODO: Give the turrets roughly this range as well, except maybe the BMPT. The TOS-1 should have like double the range.
		FriendlySeeBlocks 128;
		MaxTargetRange 16384;
		KAI_Actor.ThreatLevel THREAT_VERYDANGEROUS;
		KAI_Actor.ThreatLevelThreshold THREAT_DANGEROUS;
		//KAI_BaseVehicle.VehicleTurret "MVP_MBTTurret"; //Normal tank turret.
		KAI_BaseVehicle.MaxPushMass 25000;
		KAI_BaseVehicle.MaxPushRadius 128;
		KAI_BaseVehicle.MaxPushHeight 128;
		KAI_BaseVehicle.CrushDamage 12;
		KAI_BaseVehicle.MaxCrushRadius 64;
		KAI_BaseVehicle.MaxCrushHeight /*64*/ 192; //The height is kinda fucky, but it's for the tank to be able to drive over street lights in gz_bigcity.
		KAI_BaseVehicle.MaxCorpseRadius 88;
		KAI_BaseVehicle.MaxCorpseHeight 64;
		Tag "M6V3-EX Main Battle Tank";
		ActiveSound "Vehicle/Tank/Move";
		//TODO: Add tank specific flags like no morphing.
		+LookAllAround;
	}
	
	Override Void PostBeginPlay ()
	{
		Super.PostBeginPlay();
		//Decide movement sound for this tank instance.
		If (Random (False,True) == True) ActiveSound = "Vehicle/Tank/AltMove";
		If (Random(0,255) < 8) ActiveSound = "Vehicle/Tank/MoveOriginal";
		WarningZone = WarnMarines (MWRN_WARP|MWRN_ALLIESTOO,128,Self,(96,0,Height/2));
		console.printf ("active sound is %s",activesound);
	}
	
	Override Void Tick ()
	{
		Super.Tick();
		If (IsFrozen() || !WarningZone) Return;
		//Disable the warning zone if crushing is disabled or the tank isn't moving in the first place.
		WarningZone.bDormant = (bNoCrushing || IsInState (Self,"Spawn"));
	}
	
	Override Void UserVariableDefaults ()
	{
		If (User_RetreatDistance == 0) User_RetreatDistance = 768;
		Super.UserVariableDefaults();
		
		//If (TankCrushRange > 0) User_RetreatDistance = -1; //If you are going to crush your enemies, don't run away from them.
		If (User_CrushMode == CRUSH_NONE) bNoCrushing = True;
	}
	
	Override Bool CanAttack()
	{
		Return True; //The tank always has a turret on it to attack with. Plus it might also be able to crush enemies on its; own.
	}
	
	//Don't use the threat assessment of MVP vehicles, which considers players and marines on turrets as huge deal. Since they do little against the tank.
	Override Int AssessThreatLevel (Actor Other, Bool CheckPlayers)
	{
		//TODO: Make the player not be considered that much of a threat if they only have God or Buddha 1, and the hull has the standard turret.
		Return KAI_BaseVehicle.AssessThreatLevel(Other, CheckPlayers);
	}
	
	Override Bool SpawnDamageSmoke()
	{
		If (!Super.SpawnDamageSmoke()) Return False;
		Vector3 SpawnPos = Vec3Angle (96,GetNearestCardinalAngle(True));
		SpawnPos = Level.Vec3Offset (SpawnPos,(FRandom(-16,16),FRandom(-16,16),48));
		SpawnPos.XY = KAI_Math.RotateAround (Pos.XY,SpawnPos.XY,SpriteRotation);
		Let FX = (WoundHealth/2 >= Health) ? "MVP_BrightFireParticle" : "MVP_DamageSmoke";
		For (Int I; I < 2; I++)
		{
			Actor Smoke = Spawn (FX,SpawnPos);
			Smoke.Roll = FRandom(-180,180);
			Smoke.A_SetScale (FRandom(0.7,1.2));
			Smoke.Vel.Z = FRandom (1,4);
		}
		Return True;
	}
	
	Override Void SpawnHeadlights ()
	{
		Headlights.Push (SpawnVehicleHeadlight (Self,(64,48,32),VHSF_SPRITEROT|VHSF_CARDINALS|VHSF_16ANGLES,lightcolor:(255,195,165),512,spotlightangles:(25,50)));
		Headlights.Push (SpawnVehicleHeadlight (Self,(64,-48,32),VHSF_SPRITEROT|VHSF_CARDINALS|VHSF_16ANGLES,lightcolor:(255,195,165),512,spotlightangles:(25,50)));
		Headlights.Push (SpawnVehicleHeadlight (Self,(128,56,32),VHSF_SPRITEROT|VHSF_BACKLIGHT|VHSF_CARDINALS|VHSF_16ANGLES,lightcolor:(255,150,0),64,spotlightangles:(45,90)));
		Headlights.Push (SpawnVehicleHeadlight (Self,(128,-56,32),VHSF_SPRITEROT|VHSF_BACKLIGHT|VHSF_CARDINALS|VHSF_16ANGLES,lightcolor:(255,150,0),64,spotlightangles:(45,90)));
	}
	
	Override Void Die (Actor Source, Actor Inflictor, Int DmgFlags, Name MeansOfDeath)
	{
		If (WarningZone) WarningZone.Destroy();
		If (Retreating)
		{
			A_SetSpriteRotation (0);
			A_SetAngle (Angle+180);
			Retreating = False;
			RetreatLoops = 0;
		}
		Super.Die (Source, Inflictor, DmgFlags, MeansOfDeath);
	}
	
	Override Void OnDestroy()
	{
		Super.OnDestroy();
		If (WarningZone) WarningZone.Destroy();
	}
	
	//Produce crushing related obituaries for players.
	Override String GetObituary (Actor Victim, Actor Inflictor, Name MOD, Bool PlayerAttack)
	{
		String MeleeObituaries[] = {
		"%o was ran over by a tank",
		"%o didn't check both ways when crossing the street",
		"%o became roadkill",
		"%o is practicing their skidmark impression"
		};
		If (Inflictor == Self && (MOD == 'Crush' || MOD == 'TankCrush'))
		{
			Bool Placeholder = True;
			//Print a "special" obituary if the player was intentionally crushed by the tank.
			If (Target == Victim && User_CrushMode == CRUSH_ACTIVE && Random (0,255) < 255/4) //4/6/1989
			{
				Let Checker = SM_MarineChecker(EventHandler.Find ("SM_MarineChecker"));
				String PlayerName;
				If (Victim && Victim.Player)
					PlayerName = Victim.Player.GetUsername();
				Else If (Victim)
					PlayerName = Victim.GetTag();
				Return String.Format ("%s 没有被压碎 %s",PlayerName,Checker.ScopeHack.Date);
			}
			Else
				Return MeleeObituaries[Random(0,MeleeObituaries.Size()-1)];
		}
		
		Return Super.GetObituary (Victim, Inflictor, MOD, PlayerAttack);
	}
	
	Bool IsMeleeOnlyEnemy (Actor Other)
	{
		Return (Other && Other.MeleeState && !Other.MissileState);
	}
	
	//Bool IsRangedEnemy (Actor Other)
	
	//Finds a living enemy to crush within Range, and sets it as the tanks' target.
	//FOV: The FOV to use for the sight check.
	//Range: The range to find a victim to run over in.
	//MaxTurretRange: If the turrets' target is outside of this range from it, begin chasing that target instead.
	Void MBT_RunShitOver (Double FOV = 45, Double Range = 512, Double MaxTurretRange = 2048)
	{
		If (Range <= 0 || bNoCrushing) Return;
		//The turrets' target is too far from it or out of sight. So start chasing that instead.
		If (Turret && Turret.Target && (Turret.Distance3DSquared (Turret.Target) > MaxTurretRange || !Turret.CheckSight(Turret.Target)))
		{
			Target = Turret.Target;
			Return;
		}
		If (Health < 1000) Return;
		Actor Mobj;
		Array <Actor> Candidates;
		Let Roadkills = BlockThingsIterator.Create (Self,Range);
		While (Roadkills.Next())
		{
			Mobj = RoadKills.Thing;
			
			If (!Mobj || Mobj == Self) Continue;
			If (IsDead (Mobj) || IsInanimateObject (Mobj) || IsFlying (Mobj) || !IsCollidable (Mobj,Self) || !CanBeTargeted(Self,Mobj) || !IsActorHostile (Mobj)) Continue;
			
			Int Level = AssessThreatLevel (Mobj,True);
			
			//Don't fuck with super dangerous enemies.
			Switch (Level)
			{
				Case THREAT_DANGEROUS:
				Case THREAT_VERYDANGEROUS:
				Case THREAT_SUPERDANGER:
				Case THREAT_UNSTOPPABLE:
					a_log ("too dangerous");
					Continue;
				Default:
					Break;
			}
			
			//If it's not a really weak enemy and they have some kind of range attack, avoid them. If they are weak, ignore that they have a range attack.
			If (Level >= THREAT_NORMAL && Mobj.MissileState) {a_log ("ranged");Continue;}
			
			//And at last, the distance and sight checks.
			If (Distance3DSquared (Mobj) > Range*Range || !CheckSight (Mobj)) {a_log ("distance and sight");Continue;}
			
			Candidates.Push(Mobj);
		}
		
		If (!Candidates.Size())
		{a_log ("no crushees"); Return;}
		
		//LastEnemy = Target;
		Target = GetClosestActor (Candidates,Self.Pos,Range);
	}
	
	Void A_MBTLook ()
	{
		If (User_CrushMode != CRUSH_PASSIVE)
			MBT_RunShitOver (360,TankCrushRange); //Find something to run over.
		If (!Target) //Nothing found, just look for actors normally.
			KAI_Look (User_Stationary ? LOF_NOJUMP : 0,maxseedist:MaxTargetRange,8192,360);
		If (Turret && Turret.Target) //Still no target, so get your turrets' target instead.
		{
			Target = Turret.Target;
			If (!User_Stationary) SetStateLabel ("See");
		}
	}
	
	//TODO: Make a generic A_TankFire() function that has 3 different firing types maybe ?
	/*
	Enum AmmoTypes
	{
		TYPE_HEAT 	= 0, //Standard ammo type, used for weak (Relatively) enemies, groups, etc.
		TYPE_APFSDS	= 1, //Ripper that does a shitton of damage. Used for powerful enemies, like Cyberdemons and players with god/buddha mode 1.
		TYPE_ATGM	= 2, //Homing missiles, have a chance to be fired at powerful enemies, and distant and/or fast enemies.
	}
	Void A_TankFire (Vector3 Offset, Int Type = TYPE_HEAT){}
	*/
	// Use +YFLIP for the aiming down elevations of the ATGM (And maybe rocket too), to save on frames and file size.
	// For the SPAAG, make it do more damage to flying actors using DoSpecialDamage on both the projectile and hitscan shrapnel puffs.
	// Design wise, the back radar of the SPAAG should have a separate REAL hitbox that receives damage. Whose relative position snaps based on the turret angle.
	Enum TurretTypes
	{
		TURRET_NORMAL	= 0, //The normal MBT variant.
		TURRET_TOS1		= 1, //Thermobaric rocket artillery variant, no gravity affected rockets because I'm not THAT nuts (Actually good at programming).
		TURRET_BMPT		= 3, //Light tank-ish variant of the tank. With only machine guns and rockets, and less health.
		TURRET_SPAAG	= 4, //AA variant of the tank, with a functional top radar.
	}
	
	Const TankAngleLimit = 3; //How much the tank can turn per step.
	Const TankCrushRange = 640;
	Bool Retreating;
	Int RetreatLoops;
	Actor WarningZone;
	
	Bool User_Stationary; //The tank always stays in place, similar to the HECU M1 Abrams tanks from Half-Life 1.
	
	//Original code donut stael.
	//Main difference is that this control both corpse AND live enemy crushing.
	Int User_CrushMode;
	Enum CorpseCrushModes
	{
		CRUSH_NONE = -1, //No crushing at all, only pushing.
		CRUSH_ACTIVE = 0, //Actively seek corpses and enemies.
		CRUSH_PASSIVE = 1 //Crush enemies and corpses, but only by happenstance.
	};
	States
	{
		Spawn:
			MMBT A 1
			{
				A_StopSound (CHAN_MOVING);
				A_StartSound("Vehicle/Tank/Idle",CHAN_IDLING,CHANF_LOOPING,attenuation:0.5);
				A_MBTLook();
			}
			Loop;
		//High quality code rips.
		Idle:
			MMBT ABCDEF 2
			{
				A_QuakeEx (1,1,1,2,0,384,flags:QF_GROUNDONLY);
				A_StopSound (CHAN_IDLING);
				A_StartSound (ActiveSound,CHAN_MOVING,CHANF_LOOPING,attenuation:0.6);
				
				A_MBTLook();
				
				//Archvile trolling move activated.
				If (User_CrushMode == CRUSH_ACTIVE)
				{
					If (CorpseTarget && CorpseTarget.bDontGib) CorpseTarget = Null; //Disgard crushed corpses.
					//Don't have a corpse to crush already.
					If (!CorpseTarget)
					{
						CorpseTarget = FindNearestCorpse(); //Nearby corpse found, go and crush it.
						If (CorpseTarget) 
							KAI_MoveTowards (CorpseTarget.Pos,0.8,8);
						Else //Still no corpse found, so just begin wandering around.
							KAI_Wander(48,1024,128,0.5,TankAngleLimit);
					}
					
					//There is an available corpse to head to and crush.
					If (CorpseTarget)
						KAI_MoveTowards (CorpseTarget.Pos,0.8,8);
				}
				Else
					KAI_Wander(48,1024,128,0.5,TankAngleLimit);
				
				If (User_CrushMode != CRUSH_NONE) KAI_CrushCorpses();
			}
			Loop;
		See:
			MMBT ABCDEF 2
			{
				A_QuakeEx (1,1,1,2,0,384,flags:QF_GROUNDONLY);
				If (User_Stationary) //Shouldn't be here.
					Return State (SpawnState);
				//Console.Printf ("Sprite angle offset %d",SpriteRotation);
				A_StopSound (CHAN_IDLING);
				A_StartSound (ActiveSound,CHAN_MOVING,CHANF_LOOPING,attenuation:0.5);
				//Try to find someone else to run over before the stock retargeting code runs.
				If (User_CrushMode == CRUSH_ACTIVE)
					If (!Target || Target && Distance3DSquared (Target) > TankCrushRange*TankCrushRange)
						MBT_RunShitOver (360,TankCrushRange);
				MoveToParams Params;console.printf ("retreat dist %d",retreatrange);
				Params.DetourFactor = 0.25;
				Params.Attempts = 32;
				Params.StepThreshold = 32;
				Params.RunRad = 384;
				Int RealRange = RetreatRange;
				//If moving to a target that is below the threat threshold, never retreat. In other words, don't retreat when trying to run over someone.
				If (AssessThreatLevel (Target) < ThreatLevelThreshold && User_CrushMode == CRUSH_ACTIVE && Health >= 1000) RetreatRange = 0;
				KAI_LandVehicleChase (flags:LVC_USERETREATSTATE|LVC_PLAYERSASTHREATS|LVC_MAKEFRIENDSIDLE,turnradius:TankAngleLimit,512);
				RetreatRange = RealRange;
				If (User_CrushMode != CRUSH_NONE) KAI_CrushCorpses();
				Return State (Null);
			}
			Loop;
		//Retreat by "reversing", AKA calling KAI_VehicleRetreat, but using SpriteRotation and an inverted move animation to appear as facing the target.
		Retreat:
			TNT1 A 0
			{
				If (User_Stationary) //Shouldn't be here.
					Return State (SpawnState);
				Retreating = True;
				A_SetSpriteRotation (180);
				A_SetAngle (Angle-180);
				Return State (Null);
			}
		Retreat.Move:
			MMBT FEDCBA 2
			{
				A_QuakeEx (1,1,1,2,0,384,flags:QF_GROUNDONLY);
				A_StopSound (CHAN_IDLING);
				A_StartSound (ActiveSound,CHAN_MOVING,CHANF_LOOPING,attenuation:0.5);
				KAI_VehicleRetreat (Target,96,512,32,0.25,TankAngleLimit);
				If (User_CrushMode != CRUSH_NONE) KAI_CrushCorpses();
			}
		Retreat.End:
			TNT1 A 0
			{
				//Target no longer in sight, keep retreating for a bit before moving forward again.
				If (!RetreatLoops && RetreatLoops != -1)
				{
					If (!CheckSight(Target))
						RetreatLoops = Random (12,24);
					If (!RetreatLoops && !FindNearestEnemy (RetreatRange))
						RetreatLoops = Random (4,8);
					If (!RetreatLoops && Turret && Turret.Target && Turret.ElevationState != Turret.ELEVATION_TOOHIGH)
						RetreatLoops = Random (6,12);
					
					RetreatLoops = Random (12,24);
				}
					console.printf ("loops %d",retreatloops);
				If (RetreatLoops > 0 && Target && !IsDead (Target))
				{
					RetreatLoops--;
					If (RetreatLoops == 0)
						RetreatLoops--;
					Return FindState ("Retreat.Move",True);
				}
					
				A_SetSpriteRotation (0);
				A_SetAngle (Angle+180);
				RetreatLoops = 0;
				Retreating = False;
				Return State (Null);
			}
			Goto See;
	}
}

Class MVP_MBTTurret : MVP_BaseTurret
{
	Default
	{
		
	}
}

Class MVP_MBTRWS : MVP_BaseTurret
{
	Default
	{
		
	}
}
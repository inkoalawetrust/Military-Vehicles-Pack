//VARIANT IDEAS:
//Normal turret
	//Make an alternate 3-barrel chaingun RWS for the tank. That fires MVP_RifleBullet instead of MVP_50CalBullet. Twice as fast, for painlocking enemies.
//A BMPT Terminator.
	//It'll overall be weaker than the MBT, maybe having like 2000 health.
	//Two autocannons, or maybe machine guns instead (Probably that), and armed with ATGMs with a reload time of maybe like, 10 seconds or so.
	//It'll be limited to like -10 to 15/20 degrees of elevation.
	/*Maybe give it the ability to kinda use its' missiles sparingly. e.g if it's firing its' guns at an enemy, but a strong enemy is nearby, like in 1024 MU,
	then the turret will target the powerful enemy, and fire a missile at it, once the next missile is ready.*/
	/*Make it so if it's near an MBT, it will begin following it. And for as long as they are in sight of each other. The BMPT will only focus on attacking
	weak enemies with its' machine guns, unless a missile is ready. While the MBT turret will only focus on powerful enemies if there are any around.
	Basically, give the BMPT it's real world role as tank support, instead of just having it be shittier MBT.*/
//A SPAAG variant, like the Gepard and Type 87. With airburst shells like the APC.
	//It'll overall be weaker than the MBT, maybe having like 2000 health.
	//It has an extreme elevation range of -10 to 90 degrees.
	//It can see 360 degrees.
	//Maybe add an animation of the destructible back radar rising and lowering when the tank sees an enemy. It won't lower the rader if its' destroyed.
	//It has a dual autocannon, like the APC's autocannon, but fires a little faster, and has a far faster traverse speed.
	//The sheels are a bit smaller than the APCs, and weaker, but can airburst, and produce hitscan shrapnel with a longer range than the airbburst explosion.
	//Maybe remove the airburst from the APC's autocannon, to justify using the SPAAG instead.
	//Add a radar in front of the turret, that elevates with the cannons. And a smaller radar on top, that is a separate actor instead of part of the sprite.
	//The top radar should not be cosmetic, and when destroyed halve the accuracy and sight range of the SPAAG, and limit its' FOV.
	//It will only target flying enemies, unless there's literally none of them in sight, in which case it'll start sounding at ground enemies too.

//FIXME:
//The tank can't move over the ends of slopes, like crossing the top or bottom of a slope, what the fuck ??????
Class MVP_MBT : MVP_BaseVehicle
{
	Default
	{
		//$Title Main Battle Tank
		//$Category Vehicles/Tanks
		Health 6000;
		Speed 10;
		XScale 0.9;
		YScale 0.75; //0.9 / 1.2
		Radius 96;
		Height 88; //For now, this is the combined height of the hull and main turret.
		MeleeRange 88;
		MaxSlopeSteepness 0.65;
		KAI_BaseVehicle.MaxPushMass 25000;
		KAI_BaseVehicle.MaxPushRadius 128;
		KAI_BaseVehicle.MaxPushHeight 128;
		KAI_BaseVehicle.CrushDamage 6;
		KAI_BaseVehicle.MaxCrushRadius 64;
		KAI_BaseVehicle.MaxCrushHeight /*64*/ 192; //The height is kinda fucky, but it's for the tank to be able to drive over street lights in gz_bigcity.
		Tag "M6V3-EX Main Battle Tank";
		ActiveSound "Vehicle/Tank/Move";
	}
	
	Override Void PostBeginPlay ()
	{
		Super.PostBeginPlay();
		If (Random (False,True) == True) ActiveSound = "Vehicle/Tank/AltMove";
		If (Random(0,255) < 8) ActiveSound = "Vehicle/Tank/MoveOriginal";
		console.printf ("active sound is %s",activesound);
	}
	
	Override Bool CanAttack()
	{
		/*If (Target && target.player && target.player.readyweapon && target.player.readyweapon.getclassname() == "Fist")*/ Return True;
		Return False; //PLACEHOLDER
	}
	
	Override Void Die (Actor Source, Actor Inflictor, Int DmgFlags, Name MeansOfDeath)
	{
		If (Retreating)
		{
			A_SetSpriteRotation (0);
			A_SetAngle (Angle+180);
			Retreating = False;
			RetreatLoops = 0;
		}
		Super.Die (Source, Inflictor, DmgFlags, MeansOfDeath);
	}
	
	//
	Override String GetObituary (Actor Victim, Actor Inflictor, Name MOD, Bool PlayerAttack)
	{
		String MeleeObituaries[] = {
		"%o was ran over by a tank",
		"%o didn't check both ways when crossing the street",
		"%o became roadkill",
		"%o is practicing their skidmark impression"
		};
		If (Inflictor == Self && (MOD == 'Crush' || MOD == 'TankCrush'))
		{
			Bool Placeholder = True;
			//TODO: Add a check for if the tank intentionally ran over the player.
			If (!Placeholder) //4/6/1989
			{
				Let Checker = SM_MarineChecker(EventHandler.Find ("SM_MarineChecker"));
				String PlayerName;
				If (Victim && Victim.Player)
					PlayerName = Victim.Player.GetUsername();
				Return String.Format ("%s 没有被压碎 %s",PlayerName,Checker.ScopeHack.Date);
			}
			Else
				Return MeleeObituaries[Random(0,MeleeObituaries.Size()-1)];
		}
		
		Return Super.GetObituary (Victim, Inflictor, MOD, PlayerAttack);
	}
		
	//TODO: Make a generic A_TankFire() function that has 3 different firing types maybe ?
	/*
	Enum AmmoTypes
	{
		TYPE_HEAT 	= 0, //Standard ammo type, used for weak (Relatively) enemies, groups, etc.
		TYPE_APFSDS	= 1, //Ripper that does a shitton of damage. Used for powerful enemies, like Cyberdemons and players with god/buddha mode 1.
		TYPE_ATGM	= 2, //Homing missiles, have a chance to be fired at powerful enemies, and distant and/or fast enemies.
	}
	Void A_TankFire (Vector3 Offset, Int Type = TYPE_HEAT){}
	*/
	// Use +YFLIP for the aiming down elevations of the ATGM (And maybe rocket too), to save on frames and file size.
	// Make a User_Stationary variable. Especially useful for the SPAAG, and for making the normal tank act more like the HECU Abrams in Half Life 1.
	// For the SPAAG, make it do more damage to flying actors using DoSpecialDamage on both the projectile and hitscan shrapnel puffs.
	// Design wise, the back radar of the SPAAG should have a separate REAL hitbox that receives damage. Whose relative position snaps based on the turret angle.
	// Make the hull actually reverse when driving away. Instead of turning around.
	Enum TurretTypes
	{
		TURRET_NORMAL	= 0, //The normal MBT variant.
		TURRET_TOS1		= 1, //Thermobaric rocket artillery variant, no gravity affected rockets because I'm not THAT nuts (Actually good at programming).
		TURRET_BMPT		= 3, //Light tank-ish variant of the tank. With only machine guns and rockets, and less health.
		TURRET_SPAAG	= 4, //AA variant of the tank, with a functional top radar.
	}
	
	Const TankAngleLimit = 3;
	Bool Retreating;
	Int RetreatLoops;
	
	Bool User_Stationary; //The tank always stays in place, similar to the HECU M1 Abrams tanks from Half-Life 1.
	
	States
	{
		Spawn:
			MMBT A 1
			{
				A_StopSound (CHAN_MOVING);
				A_StartSound("Vehicle/Tank/Idle",CHAN_IDLING,CHANF_LOOPING,attenuation:0.5);
				KAI_Look (User_Stationary ? LOF_NOJUMP : 0,maxseedist:DEFAULT_SEEDISTANCE*2,DEFAULT_HEARDISTANCE*1.5);
			}
			Loop;
		See:
			MMBT ABCDEF 2
			{
				If (User_Stationary) //Shouldn't be here.
					Return State (SpawnState);
				//Console.Printf ("Sprite angle offset %d",SpriteRotation);
				A_StopSound (CHAN_IDLING);
				A_StartSound (ActiveSound,CHAN_MOVING,CHANF_LOOPING,attenuation:0.5);
				MoveToParams Params;
				Params.DetourFactor = 0.25;
				Params.Attempts = 32;
				Params.StepThreshold = 32;
				Params.RunRad = 384;
				KAI_LandVehicleChase (flags:LVC_USERETREATSTATE,turnradius:TankAngleLimit,512);
				Return State (Null);
			}
			Loop;
		//Retreat by "reversing", AKA calling KAI_MoveAway, but using SpriteRotation and an inverted move animation to appear as facing the target.
		//TODO: Add death checks and such, to stop retreating if the actor is dead or something.
		Retreat:
			TNT1 A 0
			{
				If (User_Stationary) //Shouldn't be here.
					Return State (SpawnState);
				Retreating = True;
				A_SetSpriteRotation (180);
				A_SetAngle (Angle-180);
				Return State (Null);
			}
		Retreat.Move:
			MMBT FEDCBA 2
			{
				A_StopSound (CHAN_IDLING);
				A_StartSound (ActiveSound,CHAN_MOVING,CHANF_LOOPING,attenuation:0.5);
				KAI_VehicleRetreat (Target,96,512,32,0.25,TankAngleLimit);
				//KAI_LandVehicleChase (turnradius:2.5,512);
			}
		Retreat.End:
			TNT1 A 0
			{
				//Target no longer in sight, keep retreating for a bit before moving forward again.
				If (!RetreatLoops && RetreatLoops != -1)
				{
					If (!CheckSight(Target))
						RetreatLoops = Random (12,24);
					If (!RetreatLoops && !FindNearestEnemy (RetreatRange))
						RetreatLoops = Random (4,8);
					If (!RetreatLoops && Turret && Turret.Target && Turret.ElevationState != Turret.ELEVATION_TOOHIGH)
						RetreatLoops = Random (6,12);
					
					RetreatLoops = Random (12,24);
				}
					console.printf ("loops %d",retreatloops);
				If (RetreatLoops > 0 && Target && !IsDead (Target))
				{
					RetreatLoops--;
					If (RetreatLoops == 0)
						RetreatLoops--;
					Return FindState ("Retreat.Move",True);
				}
					
				A_SetSpriteRotation (0);
				A_SetAngle (Angle+180);
				RetreatLoops = 0;
				Retreating = False;
				Return State (Null);
			}
			Goto See;
	}
}

Class MVP_MBTTurret : MVP_BaseTurret
{
	Default
	{
		
	}
}

Class MVP_MBTRWS : MVP_BaseTurret
{
	Default
	{
		
	}
}
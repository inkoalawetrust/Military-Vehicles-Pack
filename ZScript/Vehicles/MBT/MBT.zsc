//VARIANT IDEAS:
//General
//A BMPT Terminator.
	//It'll overall be weaker than the MBT, maybe having like 2000 health.
	//Two autocannons, or maybe machine guns instead (Probably that), and armed with ATGMs with a reload time of maybe like, 10 seconds or so.
	//It'll be limited to like -10 to 15/20 degrees of elevation.
	/*Maybe give it the ability to kinda use its' missiles sparingly. e.g if it's firing its' guns at an enemy, but a strong enemy is nearby, like in 1024 MU,
	then the turret will target the powerful enemy, and fire a missile at it, once the next missile is ready.*/
	/*Make it so if it's near an MBT, it will begin following it. And for as long as they are in sight of each other. The BMPT will only focus on attacking
	weak enemies with its' machine guns, unless a missile is ready. While the MBT turret will only focus on powerful enemies if there are any around.
	Basically, give the BMPT it's real world role as tank support, instead of just having it be shittier MBT.*/
//A TOS-1
	//The hull should have similar, if not identical, stats to the SPAAG hull. Health, mass, rip level, etc.

//TODO
//Probably move the APCs' bullets and shells, and the tanks' ATGM, into a generic projectiles file for reused projectile types.
Class MVP_MBT : MVP_BaseVehicle
{
	Default
	{
		//$Title Main Battle Tank
		//$Category Vehicles/Tanks
		//$Sprite MMBT[1
		Health 6000;
		WoundHealth 1500;
		GibHealth 2000;
		Speed 10;
		FastSpeed 16;
		XScale 1;
		YScale 0.833333; //1 / 1.2
		Radius 96;
		Height 61;
		DeathHeight 61;
		MeleeRange 88;
		MaxSlopeSteepness 0.65;
		Mass 30000;
		FriendlySeeBlocks 128;
		MaxTargetRange 16384;
		RipLevelMin 16;
		KAI_Actor.ThreatLevel THREAT_VERYDANGEROUS;
		KAI_Actor.ThreatLevelThreshold THREAT_VERYDANGEROUS;
		KAI_BaseVehicle.VehicleTurret "MVP_MBTTurret"; //Normal tank turret.
		KAI_BaseVehicle.MaxPushMass 25000;
		KAI_BaseVehicle.MaxPushRadius 128;
		KAI_BaseVehicle.MaxPushHeight 128;
		KAI_BaseVehicle.CrushDamage 12;
		KAI_BaseVehicle.MaxCrushRadius 64;
		KAI_BaseVehicle.MaxCrushHeight /*64*/ 192; //The height is kinda fucky, but it's for the tank to be able to drive over street lights in gz_bigcity.
		KAI_BaseVehicle.MaxCorpseRadius 88;
		KAI_BaseVehicle.MaxCorpseHeight 64;
		Tag "M6V3-EX Main Battle Tank";
		ActiveSound "Vehicle/Tank/Move";
		//Armor, yes, good luck, lmao.
		DamageFactor 0.6; //Generic damage factor.
		DamageFactor "ExplosiveImpact", 0.5;
		DamageFactor "Explosion", 0.5;
		DamageFactor "Explosive", 0.5;
		DamageFactor "TankShell", 0.7;
		DamageFactor "Shell", 0.7;
		DamageFactor "APShell", 1.0; //Super susceptible to APFSDS.
		DamageFactor "Grenade", 0.4;
		DamageFactor "HitScan", 0.55; //The generic damage type of hitscan attacks.
		DamageFactor "Shrapnel", 0.2;
		DamageFactor "Fire", 0.3;
		DamageFactor "Plasma", 0.5;
		//Damage factors specific to the Smart Marines.
		DamageFactor "MarineHMG", 0.2;
		DamageFactor "MarineGrenade", 0.5;
		DamageFactor "MarineRifle", 0.55;
		//Vehicle damage factors
		DamageFactor "Autocannon", 0.25;
		DamageFactor "RifleBullet", 0.1;
		DamageFactor "Missile", 0.7;
		DamageFactor "AntiAir", 0.3;
		+DontSquash;
		+DontBlast;
	}
	
	Override Void PostBeginPlay ()
	{
		TurretOffsets = (0.1,0,-0.2);
		Super.PostBeginPlay();
		//StayStillDelay = Random(2,4)*GameTicRate; //Don't immediately drop smoke upon spawning.
		IdleSound = "Vehicle/Tank/Idle";
		//Decide movement sound for this tank instance.
		If (Random (False,True) == True) ActiveSound = "Vehicle/Tank/AltMove";
		
		/*I just overheard a secure access transmission...soldiers have arrived and they're coming to rescue us.
		Of course, I have my doubts that we'll live long enough to greet them.*/
		If (Random(0,255) < (!User_Stationary ? 16 : 48))
		{
			IdleSound = "Vehicle/Tank/IdleOriginal";
			ActiveSound = "Vehicle/Tank/MoveOriginal";
			Turret.TurnSound = "Vehicle/Tank/TurretTurnOriginal";
			Turret.AttackSound = "Vehicle/Tank/CannonFireOriginal";
			Turret.bTurnSoundNoStop = False;
		}
		WarningZone = WarnMarines (MWRN_WARP|MWRN_ALLIESTOO,192,Self,(96,0,Height/2));
	}
	
	Override Void Tick ()
	{
		Super.Tick();
		If (IsFrozen() || !WarningZone) Return;
		//Disable the warning zone if crushing is disabled or the tank isn't moving in the first place.
		WarningZone.bDormant = (bNoCrushing || IsInState (Self,"Spawn"));
	}
	
	Override Void UserVariableDefaults ()
	{
		If (User_RetreatDistance == 0) User_RetreatDistance = 1024;
		Super.UserVariableDefaults();
		
		//If (TankCrushRange > 0) User_RetreatDistance = -1; //If you are going to crush your enemies, don't run away from them.
		If (User_CrushMode == CRUSH_NONE) bNoCrushing = True;
		If (User_APSDelay == 0) User_APSDelay = INT.MAX; //Don't shoot projectiles down practically ever.
		If (User_AltAPSDelay == 0) User_AltAPSDelay = INT.MAX; //Don't dazzle projectiles practically ever.
	}
	
	Override Void SpawnVehicleTurret ()
	{
		If (VehicleTurret)
		{
			SpawnTurret (VehicleTurret);
			If (User_RWS ~== "MG" || User_RWS ~== "MachineGun" || User_RWS ~== "Machine Gun")
				Turret.VehicleTurret = "MVP_MBTRWS";
			Else If (User_RWS ~== "Minigun" || User_RWS ~== "Gatling")
				Turret.VehicleTurret = "MVP_MBTRWSMinigun";
			Else If (User_RWS ~== "Random")
				Turret.VehicleTurret = Random (True,False) ? "MVP_MBTRWS" : "MVP_MBTRWSMinigun";
			If (Turret Is "MVP_MBTTurret")
				MVP_MBTTurret(Turret).MetalCoffin = User_T72Mode;
			
			MVP_MBTTurret(Turret).APSDelay/* = MVP_MBTTurret(Turret).APSCooldown*/ = User_APSDelay;
			MVP_MBTTurret(Turret).AltAPSDelay/* = MVP_MBTTurret(Turret).AltAPSCooldown*/ = User_AltAPSDelay;
		}
	}
	
	Override Bool CanAttack()
	{
		Return True; //The tank always has a turret on it to attack with. Plus it might also be able to crush enemies on its' own.
	}
	
	//Don't use the threat assessment of MVP vehicles, which considers players and marines on turrets as huge deal. Since they do little against the tank.
	Override Int AssessThreatLevel (Actor Other, Bool CheckPlayers)
	{
		If (!Other) Return THREAT_NONE;
		Int ThreatLvl = KAI_BaseVehicle.AssessThreatLevel(Other, CheckPlayers);
		//If the hull has the normal turret, and the unstoppable threat is a player with god or buddha mode 1. Or an invulnerable but non-NODAMAGE NPC.
		//Then don't consider them as much of a threat, since the turret can kill them using APFSDS anyway.
		If (Turret Is "MVP_MBTTurret" && ThreatLvl == THREAT_UNSTOPPABLE)
		{
			//Downgrade the threat if it doesn't have god or buddha 2, or NODAMAGE. And also if it doesn't have an esoteric flag combo that makes it untouchable.
			If (Other.Player && !(Other.Player.Cheats & (CF_GODMODE2|CF_BUDDHA2)) && !Other.bNoDamage && !(Other.bNonShootable && Other.bNoBlockmap && Other.bNoRadiusDmg))
				Return THREAT_SUPERDANGER; //It's not unstoppable, merely insanely dangerous.
		}
		Return ThreatLvl;
	}
	
	Mixin MVP_MBT_SmokeHandling;
	
	Override Void SpawnHeadlights ()
	{
		Headlights.Push (SpawnVehicleHeadlight (Self,(64,48,32),VHSF_SPRITEROT|VHSF_CARDINALS|VHSF_16ANGLES,lightcolor:(255,195,165),512,spotlightangles:(25,50)));
		Headlights.Push (SpawnVehicleHeadlight (Self,(64,-48,32),VHSF_SPRITEROT|VHSF_CARDINALS|VHSF_16ANGLES,lightcolor:(255,195,165),512,spotlightangles:(25,50)));
		Headlights.Push (SpawnVehicleHeadlight (Self,(128,56,32),VHSF_SPRITEROT|VHSF_BACKLIGHT|VHSF_CARDINALS|VHSF_16ANGLES,lightcolor:(255,150,0),64,spotlightangles:(45,90)));
		Headlights.Push (SpawnVehicleHeadlight (Self,(128,-56,32),VHSF_SPRITEROT|VHSF_BACKLIGHT|VHSF_CARDINALS|VHSF_16ANGLES,lightcolor:(255,150,0),64,spotlightangles:(45,90)));
	}
	
	Override Void Die (Actor Source, Actor Inflictor, Int DmgFlags, Name MeansOfDeath)
	{
		If (WarningZone) WarningZone.Destroy();
		If (DeathLight) DeathLight.Destroy();
		Super.Die (Source, Inflictor, DmgFlags, MeansOfDeath);
	}
	
	Override Void OnDestroy()
	{
		Super.OnDestroy();
		If (WarningZone) WarningZone.Destroy();
		If (DeathLight) DeathLight.Destroy();
	}
	
	//Produce crushing related obituaries for players.
	Override String GetObituary (Actor Victim, Actor Inflictor, Name MOD, Bool PlayerAttack)
	{
		String MeleeObituaries[] = {
		"%o was ran over by a tank",
		"%o didn't check both ways when crossing the street",
		"%o became roadkill",
		"%o is practicing their skidmark impression"
		};
		If (Inflictor == Self && (MOD == 'Crush' || MOD == 'TankCrush'))
		{
			//Print a "special" obituary if the player was intentionally crushed by the tank.
			If (Target == Victim && User_CrushMode == CRUSH_ACTIVE && Random (0,255) < 255/4) //4/6/1989
			{
				Let Checker = SM_MarineChecker(EventHandler.Find ("SM_MarineChecker"));
				String PlayerName;
				If (Victim && Victim.Player)
					PlayerName = Victim.Player.GetUsername();
				Else If (Victim)
					PlayerName = Victim.GetTag();
				Return String.Format ("%s 没有被压碎 %s",PlayerName,Checker.ScopeHack.Date);
			}
			Else
				Return MeleeObituaries[Random(0,MeleeObituaries.Size()-1)];
		}
		
		If (IsDead (Self) && Inflictor Is "MVP_Explosion" || Inflictor Is "MVP_BigExplosion")
			Return "%o got blown up along with a tank";
		
		Return Super.GetObituary (Victim, Inflictor, MOD, PlayerAttack);
	}
	
	//The tank stays still to either deploy smokescreens (To stay in them to not be hit by enemies), or if it finds level geometry to fire behind.
	Override Bool StayStillAndShoot (Actor CheckSightFrom)
	{
		If (StayStillDelay) Return False; //Too soon
		If (Turret && Turret.bDontStayAround) Return False; //Turret told you to not stop.
		//If (Turret && Turret.ElevationState != Turret.ELEVATION_INBOUNDS) Return False; //The turrets' target is too high up or low down to shoot.
		//If (IsPatrolling (Self) && bChaseGoal) Return False; //Don't stop if patrolling and "Don't Chase Goal" is on.
		//Let's see if we should do some smoke. Only if the delay is 0 though.
		If (!User_NoSmokeScreen && GetAge () > 3*GameTicRate && ShouldDeploySmoke() > 250) //The age check prevents the tank from immediately dropping smoke once spawned.
		{
			If (!CheckSight (Target,SF_IGNOREWATERBOUNDARY))
			{
				StayStillDelay = Random (4,16); //Check again in a few tics, to not run sight checks every tick.
				Return False;
			}
			EndRetreat();
			SetStateLabel ("StickAround.SmokeScreen"); //Stay still and deploy a smoke screen.
			Return True;
		}
		//Let's see if we can take a hull down position, regardless of the stand delay. But only if not patrolling with bChaseGoal.
		Else If (!User_NoHullDown && !IsInState (Self, "StickAround") && !(IsPatrolling (Self) && bChaseGoal) && !User_Stationary
		&& EnterHullDownPosition (Height-16) && !EnterHullDownPosition (Height+16,True))
		{
			If (!Turret.CheckSight (Target,SF_IGNOREWATERBOUNDARY)) //Since this returns true if the HULL is covered, duh.
			{
				StayStillDelay = Random (4,16); //Check again in a few tics, to not run sight checks every tick.
				Return False;
			}
			EndRetreat();
			SetStateLabel ("StickAround");
			Return True;
		}
		
		Return False;
	}
	
	//Increase smokescreen chance based on quantity and power of enemies around the target or yourself, and your targets' threat level.
	Int ShouldDeploySmoke()
	{
		Int Chance = Random (0,200);
		If (G_SkillPropertyInt (SKILLP_FastMonsters)) Chance += 48; //Bonus chance for spammy fast monsters.
		Actor Origin = Target;
		If (!Origin) Origin = Self; //Ternary operators don't work with pointers.
		
		Chance += AttackByQuantity (Origin,1536) >> 1;
		
		Switch (AssessThreatLevel (Target))
		{
			Case THREAT_UNSTOPPABLE:
				Chance += 800;
				Break;
			Case THREAT_SUPERDANGER:
				Chance += 200;
				Break;
			Case THREAT_VERYDANGEROUS:
				Chance += 50;
				Break;
			Case THREAT_DANGEROUS:
				Chance += 30;
				Break;
			Default:
				Break;
		}
		//Console.Printf ("%s - ShouldDeploySmoke(): %d",Self.GetClassName(),Chance);
		Return Chance;
	}
	
	//Can the tank enter the hull down position ?
	Bool EnterHullDownPosition (Double HeightOfs, Bool FromTurret = False)
	{
		Actor Whomst = Target;
		If (!Whomst)
			Whomst = FindNearestEnemy (2048);
		If (!Whomst)
			Return False;
		
		Let Check = New ("MVP_MBTHullDownCheck");
		Double AimPitch = PitchTo (Whomst,HeightOfs,Whomst.Height/2);
		Vector3 CheckDir = ( AngleToVector(AngleTo(Whomst), Cos(AimPitch)) , -Sin(AimPitch));
		Check.Trace (Pos.PlusZ(HeightOfs),CurSector,CheckDir,!FromTurret ? Radius*4 : Radius*3.5,0);
		//if (check.badlof)console.printf ("hull down with offset of %.2f failed",heightofs);
		//FSpawnParticleParams P; P.Color1 = "pink"; P.Style = STYLE_None; P.Lifetime = 3; P.Size = 4; P.StartAlpha = 1; P.FadeStep = -1; P.Flags = SPF_FULLBRIGHT;
		//KAI_LOFRaycast.VisualizeTracePath(Pos.PlusZ(HeightOfs),check.results.hitpos,check.results.distance,8,p);
		Return !(Check.BadLOF);
	}
	
	//If too many ranged enemies are near the target, especially powerful ones, avoid crushing.
	Int DoNotCrush (Actor Other)
	{
		If (!Other) Return 0;
		Int Penalty;
		Actor Mobj;
		Let Enemies = BlockThingsIterator.Create (Other,768);
		While (Enemies.Next())
		{
			Mobj = Enemies.Thing;
			
			If (!Mobj || Mobj == Self || /*Mobj == Other ||*/ IsInanimateObject (Mobj) || IsDead (Mobj) || !IsActorHostile (Mobj)) Continue;
			
			If (IsMeleeOnlyEnemy (Mobj) || Other.Distance3DSquared (Mobj) > 768*768 || !CheckSight (Mobj)) Continue;
			
			//Increase the penalty in accordance to how dangerous the enemies around the Other actor are.
			Switch (AssessThreatLevel (Mobj))
			{
				Case THREAT_UNSTOPPABLE:
					Penalty += 1000;
					Break;
				Case THREAT_SUPERDANGER:
					Penalty += 200;
					Break;
				Case THREAT_VERYDANGEROUS:
					Penalty += 50;
					Break;
				Case THREAT_DANGEROUS:
					Penalty += 25;
					Break;
				Default:
					Break;
			}
		}
		Return Penalty;
	}
	
	Bool IsMeleeOnlyEnemy (Actor Other)
	{
		Return (Other && Other.MeleeState && !Other.MissileState);
	}
	
	//Finds a living enemy to crush within Range, and sets it as the tanks' target.
	//FOV: The FOV to use for the sight check.
	//Range: The range to find a victim to run over in.
	//MaxTurretRange: If the turrets' target is outside of this range from it, begin chasing that target instead.
	Void MBT_RunShitOver (Double FOV = 45, Double Range = 512, Double MaxTurretRange = 2048)
	{
		If (Range <= 0 || bNoCrushing) Return;
		//The turrets' target is too far from it or out of sight. So start chasing that instead.
		If (Turret && Turret.Target && (Turret.Distance3DSquared (Turret.Target) > MaxTurretRange || !Turret.CheckSight(Turret.Target)))
		{
			Target = Turret.Target;
			Return;
		}
		If (Health < 1000) Return;
		Actor Mobj;
		Array <Actor> Candidates;
		Let Roadkills = BlockThingsIterator.Create (Self,Range);
		While (Roadkills.Next())
		{
			Mobj = RoadKills.Thing;
			
			If (!Mobj || Mobj == Self) Continue;
			If (IsDead (Mobj) || IsInanimateObject (Mobj) || IsFlying (Mobj) || !IsCollidable (Mobj,Self) || !CanBeTargeted(Self,Mobj) || !IsActorHostile (Mobj)) Continue;
			
			If (Mobj.Speed >= Speed*2 || Mobj.Speed >= Speed && Mobj.Target && Mobj.bFrightened) Continue; //Too fast to catch. Or faster than you and running away.
			
			Int Level = AssessThreatLevel (Mobj,True);
			
			//Don't fuck with super dangerous enemies.
			Switch (Level)
			{
				Case THREAT_DANGEROUS:
				Case THREAT_VERYDANGEROUS:
				Case THREAT_SUPERDANGER:
				Case THREAT_UNSTOPPABLE:
					Continue;
				Default:
					Break;
			}
			
			//If it's not a really weak enemy and they have some kind of range attack, avoid them. If they are weak, ignore that they have a range attack.
			If (Level >= THREAT_NORMAL && Mobj.MissileState) Continue;
			
			//And at last, the distance and sight checks.
			If (Distance3DSquared (Mobj) > Range*Range || !CheckSight (Mobj)) Continue;
			
			Candidates.Push(Mobj);
		}
		
		If (!Candidates.Size())
			Return;
		
		Target = GetClosestActor (Candidates,Self.Pos,Range);
	}
	
	Void EndRetreat()
	{
		If (!Retreating) Return;
		A_SetSpriteRotation (0);
		A_SetAngle (Angle+180);
		Speed = GetDefaultSpeed (GetClass()); //For the T-72 mode.
		RetreatLoops = 0;
		Retreating = False;
	}
	
	Void A_MBTLook ()
	{
		If (User_CrushMode != CRUSH_PASSIVE)
			MBT_RunShitOver (220,TankCrushRange); //Find something to run over.
		If (!Target) //Nothing found, just look for actors normally.
			KAI_Look (User_Stationary ? LOF_NOJUMP : 0,maxseedist:MaxTargetRange,8192,220);
		If (Turret && Turret.Target && !IsDead(Turret.Target)) //Still no target, so get your turrets' target instead.
		{
			Target = Turret.Target;
			If (!User_Stationary) SetStateLabel ("See");
		}
	}
	
	// For the SPAAG, make it do more damage to flying actors using DoSpecialDamage on both the projectile and hitscan shrapnel puffs.
	// Design wise, the back radar of the SPAAG should have a separate REAL hitbox that receives damage. Whose relative position snaps based on the turret angle.
	Enum TurretTypes
	{
		TURRET_NORMAL	= 0, //The normal MBT variant.
		TURRET_TOS1		= 1, //Thermobaric rocket artillery variant, no gravity affected rockets because I'm not THAT nuts (Actually good at programming).
		TURRET_BMPT		= 3, //Light tank-ish variant of the tank. With only machine guns and rockets, and less health.
		TURRET_SPAAG	= 4, //AA variant of the tank, with a functional top radar.
	}
	
	Const TankAngleLimit = 3; //How much the tank can turn per step.
	Const TankCrushRange = 640;
	Bool Retreating;
	Int RetreatLoops;
	Actor WarningZone;
	DynamicLight DeathLight;
	Sound IdleSound;
	
	Bool HasAltHull;
	
	Bool User_FocusFire; //Should the tanks' remote weapon station, if any, not always try to not have the same target as the turret ?
	Bool User_Stationary; //The tank always stays in place, similar to the HECU M1 Abrams tanks from Half-Life 1.
	//Original code donut stael.
	//Main difference is that this control both corpse AND live enemy crushing.
	Int User_CrushMode;
	Enum CorpseCrushModes
	{
		CRUSH_NONE = -1, //No crushing at all, only pushing.
		CRUSH_ACTIVE = 0, //Actively seek corpses and enemies.
		CRUSH_PASSIVE = 1 //Crush enemies and corpses, but only by happenstance.
	};
	String User_RWS; //What remote weapon station should the tank use ? The two types are MG and Minigun.
	Bool User_T72Mode; //xd
	Int User_APSDelay; //Trophy cooldown.
	Int User_AltAPSDelay; //Shtora-1 cooldown.
	Bool User_NoSmokescreen; //The tank will not deploy smokescreens.
	Bool User_NoHullDown; //The tank will not attempt to enter hull down positions.
	States
	{
		Sprites:
			AMBT ABCDEF 0;
		Spawn:
			MMBT A 0 NoDelay {Sprite = !HasAltHull ? GetSpriteIndex ("MMBT") : GetSpriteIndex ("AMBT");}
			#### A 1
			{
				A_StopSound (CHAN_MOVING);
				A_StartSound(IdleSound,CHAN_IDLING,CHANF_LOOPING,attenuation:0.5);
				A_MBTLook();
				If (User_Stationary && Target) StayStillAndShoot (Null); //Still run the smokescreen code even if stationary.
			}
			Loop;
		//High quality code rips.
		Idle:
			#### ABCDEF 2
			{
				A_QuakeEx (1,1,1,2,0,512,flags:QF_GROUNDONLY,rollintensity:0.2);
				A_StopSound (CHAN_IDLING);
				A_StartSound (ActiveSound,CHAN_MOVING,CHANF_LOOPING,attenuation:0.6);
				
				A_MBTLook();
				
				//Archvile trolling move activated.
				If (User_CrushMode == CRUSH_ACTIVE)
				{
					If (CorpseTarget && CorpseTarget.bDontGib) CorpseTarget = Null; //Disgard crushed corpses.
					//Don't have a corpse to crush already.
					If (!CorpseTarget)
					{
						CorpseTarget = FindNearestCorpse(); //Nearby corpse found, go and crush it.
						If (CorpseTarget) 
							KAI_MoveTowards (CorpseTarget.Pos,0.8,8);
						Else //Still no corpse found, so just begin wandering around.
							KAI_Wander(48,1024,128,0.5,TankAngleLimit);
					}
					
					//There is an available corpse to head to and crush.
					If (CorpseTarget)
						KAI_MoveTowards (CorpseTarget.Pos,0.8,8);
				}
				Else
					KAI_Wander(48,1024,128,0.5,TankAngleLimit);
				
				FollowPlayerControl (512);
				
				If (User_CrushMode != CRUSH_NONE) KAI_CrushCorpses();
			}
			Loop;
		See:
			#### ABCDEF 2
			{
				A_QuakeEx (1,1,1,2,0,512,flags:QF_GROUNDONLY,rollintensity:0.2);
				If (User_Stationary) //Shouldn't be here.
					Return State (SpawnState);
				A_StopSound (CHAN_IDLING);
				A_StartSound (ActiveSound,CHAN_MOVING,CHANF_LOOPING,attenuation:0.5);
				//Try to find someone else to run over before the stock retargeting code runs.
				If (User_CrushMode == CRUSH_ACTIVE)
					If (!Target || Distance3DSquared (Target) > TankCrushRange*TankCrushRange || IsFlying(Target))
						MBT_RunShitOver (360,TankCrushRange);
				MoveToParams Params;//console.printf ("retreat dist %d",retreatrange);
				Params.DetourFactor = 0.25;
				Params.Attempts = 32;
				Params.StepThreshold = 32;
				Params.RunRad = 384;
				
				Bool TargetLevel = AssessThreatLevel (Target);
				
				//Zig zag around target as long as you are far away to not need to move straight to it. Or if the target is too dangerous or you're weak.
				Bool DoZigZag = (Target && (TargetLevel < ThreatLevelThreshold && Health >= 1000 && Distance3DSquared(Target) > 768*768 && CheckSight(Target)));
				Int RealRange = RetreatRange;
				
				//If moving to a target that is below the threat threshold, never retreat. In other words, don't retreat when trying to run over someone.
				//But do retreat if there's too many dangerous enemies around the target/
				Int ShellType = MVP_MBTTurret(Turret).ShellType;
				If (DoNotCrush (Target) < 50)// &&
				//or you are going to fire an explosive shell and are too close.
				//!(ShellType != MVP_MBTTurret(Turret).TYPE_APFSDS && ShellType != MVP_MBTTurret(Turret).TYPE_NONE && Turret.Target && Turret.Distance3DSquared (Turret.Target) <= 640*640))
				{
					If (TargetLevel < ThreatLevelThreshold && User_CrushMode == CRUSH_ACTIVE && Health > 1000) RetreatRange = 0;
					Else RetreatRange = RealRange;
				}
				Else
					RetreatRange = RealRange;
				
				KAI_LandVehicleChase (flags:LVC_USERETREATSTATE|LVC_PLAYERSASTHREATS|LVC_MAKEFRIENDSIDLE|(DoZigZag ? LVC_ZIGZAGGING : 0),turnradius:TankAngleLimit,512);
				RetreatRange = RealRange;
				If (User_CrushMode != CRUSH_NONE) KAI_CrushCorpses();
				Return State (Null);
			}
			Loop;
		//Retreat by "reversing", AKA calling KAI_VehicleRetreat, but using SpriteRotation and an inverted move animation to appear as facing the target.
		Retreat:
			#### A 0
			{
				If (User_Stationary) //Shouldn't be here.
					Return State (SpawnState);
				Retreating = True;
				A_SetSpriteRotation (180);
				A_SetAngle (Angle-180);
				NextMovePos = (Double.NaN,Double.NaN,Double.NaN); //Reset move pos.
				If (User_T72Mode) Speed /= 2;
				Return State (Null);
			}
		Retreat.Move:
			#### FEDCBA 2
			{
				A_QuakeEx (1,1,1,2,0,512,flags:QF_GROUNDONLY,rollintensity:0.2);
				A_StopSound (CHAN_IDLING);
				A_StartSound (ActiveSound,CHAN_MOVING,CHANF_LOOPING,attenuation:0.5);
				KAI_VehicleRetreat (Target,96,512,32,VRF_ZIGZAG,0.25,TankAngleLimit);
				If (User_CrushMode != CRUSH_NONE) KAI_CrushCorpses();
				Int Temp = RetreatLoops;
				RetreatLoops = 0;
				StayStillAndShoot (Null);
				RetreatLoops = Temp;
			}
		Retreat.End:
			#### A 0
			{
				//Target no longer in sight, keep retreating for a bit before moving forward again.
				If (!RetreatLoops && RetreatLoops != -1)
				{
					If (!CheckSight(Target))
						RetreatLoops = Random (12,24);
					If (!RetreatLoops && !FindNearestEnemy (RetreatRange))
						RetreatLoops = Random (4,8);
					If (!RetreatLoops && Turret && Turret.Target && Turret.ElevationState != Turret.ELEVATION_TOOHIGH)
						RetreatLoops = Random (6,12);
					
					RetreatLoops = Random (12,24);
				}
					//console.printf ("loops %d",retreatloops);
				If (RetreatLoops > 0 && Target && !IsDead (Target))
				{
					RetreatLoops--;
					If (RetreatLoops == 0)
						RetreatLoops--;
					Return FindState ("Retreat.Move",True);
				}
				
				EndRetreat();
				Return State (Null);
			}
			Goto See;
		//Hull down position.
		StickAround:
			#### # 0
			{
				ChaseTimer = 0;
				A_StopSound (CHAN_MOVING);
				A_StartSound (IdleSound,CHAN_IDLING,CHANF_LOOPING,attenuation:0.5);
				ChaseTimer = Random (5,10)*GameTicRate;
			}
			#### # 1
			{
				If (!Turret.Target || !Turret.CheckSight (Turret.Target,SF_IGNOREWATERBOUNDARY) || (!EnterHullDownPosition (Height-16) || EnterHullDownPosition (Height+16,True))) ChaseTimer--;
				Else ChaseTimer = Random (5,10)*GameTicRate;
				//Console.Printf ("Hull down timer %d",ChaseTimer);
				//Get out if the turret can't aim, an overwhelming enough amount of enemies is nearby, the target has gotten way too close.
				//Or the level changed, and the cover sucks now.
				If (ChaseTimer < 0 || Turret.ElevationState != Turret.ELEVATION_INBOUNDS || AttackByQuantity (Self,512,True) > 120 || FindNearestEnemy (Radius+192))
				{
					StayStillDelay = Random (3,6)*GameTicRate;;
					Return FindState ("See");
				}
				Return State (Null);
			}
			Wait;
		//Deploying smokescreen.
		StickAround.SmokeScreen:
			#### # 0
			{
				A_StopSound (CHAN_MOVING);
				A_StartSound (IdleSound,CHAN_IDLING,CHANF_LOOPING,attenuation:0.5);
				A_StartSound ("Vehicle/Tank/Smokescreen",CHAN_WEAPON,attenuation:0.5);
				
				bShadow = True; //Give yourself MF_SHADOW too, although the smoke particles themselves do have SHADOWBLOCK too.
				ShadowPenaltyFactor = 1.5;
				Turret.bShadow = True; //Conceal the turret too.
				Turret.ShadowPenaltyFactor = 1.5;
				If (Turret.Turret) //And if it has a remote weapon station, protect that too.
				{
					Turret.Turret.bShadow = True;
					Turret.Turret.ShadowPenaltyFactor = 1.5;
				}
				
				StayStillDelay = Random (5,8)*GameTicRate; //Use the stay delay to also get OUT of the smoke screen delay.
				//Spawn smokescreen.
				Actor Cover = Spawn ("MVP_SmokeScreen",Pos);
				Cover.Master = Self; //So the screen can follow the tank, even if it does stay in one place.
				Cover.Speed = 8;
				Cover.ReactionTime = 64;
				Cover.Threshold = 256;
				Cover.Stamina = Int(35*1.5);
				Cover.Mass = StayStillDelay;
			}
			#### # 4 A_JumpIf ((--StayStillDelay < -16), 1);
			Goto StickAround.SmokeScreen+1;
			#### # 0
			{
				A_StopSound (CHAN_WEAPON);
				bShadow = False;
				ShadowPenaltyFactor = Default.ShadowPenaltyFactor;
				Turret.bShadow = False; //Conceal the turret too.
				Turret.ShadowPenaltyFactor = Turret.Default.ShadowPenaltyFactor;
				If (Turret.Turret)
				{
					Turret.Turret.bShadow = False;
					Turret.Turret.ShadowPenaltyFactor = Turret.Turret.Default.ShadowPenaltyFactor;
				}
				StayStillDelay = Random (4,8)*GameTicRate;
			}
			Goto See;
		Death:
			MBTD A 1
			{
				Vector3 Back = Vec3Angle (96,GetNearestCardinalAngle(True));
				DamageSmokeDelay = 0;
				A_StartSound ("SFX/Fire",CHAN_VOICE,CHANF_LOOPING,0.7,0.8);
				Frame = !HasAltHull ? 0 : 1; //Normal = A, Alt = B
				
				//General explosion
				Actor Boom = Spawn ("MVP_Explosion",Pos.PlusZ(Height/2));
				Boom.Scale *= 2.5;
				Boom.SetDamage (300);
				Boom.MaxTargetRange = 384;
				Boom.MeleeRange = 96;
				Boom.bNoGravity = True;
				Boom.bGetOwner = True; //So the dead tank is considered the source.
				Boom.Target = Self;
				
				//Spawn dust around tank.
				Actor Dusty = Spawn ("MVP_GroundDustSpawner",Pos.PlusZ(Height/2));
				//Dusty.RadiusDamageFactor = 0;
				Dusty.ReactionTime = 128;
				Dusty.Threshold = 256;
				
				//Engine explosion and fire
				Boom = Spawn ("MVP_Explosion",Back.PlusZ(Height/2+16));
				Boom.Scale *= 1.75;
				Boom.SetDamage (150);
				Boom.MaxTargetRange = 192;
				Boom.MeleeRange = 48;
				Boom.bNoGravity = True;
				Boom.bGetOwner = True; //So the dead tank is considered the source.
				Boom.Target = Self;
				DeathLight = DynamicLight(Spawn("PointLightFlickerRandom",Back));
				If (DeathLight)
				{
					DeathLight.Args[3] = 64;
					DeathLight.Args[4] = 96;
					DeathLight.Args[0] = 231; //RGB
					DeathLight.Args[1] = 207;
					DeathLight.Args[2] = 13;
					DeathLight.Angle = 350; //Flicker chance.
				}
			}
			MBTD # -1;
			Stop;
		XDeath:
			MBTD A 1
			{
				Frame = !HasAltHull ? 22 : 23; //Normal = W, Alt = X
				
				Actor Boom = Spawn ("MVP_BigExplosion",Pos.PlusZ(32));
				Boom.MaxTargetRange = 640;
				Boom.MeleeRange = 256;
				Boom.SetDamage(600);
				Boom.A_SetScale (2.5);
				
				Actor Dusty = Spawn ("MVP_GroundDustSpawner",Pos.PlusZ(32));
				Dusty.RadiusDamageFactor = 0;
				Dusty.ReactionTime = 512;
				Dusty.Threshold = 512;
				
				A_QuakeEx (2,2,2,GameTicRate*2,0,1024,flags:QF_3D|QF_SCALEDOWN|QF_GROUNDONLY,rollintensity:2);
				
				//Spawn a random amount of flames around the APC wreck.
				SpawnDeathFlames(amount:(12,24),radmul:1);
			}
			MBTD # -1;
			Stop;
	}
}

//Tank variant aliases.
Class MVP_MBT_MG : Actor //Tank with 12.7mm RWS.
{
	Override Void PostBeginPlay()
	{
		Actor Tonk = Spawn ("MVP_MBT",Pos);
		If (Tonk)
		{
			Tonk.CopyFriendliness (Self,False);
			MVP_MBT(Tonk).User_RWS = "Machine Gun";
			Tonk.ChangeTID (TID);
			Tonk.Angle = Angle;
		}
		Destroy();
	}
}

Class MVP_MBT_Minigun : Actor //Tank with 7.62mm minigun.
{
	Override Void PostBeginPlay()
	{
		Actor Tonk = Spawn ("MVP_MBT",Pos);
		If (Tonk)
		{
			Tonk.CopyFriendliness (Self,False);
			MVP_MBT(Tonk).User_RWS = "Minigun";
			Tonk.ChangeTID (TID);
			Tonk.Angle = Angle;
		}
		Destroy();
	}
}

Class MVP_MBT_Full : Actor //Tank with active protection systems on.
{
	Override Void PostBeginPlay()
	{
		Actor Tonk = Spawn ("MVP_MBT",Pos);
		If (Tonk)
		{
			Tonk.CopyFriendliness (Self,False);
			MVP_MBT(Tonk).User_APSDelay = GameTicRate*2;
			MVP_MBT(Tonk).User_AltAPSDelay = GameTicRate*2;
			Tonk.ChangeTID (TID);
			Tonk.Angle = Angle;
		}
		Destroy();
	}
}

Class MVP_MBT_Full_MG : Actor //Ditto, but with 12.7mm RWS.
{
	Override Void PostBeginPlay()
	{
		Actor Tonk = Spawn ("MVP_MBT",Pos);
		If (Tonk)
		{
			Tonk.CopyFriendliness (Self,False);
			MVP_MBT(Tonk).User_RWS = "Machine Gun";
			MVP_MBT(Tonk).User_APSDelay = GameTicRate*2;
			MVP_MBT(Tonk).User_AltAPSDelay = GameTicRate*2;
			Tonk.ChangeTID (TID);
			Tonk.Angle = Angle;
		}
		Destroy();
	}
}

Class MVP_MBT_Full_Minigun : Actor //Ditto, but with 7.62mm minigun.
{
	Override Void PostBeginPlay()
	{
		Actor Tonk = Spawn ("MVP_MBT",Pos);
		If (Tonk)
		{
			Tonk.CopyFriendliness (Self,False);
			MVP_MBT(Tonk).User_RWS = "Minigun";
			MVP_MBT(Tonk).User_APSDelay = GameTicRate*2;
			MVP_MBT(Tonk).User_AltAPSDelay = GameTicRate*2;
			Tonk.ChangeTID (TID);
			Tonk.Angle = Angle;
		}
		Destroy();
	}
}

//Normal tank turret. Can attack with its' attached RWS (If any), it's 130mm cannon with 3 shell types, and its' 7.62mm coaxial machine gun.
Class MVP_MBTTurret : MVP_BaseTurret
{
	Default
	{
		XScale 1;
		YScale 0.833333; //1 / 1.2
		Health 2500;
		Height 32;
		DeathHeight 32;
		Radius 72;
		FriendlySeeBlocks 128;
		MaxTargetRange 16384;
		ShadowPenaltyFactor 0.5;
		Mass 30000;
		Tag "M6V3-EX Turret";
		Obituary "%o was blown up by a tank turret";
		KAI_BaseTurret.MaximumPitch -20;
		KAI_BaseTurret.MinimumPitch 10;
		KAI_BaseTurret.TurnSoundRadius 0.5;
		MVP_BaseTurret.SmokeDelay 0;
		KAI_BaseVehicle.SearchTime 175;
		//The attack speeds for the target prediction dynamically change based on the ammo type. For example APFSDS will be faster than HEAT.
		KAI_BaseTurret.AttackSpeed 300;
		KAI_BaseTurret.FastAttackSpeed 350;
		KAI_BaseTurret.CombatAngleTurnRate 40;
		KAI_BaseTurret.CombatPitchTurnRate 30;
		KAI_BaseTurret.TurnSound "Vehicle/Tank/TurretTurn";
		AttackSound "Vehicle/Tank/CannonFire";
		KAI_Actor.ThreatLevel THREAT_VERYDANGEROUS;
		+KAI_BaseTurret.TransferDamage;
		+KAI_BaseTurret.TurnSoundNoStop;
		+MissileMore;
		+MissileEvenMore;
		
		//"Armor"
		DamageFactor 0.6; //Generic damage factor.
		DamageFactor "ExplosiveImpact", 0.5;
		DamageFactor "Explosion", 0.5;
		DamageFactor "Explosive", 0.5;
		DamageFactor "TankShell", 0.5;
		DamageFactor "Shell", 0.7;
		DamageFactor "APShell", 1.0; //Super susceptible to APFSDS.
		DamageFactor "Grenade", 0.4;
		DamageFactor "HitScan", 0.55; //The generic damage type of hitscan attacks.
		DamageFactor "Shrapnel", 0.2;
		DamageFactor "Fire", 0.3;
		DamageFactor "Plasma", 0.5;
		//Damage factors specific to the Smart Marines.
		DamageFactor "MarineHMG", 0.5;
		DamageFactor "MarineGrenade", 0.5;
		DamageFactor "MarineRifle", 0.55;
		//Vehicle damage factors
		DamageFactor "Autocannon", 0.25;
		DamageFactor "RifleBullet", 0.1;
		DamageFactor "Missile", 0.7;
		DamageFactor "AntiAir", 0.3;
	}
	
	Int UpdateTankElevation (Int FaceDown, Int FaceStraight, Int FaceUp, Int FaceUp2)
	{
		If (Pitch >= 10 && Pitch >= 5)
			Return FaceDown;
		Else If (Pitch < 10 && Pitch >= -10)
			Return FaceStraight;
		Else If (Pitch < -10 && Pitch >= -17)
			Return FaceUp;
		Else If (Pitch <= -20)
			Return FaceUp2;
		
		Return FaceStraight;
	}
	
	Override Void OnDestroy()
	{
		Super.OnDestroy();
		If (WarningZone) WarningZone.Destroy();
		If (PreFireZone) PreFireZone.Destroy();
	}
	
	Override Void Die (Actor Source, Actor Inflictor, Int DmgFlags, Name MeansOfDeath)
	{
		If (WarningZone) WarningZone.Destroy();
		If (PreFireZone) PreFireZone.Destroy();
		Super.Die (Source, Inflictor, DmgFlags, MeansOfDeath);
	}
	
	Override String GetObituary (Actor Victim, Actor Inflictor, Name MOD, Bool PlayerAttack)
	{
		String GodKillObituaries[] = {
		"%o got that shit eating grin wiped off %p face",
		"%o got %p cheating award",
		"%o discovered that cheaters never prosper",
		"%o isn't as indestructible as %g thinks"};
		
		If (Inflictor.GetClass() == "MVP_MBTFireEffect") //Caught in the firing blast.
			Return "%o stood too close to a tank";
		If (Inflictor Is "MVP_RifleBullet") //Coaxial
			Return "%o was gunned down by a tanks' coaxial machine gun";
		If (Inflictor Is "MVP_HEATShell") //Took 10 kilos of explosive to the face.
			Return Inflictor.Obituary;
		
		//Print special obituaries for players with god mode or the bInvulnerable flag who got killed by the APFSDS round.
		If (Inflictor Is "MVP_APFSDSShell" && MVP_APFSDSShell(Inflictor).KilledCheater)
			Return GodKillObituaries[Random(0,GodKillObituaries.Size()-1)];
		
		If (Inflictor Is "MVP_APFSDSShell") //APFSDS killed normal player.
			Return Inflictor.Obituary;
		
		String ATGMLandObituaries[] = {
		"%o was hit by an anti tank missile",
		"%o couldn't dodge a missile in time",
		"%o failed their Neo impression",
		"%o was not the chosen one"};
		
		String ATGMAirObituaries[] = {
		"%o was shot out of the sky",
		"%o couldn't flap their wings away in time",
		"%o is on a death spiral"};
		
		String MissileShaker = "%o couldn't withstand the missile shaker"; //https://www.youtube.com/watch?v=JlT43Ra21hs
		
		//Missile obituaries, both ground and air blasts.
		If (Inflictor Is "MVP_ATGM")
		{
			//Killed player with the ground blast.
			If (!Inflictor.bFalling)
			{
				If (Random (0,255) < 16)
					Return MissileShaker;
				
				Return ATGMLandObituaries[Random(0,ATGMLandObituaries.Size()-1)];
			}
			//Died from air blast.
			Else
			{
				If (Random (0,255) < 16)
					Return MissileShaker;
				
				If (Random (0,255) < 255/2) //50/50 chance to use an air obituary if the player was off the ground.
					Return ATGMAirObituaries[Random(0,ATGMAirObituaries.Size()-1)];
				
				Return ATGMLandObituaries[Random(0,ATGMLandObituaries.Size()-1)]; //The land obituaries still work since they are generic enough.
			}
		}
		
		If (IsDead (Self) && MOD == 'Crush')
			Return "%o had a Russian tank turret fall on them";
		
		If (IsDead (Self) && Inflictor Is "MVP_Explosion" || Inflictor Is "MVP_BigExplosion")
			Return "%o got blown up along with a tank";
		
		Return Super.GetObituary (Victim, Inflictor, MOD, PlayerAttack); //Return the generic obituary property.
	}
	
	Override Void PostBeginPlay ()
	{
		Vector3 Original = TurretOffsets;
		/*NOTE: The RWS can never look perfect due to the tank being made out of sprites. A Z offset of 0 looks like the station is sunken into its' platform
		from the front, but from the side makes it look actually attached. While a Z of 3 looks normal from the front, but makes the RWS float on the side.*/
		TurretOffsets = (-6,7.5,3);
		Super.PostBeginPlay();
		TurretOffsets = Original;
		
		If (APSDelay == INT.MAX) APSCooldown = INT.MAX;
		If (AltAPSDelay == INT.MAX) AltAPSCooldown = INT.MAX;
		
		MissileState = FindState ("Fire",True);
		AttackStates.Push (FindState("Fire",True));
		AttackStates.Push (FindState("Fire.Coaxial",True));
		WarningZone = WarnMarines (0,48,Self); //Default radius for the coaxial.
	}
	
	//Don't use the threat assessment of MVP vehicles, which considers players and marines on turrets as huge deal. Since they do little against the tank.
	Override Int AssessThreatLevel (Actor Other, Bool CheckPlayers)
	{
		If (!Other) Return THREAT_NONE;
		Int ThreatLvl = KAI_BaseVehicle.AssessThreatLevel(Other, CheckPlayers);
		//If the unstoppable threat is a player with god or buddha mode 1. Or an invulnerable but non-NODAMAGE NPC.
		//Then don't consider them as much of a threat, since APFSDS still kills them.
		If (ThreatLvl == THREAT_UNSTOPPABLE)
		{
			//Downgrade the threat if it doesn't have god or buddha 2, or NODAMAGE. And also if it doesn't have an esoteric flag combo that makes it untouchable.
			If (Other.Player && !(Other.Player.Cheats & (CF_GODMODE2|CF_BUDDHA2)) && !Other.bNoDamage && !(Other.bNonShootable && Other.bNoBlockmap && Other.bNoRadiusDmg))
				Return THREAT_SUPERDANGER; //It's not unstoppable, merely insanely dangerous.
		}
		Return ThreatLvl;
	}
	
	Override Bool ShouldAttack (Bool NoStateJump)
	{
		If (!KAI_BaseTurret.ShouldAttack()) Return False;
		If (Target && !CheckFOV (Target,60/2)) Return False; //KLUDGE: We need to do the null check here, because as of GZDoom 4.10, it's not done internally. Crashing the game.
		If (IsOverPitchLimits (Target,8,Target.Height/2) != ELEVATION_INBOUNDS) Return False;
		If (Target == Self || !KAI_CheckMissileRange(Target,CMR_INVERTDIST) || IsDead (Target) || !IsActorHostile (Target)) Return False;
		
		Int Threat = AssessThreatLevel (Target);
		
		//If the cannon is busy loading, use the coaxial instead.
		If (ReloadTime)
		{
			MaxTargetRange = 8192; //Lower the range for the coaxial.
			CoaxialShots = Random (1,2)*10;
			If (Distance3DSquared (Target) < MaxTargetRange*MaxTargetRange && KAI_TurretCheckLOF (Target,150,0,(0,-10,20)))
				If (!NoStateJump) SetStateLabel ("Fire.Coaxial");
			MaxTargetRange = Default.MaxTargetRange;
			Return True;
		}
		
		//Fire, the shell type to use should be decided in Tick() by DecideAmmoType().
		If (!ReloadTime)
		{
			//Try targeting a stronger enemy.
			Actor OldTarg = Target;
			A_FindStrongEnemy (Target, Target, 1024);
			If (Random (0,255) < 192)
				Target = OldTarg;
			
			If (!NoStateJump) SetStateLabel ("Fire");
		}
		
		Return False;
	}
	
	//Fire a ray from the direction the turret is facing and return a position to where the ray stopped, which should also be where the projectile with hit.
	Override Vector3 GetAttackLocation ()
	{
		Let Check = New ("MVP_GenericWarnMarineCheck");
		
		Vector3 Direction;
		If (!InFlight)
			Direction = (AngleToVector(Angle, Cos(Pitch)), -Sin(Pitch));
		Else
			Direction = (0,0,-1); //Aim warning straight down.
		Vector3 StartPos;
		If (!InFlight)
			StartPos = Level.Vec3Offset (Pos,(0,0,14));
		Else
			StartPos = Pos;
		If (!InFlight) Check.Shooter = Self;
		If (!InFlight) Check.Other = Target;
		Check.Trace (StartPos , CurSector, Direction, MaxTargetRange, 0 );
		
		Return Check.Results.HitPos;
	}
	
	Override Void Tick()
	{
		If (IsFrozen()) Return;
		
		//Reverse the direction of the turret when retreating, calling this before Super.Tick() makes the transition seamless.
		If (!IsDead (Self) && Master && Master Is "MVP_MBT")
			TurretRotationOffset = MVP_MBT(Master).Retreating ? -180 : 0;
		
		Super.Tick();
		
		If (WarningZone) WarningZone.SetOrigin (GetAttackLocation(),True); //Track warn zone to aim direction.
		
		If (!IsDead (Self)) //No reason to run these if we are dead.
		{
			//Decide an attack type every half a second.
			If (ReadyToDecide && GetAge() % GameTicRate/2 == 0)
			{
				ShellType = DecideAmmoType();
				//NOTE: I may add HESH in the future, so this will need changing. Like making it so if the code above decides to use it, this check is ignored.
				If (/*ShellType != TYPE_HESH && */Target && !CheckSight (Target,SF_IGNOREWATERBOUNDARY))
					ReadyToDecide = False; //You can no longer see the target, so you cannot fire at them.
			}
		
			If (--APSCooldown <= 0 && APSDelay > 1 || APSDelay == 1)
				RunTrophyAPS();
			
			If (--AltAPSCooldown <= 0 && AltAPSDelay > 1 || AltAPSDelay == 1)
				RunShtoraAPS();
			
			If (ReloadTime)
				ReloadTime--;
		}
			
		//console.printf ("reload time %d",reloadtime);
	}
	
	Const TrophyRange = 640;
	Const ShtoraRange = 1024;
	
	Void RunTrophyAPS()
	{
		Array <Actor> Incoming; //Detectable incoming projectiles found.
		ForEach (Proj : KAIHandler.ProjectileList)
		{
			If (!Proj || Proj.Target == Self || !Proj.bMissile) //Null, one of our own, or not a missile anymore. (AKA it was blown up, but not out of the list yet)
				Continue;
			
			//If the projectile is faster than the threshold. Then begin raising the chance of a failed shootdown for each bit of excess velocity.
			//This also allows to smooth out the speed cap. Instead of shooting down a speed 200 missile all the time, and a speed 201 one none of the time.
			If (Proj.Vel.Length() > 200)
			{
				Double ExcessVel = Proj.Vel.Length() - 200;
				If (Random (0, 255) < ExcessVel*2)
					Continue;
			}
			
			If (!IsActorHostile(Proj.Target)) //Ignore friendly projectiles.
				Continue;
			
			//If (Proj.bSeekerMissile && Proj.Tracer && Proj.Tracer Is "MVP_SeekerDecoy") //Homing projectile that was tricked by the IR dazzler.
			//	Continue;
			
			If (Distance3DSquared(Proj) > TrophyRange*TrophyRange) //Too far
				Continue;
			
			//Credit: RaveYard
			//Is the projectile actually coming at the tank ?
			Bool IncomingProjectile = (Vec3To(Proj).Unit() Dot Proj.Vel.Unit()) < -0.15;
			Double SafeRadius = Sqrt(2 * ((Proj.Radius + Radius) ** 2.2));
			If(!(IncomingProjectile && KAI_Math.Distance3DLine(Pos, Proj.Pos, Proj.Pos + Proj.Vel) < SafeRadius))
				Continue;
			
			If (!CheckSight (Proj,SF_IGNOREWATERBOUNDARY)) //Out of sight, out of mind.
				Continue;
			
			Incoming.Push(Proj);
		}
		
		//Now, let's find the strongest projectile.
		Int HighestDamage;
		Actor StrongestProjectile;
		ForEach (Proj : Incoming)
		{
			Double Dmg = Proj.GetMissileDamage(1, 7);
			If (Dmg > HighestDamage)
			{
				HighestDamage = Dmg;
				StrongestProjectile = Proj;
			}
		}
		
		APSPopMissile (StrongestProjectile);
	}
	
	Void APSPopMissile (Actor Who)
	{
		If (!Who)
			Return;
		//The evil has been defeated.
		If (Master Is "MVP_MBT") APSDelay = MVP_MBT(Master).User_APSDelay; //Update the delay, in case it changed on the MBT dynamically.
		Actor Twinkle = Spawn ("MVP_Spark",Who.Pos);
		Twinkle.A_StopAllSounds(); //Doesn't work lol.
		Twinkle.A_SetScale (FRandom(0.3, 0.5));
		If (Who Is "MVP_APFSDSShell") //If you happened to catch a dart, and also won the lottery probably. Then shatter it.
			MVP_APFSDSShell(Who).Shatter = True;
		Who.ExplodeMissile();
		A_StartSound ("Vehicle/Tank/APSRun",CHAN_VOICE,CHANF_OVERLAP,attenuation:0.8);
		APSCoolDown = APSDelay;
	}
	
	Void RunShtoraAPS()
	{
		Bool FoundSomething;
		ForEach (Proj : KAIHandler.ProjectileList)
		{
			If (!Proj || Proj.Target == Self || !Proj.bMissile) //Null, one of our own, or not a missile anymore. (AKA it was blown up, but not out of the list yet)
				Continue;
			
			If (!Proj.bSeekerMissile || Proj.Tracer && Proj.Tracer Is "MVP_SeekerDecoy") //Not a homing projectile. Or has already been duped.
				Continue;
			
			If (!CheckFOV (Proj,45) || AbsAngle (PitchTo(Proj),Pitch) > 45) //Out of the field of view.
				Continue;
			
			If (!IsActorHostile(Proj.Target)) //Ignore friendly projectiles.
				Continue;
			
			If (Distance3DSquared(Proj) > ShtoraRange*ShtoraRange) //Too far
				Continue;
			
			If (!CheckSight (Proj,SF_IGNOREWATERBOUNDARY)) //Out of sight, out of mind.
				Continue;
			
			Vector3 DecoyPos = Proj.Vec3Angle (256,Proj.Angle+RandomPick(45,-45));
			DecoyPos = Level.Vec3Offset (DecoyPos,(FRandom(128,-128),FRandom(128,-128),FRandom(128,-128)));
			Actor Decoy = Spawn ("MVP_SeekerDecoy",DecoyPos); //The fake track target for the seekers.
			Decoy.Angle = Random (0,360);
			Decoy.Pitch = Random (90,-90);
			Decoy.Speed = Random (4,16);
			Decoy.Master = Proj; //Parent decoy to projectile.
			Actor Twinkle = Spawn ("MVP_Spark",Proj.Pos);
			Twinkle.A_StopAllSounds();
			Twinkle.A_SetScale (FRandom(0.2, 0.35));
			Proj.Tracer = Decoy;
			FoundSomething = True;
		}
		If (FoundSomething)
		{
			A_StartSound ("Vehicle/Tank/AltAPSRun",CHAN_VOICE,CHANF_OVERLAP,attenuation:0.7);
			AltAPSCoolDown = AltAPSDelay;
		}
	}
	
	//Finds a strong enemy around the origin, and sets it as the turrets' target, so that the APFSDS round can destroy it.
	Bool A_FindStrongEnemy (Actor Avoid, Actor Origin, Double CheckRange)
	{
		If (!Avoid || !CheckRange || !Origin) Return False;
		
		Array <Actor> TargetList;
		
		BlockThingsIterator EnemyFinder = BlockThingsIterator.Create (Origin,CheckRange);
		
		CheckRange *= CheckRange; //Do the multiplication for Distance3DSquared only once.
		
		While (EnemyFinder.Next())
		{
			Actor Mobj = EnemyFinder.Thing;
			
			If (!Mobj || Mobj == Avoid) Continue; //AVOID THIS TARGET.
			
			If (Mobj.bDormant || IsInanimateObject (Mobj)) Continue; //Don't attack dormant or inanimate object actors.
			
			If (AssessThreatLevel (Mobj) < ThreatLevelThreshold) Continue; //Not strong enough to target.
			
			If (!CanBeTargeted(Self, Mobj)) Continue; //Can't be targeted. (Duh)
			
			If (IsDead (Mobj)) Continue; //Is dead (Duuuuuuuuuuh)
			
			If (Origin.Distance3DSquared(Mobj) > CheckRange) Continue; //Too out of reach.
			
			If (!IsActorHostile (Mobj)) Continue; //Actor isn't hostile.
			
			If (!CheckSight(Mobj)) Continue; //Actor is not visible.
			Target = Mobj;
			Return True;
		}
		Return False;
	}
	
	//Finds the nearest visible enemy vehicle.
	Actor A_FindEnemyVehicle()
	{
		Let VehFind = ThinkerIterator.Create ("KAI_BaseVehicle");
		Actor Mobj;
		While (Mobj = Actor(VehFind.Next()))
		{
			If (Mobj.bDormant || IsInanimateObject (Mobj)) Continue; //Don't attack dormant or inanimate object actors.
			
			If (AssessThreatLevel (Mobj) < THREAT_ABOVENORMAL) Continue; //Not strong enough to target.
			
			If (!CanBeTargeted(Self, Mobj)) Continue; //Can't be targeted. (Duh)
			
			If (IsDead (Mobj)) Continue; //Is dead (Duuuuuuuuuuh)
			
			If (!IsActorHostile (Mobj)) Continue; //Actor isn't hostile.
			
			If (!CheckSight(Mobj)) Continue; //Actor is not visible.
			
			Return Mobj;
		}
		Return Null;
	}
	
	//The generic projectile check does have ripper checks, but whatever, this will do for a million dollar lawn dart that goes through everything.
	Bool A_CheckAPFSDSLOF()
	{
		If (!CheckSight(Target)) Return False;
		Array <Actor> Targ;
		KAI_FindInLOF (FIL_FACETARGET|FIL_MISSILEHIT,MaxTargetRange,32,(0,0,16),Target,Targ);
		For (Int I = Targ.Size()-1; I >= 0; I--)
			If (Targ[I] == Target)
				Return True;
		Return False;
	}
	
	//Decide and return what ammunition type to use for the tank. And also change the target prediction speeds appropriately.
	Int DecideAmmoType()
	{
		If (!Target) Return ShellType;
		Int Threat = AssessThreatLevel (Target);
		
		//High chance that if your target is strong or a strong enemy is near it, the tank will fire the APFSDS shell.
		If (Random (0,255) < 200 && (Threat >= ThreatLevelThreshold || A_FindStrongEnemy (Target, Target, 1024)) && A_CheckAPFSDSLOF())
		{
			//Very small chance to fire a missile instead of a HEAT shell.
			If (Random (0,255) < 4)
			{
				TurretAttackSpeed = GetDefaultByType("MVP_ATGM").Speed; FastTurretAttackSpeed = GetDefaultByType("MVP_ATGM").FastSpeed;
				Return TYPE_ATGM;
			}
			TurretAttackSpeed = GetDefaultByType("MVP_APFSDSShell").Speed; FastTurretAttackSpeed = GetDefaultByType("MVP_APFSDSShell").FastSpeed;
			Return TYPE_APFSDS;
		}
		
		Int AOEChance = Random (0,20); //Introduce some RNG to how likely the tank is to fire an explosive round.
		
		Double LOFHeight = 16-(GetDefaultByType("MVP_HEATShell").Height);
		//Fire a guided missile at crowds of enemies, or monsters that fit these conditions:
		Bool FastBoi = (Target.Speed >= 50); //Too fast, and likely unpredictable, to hit with a shell.
		Bool FastDistantBoi = (Target.Speed >= 25 && Distance3DSquared(Target) > 8192*8192); //Same, but for less fast enemies, that are still very far.
		Bool Is3ZipcodesAway = (Distance3DSquared(Target) > 14000*14000); //Even the smallest movement would cause a shell to miss.
		If ((Random (0,255) < 64 || FastBoi || FastDistantBoi || Is3ZipcodesAway) && (Threat > THREAT_MILD || AttackByQuantity (Target, 512) >= 200-AOEChance)
		&& KAI_TurretCheckLOF (Target,0,512,(0,0,LOFHeight)))
		{
			TurretAttackSpeed = GetDefaultByType("MVP_ATGM").Speed; FastTurretAttackSpeed = GetDefaultByType("MVP_ATGM").FastSpeed;
			Return TYPE_ATGM;
		}
		
		//If your enemy isn't ridiculously weak, or there's enough enemies around it to justify it, then fire the HEAT shell.
		If ((Threat > THREAT_NORMAL || AttackByQuantity (Target, 512) >= 250-AOEChance || Random(0,255) < 6) && KAI_TurretCheckLOF (Target,0,512,(0,0,LOFHeight),TLOF_OnlyAhead))
		{
			//Small chance to fire a missile instead of a HEAT shell.
			If (Random (0,255) < 6)
			{
				TurretAttackSpeed = GetDefaultByType("MVP_ATGM").Speed; FastTurretAttackSpeed = GetDefaultByType("MVP_ATGM").FastSpeed;
				Return TYPE_ATGM;
			}
			TurretAttackSpeed = GetDefaultByType("MVP_HEATShell").Speed; FastTurretAttackSpeed = GetDefaultByType("MVP_HEATShell").FastSpeed;
			Return TYPE_HEAT;
		}
		//Otherwise get the coaxial gun to fire a few shots at it.
		Else
		{
			MaxTargetRange = 8192; //Lower the range for the coaxial.
			If (KAI_CheckMissileRange(Target,CMR_INVERTDIST) && KAI_TurretCheckLOF (Target,150,0,(0,-10,20)))
			{
				TurretAttackSpeed = GetDefaultByType("MVP_RifleBullet").Speed; FastTurretAttackSpeed = GetDefaultByType("MVP_RifleBullet").FastSpeed;
				CoaxialShots = Random (2,4)*10;
				MaxTargetRange = Default.MaxTargetRange; //Reset the max range to normal.
				Return TYPE_NONE;
			}
		}
		MaxTargetRange = Default.MaxTargetRange;
		TurretAttackSpeed = Default.TurretAttackSpeed; //When falling back to HEAT, use the default speeds, since they are for heat.
		FastTurretAttackSpeed = Default.FastTurretAttackSpeed;

		Return TYPE_HEAT;
	}
	
	Enum AmmoTypes
	{
		TYPE_NONE	= 0, //Special none type. If ShellType is this, then it likely means that the tank should use the coax gun.
		TYPE_HEAT 	= 1, //Standard ammo type, used for weak (Relatively) enemies, groups, etc.
		TYPE_APFSDS	= 2, //Ripper that does a shitton of damage. Used for powerful enemies, like Cyberdemons and players with god/buddha mode 1.
		TYPE_ATGM	= 3, //Homing missiles, have a chance to be fired at powerful enemies, and distant and/or fast enemies.
		//TYPE_HESH	= 4, //Slowest shell. Can be fired at enemies behind thin walls/void spaces, which it sticks on, to harm them with shrapnel on the other side.
	}
	
	Void A_TankFire (Int Type = TYPE_HEAT)
	{
		Double Vol = (Type == TYPE_ATGM) ? 0.5 : 1.0; //Quiet the firing sound when firing guided missiles.
		A_StartSound (AttackSound,CHAN_WEAPON,CHANF_OVERLAP,Vol,0.1);
		
		//Normal high explosive shell. The stock exploding projectiles tanks usually fire in media.
		If (Type == TYPE_HEAT)
			A_SpawnProjectile ("MVP_HEATShell",16,flags:CMF_AIMDIRECTION,Pitch);
		//Depleted uranium dart, useful for individual powerful enemies like bosses and cheaters. Not affected by stealth.
		Else If (Type == TYPE_APFSDS)
		{
			Bool Flag = bSeeInvisible;
			bSeeInvisible = True;
			A_SpawnProjectile ("MVP_APFSDSShell",16,flags:CMF_AIMDIRECTION,Pitch);
			bSeeInvisible = Flag;
		}
		//Gun launched homing missile. For fast and/or distant targets.
		Else If (Type == TYPE_ATGM)
		{
			Actor Missile = A_SpawnProjectile ("MVP_ATGM",16,flags:CMF_AIMDIRECTION,Pitch);
			Missile.Tracer = Target; //A_SpawnProjectile doesn't do this on its' own, even thought it SHOULD.
		}
		GunLoaded = False;
		
		Vector3 FXPos = (224,0,0);
		Vector3 BorePos = (188,0,0);
		//The closer the tank fires to the ground, the more smoke and dust it kicks up.
		Switch (Frame)
		{
			Case 14: //Aiming up (very).
				SmokeCounter = 0;
				FXPos.Z = 64;
				BorePos.X -= 6;
				BorePos.Z = 48;
				Break;
			Case 11: //Aiming up.
				SmokeCounter = 8;
				FXPos.Z = 40;
				BorePos.X -= 16;
				BorePos.Z = 32;
				Break;
			Case 8: //Aiming ahead.
				SmokeCounter = 16;
				FXPos.Z = 16;
				BorePos.Z = 24;
				Break;
			Case 17: //Aiming down.
				SmokeCounter = 32;
				FXPos.Z = -16;
				BorePos.X -= 8;
				BorePos.Z = -6;
				Break;
			Default:
				SmokeCounter = 32; //Default ground smoke and dust amount.
				FXPos.Z = 16;
				BorePos.Z = 24;
				Break;
		}
		
		If (Type != TYPE_ATGM) //The gun launched missile has no firing effect, it's just spat out the barrel like a grenade, since it's self propelled.
		{
			//Firing effect.
			Int Trash; Double SpriteAngle = GetNearestCardinalAngle (True)-180;
			Actor FX;
			[Trash, FX] = A_SpawnItemEx ("MVP_MBTFireEffect",FXPos.X,FXPos.Y,FXPos.Z,angle:SpriteAngle,SXF_ABSOLUTEANGLE);
			FX.bAlwaysPuff = False; //Spawn our own, smaller shockwave ring. Or maybe none at all.
			FX.Scale *= 0.75;
			FX.Target = Self; //So enemies caught in the firing blast know who to blame.
			
			//Dust control.
			FX.RadiusDamageFactor = 0.5; //How much dust is not spawned, based on height off the ground.
			FX.ReactionTime = 88; //Extra dusty.
			FX.Threshold = 196; //Dust spawn radius.
			
			//Bore evacuator smoke.
			For (Int I = 0; I < 16; I++)
			{
				//Vector3 SpawnPos = Vec3Offset (BorePos.X,BorePos.Y,BorePos.Z);
				Quat Dir = Quat.FromAngles (SpriteAngle,0,0);
				Vector3 SpawnPos = Level.Vec3Offset (Pos,Dir * BorePos);
				FX = Spawn ("MVP_DamageSmoke",Level.Vec3Offset (SpawnPos,(FRandom (6,-6),FRandom (6,-6),0)));
				FX.Scale *= FRandom (0.35,0.55);
				FX.Roll = FRandom(-180,180);
				FX.Vel.X = FRandom (2,-2);
				FX.Vel.Y = FRandom (2,-2);
				FX.Vel.Z = FRandom (1,2);
			}
		}
	}
	
	Actor WarningZone; //After the tank is finished, the marines' crude warning system will be turned into a generic hazard system for the library.
	Actor PreFireZone; //Warning zone spawned in the 2 second space before the tank fires.
	Int ShellType; //What the turret will fire.
	Bool ReadyToDecide; //Tells the turret to decide what shell to fire during the 2 second firing delay.
	Int ReloadTime; //How long until the turret is ready to fire.
	Int CoaxialShots; //How many shots to fire in the coaxial state before stopping.
	Bool MetalCoffin; //T-72 mode
	Bool GunLoaded; //Stop spamming the load sound.
	
	Int APSCooldown; //Cooldown on the Trophy-like system that actively shoots incoming projectiles down.
	Int AltAPSCooldown; //Cooldown for the Shtora-1 system that throws off homing projectiles in front of it by making them follow wandering points.
	Int APSDelay; //The tick delay to set to the APS before it can search and shoot down projectiles again.
	Int AltAPSDelay; //Same, but for the alt APS.
	
	States
	{
		Spawn:
			MMBT G 0;
			MMBT # 1
			{
				RotateToVehicle(RTVF_ADDANGLE);
				KAI_Look (maxseedist:MaxTargetRange,8196,120,extraflags:KAIL_CHASETARGET);
				Frame = UpdateTankElevation (15,6,9,12); //P, G, J, M
			}
			Loop;
		See:
			MMBT # 1
			{
				DoCombatTraverse();
				RotateToVehicle();
				KAI_LandVehicleChase (LVC_NOTURRETRETARGET,chaseflags:CHF_DONTIDLE|CHF_DONTMOVE);
				RetargetVehicleHull (RVHF_STRONGERHULL); //Target the enemy vehicles' hull if it is healthier than the turret. Especially useful for APFSDS.
				UpdateTurretSnapTimer();

				Frame = UpdateTankElevation (15,6,9,12); //P, G, J, M
			}
			Loop;
		//Firing the cannon.
		Fire:
			MMBT # 0 A_JumpIf (ReloadTime > 0,"See");
			//The calm before the storm.
			MMBT # 0
			{
				If (!GunLoaded)
				{
					A_StartSound ("Vehicle/Tank/Reload",CHAN_WEAPON,attenuation:0.7);
					GunLoaded = True;
				}
				ReadyToDecide = True; //Start deciding what to shoot in the last 2 seconds before firing.
				If (WarningZone) WarningZone.MaxTargetRange = 512; //Set the range of the marine warn zone to the HEAT shells' blast radius.
				DecideAmmoType();
				If (!(Target Is "KAI_BaseVehicle"))
				{
					Actor New = A_FindEnemyVehicle();
					If (New) Target = New;
				}
				PreFireZone = WarnMarines (range:256,Self,(224,0,0));
			}
			MMBT ###################################################################### 1
			{
				//Decided to not fire because there is no line of sight to the target anymore.
				If (!ReadyToDecide)
				{
					If (PreFireZone) PreFireZone.Destroy();
					If (WarningZone) WarningZone.MaxTargetRange = 48;
					TurretAttackSpeed = GetDefaultByType("MVP_RifleBullet").Speed; FastTurretAttackSpeed = GetDefaultByType("MVP_RifleBullet").FastSpeed;
					Return FindState ("See");
				}
				DoCombatTraverse(); //Soon
				Frame = UpdateTankElevation (15,6,9,12); //P, G, J, M
				Return State (Null);
			}
			MMBT # 0
			{
				If (PreFireZone) PreFireZone.Destroy();
				If (ShellType == TYPE_NONE)
				{
					If (WarningZone) WarningZone.MaxTargetRange = 48;
					TurretAttackSpeed = GetDefaultByType("MVP_RifleBullet").Speed; FastTurretAttackSpeed = GetDefaultByType("MVP_RifleBullet").FastSpeed;
					Return FindState ("Fire.Coaxial");
				}
				Return State (Null);
			}
			//Perish
			MMBT # 2
			{
				ReadyToDecide = False;
				Frame = UpdateTankElevation (17,8,11,14); //R, I, L, O
				A_TankFire (ShellType); //This is where the magic happens.
				
				//Revert to the coaxial until next load.
				If (WarningZone) WarningZone.MaxTargetRange = 48;
				ShellType = TYPE_NONE;
				TurretAttackSpeed = GetDefaultByType("MVP_RifleBullet").Speed; FastTurretAttackSpeed = GetDefaultByType("MVP_RifleBullet").FastSpeed;
			}
			MMBT ## 2 {Frame = UpdateTankElevation (17,8,11,14);} //R, I, L, O
			MMBT ## 2 {Frame = UpdateTankElevation (15,6,9,12);} //P, G, J, M
			MMBT # 8
			{
				ReloadTime = 5*GameTicRate;
				Frame = UpdateTankElevation (15,6,9,12); //P, G, J, M
			}
			Goto See;
		//Firing the coaxial gun.
		Fire.Coaxial:
			//MMBT # 0 A_JumpIf (CoaxialDelay,"See");
			MMBT # 2 Light ("CoaxialFiringLight") //Firing state.
			{
				Actor Proj = A_SpawnProjectile ("MVP_RifleBullet",20,-10,flags:CMF_AIMDIRECTION,Pitch);
				AddProjectileSpread (Proj,(0.4,-0.4),(0.55,-0.55));
				A_StartSound ("Vehicle/Tank/CoaxialFire",CHAN_WEAPON,CHANF_OVERLAP,1.0,0.4);
				Frame = UpdateTankElevation (16,7,10,13); //Q, H, K, N
			}
			MMBT ### 1 //Refiring state
			{
				//Quick retarget attempt.
				If (!Target || IsDead (Target))
				{
					A_ClearTarget();
					LookForPlayers (True); //Look for a new target.
				}
				//console.printf ("coaxial obligations %d",coaxialshots);
				//The gun is loaded, and you are no longer forced to fire the coaxial at some weakling.
				If (!ReloadTime && CoaxialShots <= 0)
				{
					Return ResolveState ("ExitCoaxial");
				}
				
				//Recycled logic from the APCs' small autocannon MG, since the coaxial gun is the same thing, but part of the tank turret itself.
				If (Random2[pr_monsterrefire]() < 128 &&
				((Target && IsOverPitchLimits (Target,8,Target.Height/2) != ELEVATION_INBOUNDS) ||
				!KAI_TurretCheckLOF (Target,150,0,(0,-10,20))))
				{
					//A_ClearTarget();
					Return ResolveState ("ExitCoaxial");
				}
				
				HandleChaseTimer();
				
				KAI_TurretRefire (128,"ExitCoaxial",True,4,fov:120);
				If (CoaxialShots > 0)
				{
					//Finish firing the coaxial if forced to fast when the current target is dangerous.
					If (AssessThreatLevel (Target) < THREAT_DANGEROUS)
						CoaxialShots--;
					Else
						CoaxialShots -= 3;
				}
				
				Frame = UpdateTankElevation (15,6,9,12); //P, G, J, M
				Return State (Null);
			}
			Loop;
		ExitCoaxial:
			TNT1 A 0 {CoaxialShots = 0;}
			Goto See;
		Death:
			MBTD C 1 A_JumpIf (MetalCoffin,"FlyingDeath");
			MBTD C 1
			{
				Actor Boom = Spawn ("MVP_Explosion",Vec3Angle (96,GetNearestCardinalAngle(True)).PlusZ(Height/2));
				Boom.Scale *= 2.5;
				Boom.SetDamage (300);
				Boom.MaxTargetRange = 384;
				Boom.MeleeRange = 96;
				Boom.bNoGravity = True;
				Boom.bGetOwner = True; //So the dead tank is considered the source.
				Boom.Target = Self;
			}
			MBTD CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC 1 RotateToVehicle (RTVF_NOTARGETCHECK); //Wait for it.
			MBTD C 0 A_StartSound ("Vehicle/ArmyTruck/BackOpen",flags:CHANF_OVERLAP,attenuation:0.75);
			MBTD DDDDDDDDEEEEEEEE 1 RotateToVehicle (RTVF_NOTARGETCHECK);
			MBTD E Random (4,8) A_StartSound ("Vehicle/ArmyTruck/BackSlam",flags:CHANF_OVERLAP,attenuation:0.8);
			MBTD E 3 //Gunner and commandeder escape.
			{
				SpawnFleeingCrew ((0,32,34),2,-8,FRandom (4,6));
				SpawnFleeingCrew ((0,-24,34),-2,8,FRandom (4,6));
			}
			MBTD E Random (8,16);
			MBTD E 1 SpawnFleeingCrew ((0,-24,34),-2,8,FRandom (4,6)); //Driver escapes, yes out of the turret because I'm not going to make any more hull sprites for the drivers' hatch opening.
			MBTD E 1 RotateToVehicle (RTVF_NOTARGETCHECK);
			Wait;
		FlyingDeath: //Soviet engineering
			#### # 1
			{
				If (Turret) Turret.Destroy(); //Remove RWS
				InFlight = True;
				WarningZone = WarnMarines (MWRN_ALLIESTOO,Radius*4,Self); //Create a new warning zone after the old one is erased due to the tank dying, to warn marines below.
				Actor Boom = Spawn ("MVP_Explosion",Pos);
				Boom.Scale *= 1.5;
				Boom.SetDamage (384);
				Boom.MaxTargetRange = 512;
				Boom.MeleeRange = 128;
				Boom.bNoGravity = True;
				Boom.bGetOwner = True; //So the dead tank is considered the source.
				Boom.Target = Self;
				
				SetOrigin (Pos.PlusZ(Height+8),True);
				bFallOnDeath = True;
				Vel.Z = TossVelocity = FRandom (32,56);
				Double XVel = FRandom (-2,8); Double YVel = FRandom (8,16);
				Vel.X = XVel * Cos (Angle) + YVel * Sin (Angle);
				Vel.Y = XVel * Sin (Angle) - YVel * Cos (Angle);
			}
			//Update animation based on vertical velocity.
			MBTD S 1 A_JumpIf ((Vel.Z <= TossVelocity/1.5),1);
			Wait;
			MBTD T 1 A_JumpIf ((Vel.Z <= TossVelocity/2),1);
			Wait;
		FlyingDeath.Landing:
			MBTD U 1 A_JumpIf ((bOnMobj || (FloorZ >= Pos.Z) || (CeilingZ <= Pos.Z+Height)),1); //Hit the floor, ceiling, or an actor.
			Wait;
			MBTD V 1
			{
				InFlight = False;
				If (WarningZone) WarningZone.Destroy();
				A_StartSound ("SFX/MetalCrash",attenuation:0.4);
				A_Explode (800,Radius*1.5,XF_EXPLICITDAMAGETYPE|XF_NOTMISSILE,True,Radius*1.5,damagetype:'Crush');
				A_QuakeEx (1,1,1,GameTicRate*2,0,768,"",QF_SCALEDOWN|QF_GROUNDONLY,falloff:64,rollintensity:0.5);
				Actor Dusty = Spawn ("MVP_GroundDustSpawner",Pos.PlusZ(Height/2));
				Dusty.RadiusDamageFactor = 0.9;
				Dusty.ReactionTime = 128;
				Dusty.Threshold = 256;
			}
			MBTD V 2 A_JumpIf (Abs(Vel.Z) >= 24,"FlyingDeath.Restart"); //We are in vertical motion again.
			Wait;
		FlyingDeath.Restart:
			TNT1 A 0
			{
				InFlight = True;
				WarningZone = WarnMarines (MWRN_ALLIESTOO,Radius*4,Self); //Create a new warning zone after the old one is erased due to the tank dying, to warn marines below.
			}
			Goto FlyingDeath.Landing;
		//Whole turret vanishes if the tank was hit by something strong enough to gib it.
		XDeath:
			TNT1 A 1 A_JumpIf ((MetalCoffin || Random(0,255) < 72),"FlyingDeath");
			Stop;
	}
	
	Double TossVelocity;
	Bool InFlight;
	
	Mixin MVP_MBTTurret_SmokeHandling;
	
	//FIXME: For some reason when marines are spawned by the turret, they always face at 0, ignoring the SpawnMarine angle change, or any angle change.
	Void SpawnFleeingCrew (Vector3 PosOfs = (0,0,0), Double XVel = 0, Double YVel = 0, Double ZVel = 0)
	{
		Actor Marine; //Gunner comes out the left hatch.
		Marine = SpawnMarine (PosOfs);
		Marine.DamageMobj (Target,Target,Random (16,48),DeathType,DMG_NO_PAIN|DMG_THRUSTLESS); //Harm the marine by a random amount, the source being the MBT's killer.
		//SpawnItemEx velocity code.
		Marine.Vel.X = XVel * Cos (Angle) + YVel * Sin (Angle);
		Marine.Vel.Y = XVel * Sin (Angle) - YVel * Cos (Angle);
		Marine.Vel.Z = ZVel;
		
		If (CustomMarinesAvailable())
		{
			Let Token = Marine.GiveInventoryType ("MVP_MarineLandWarning");
			Token.Master = Self; //To make the marines run away from the tank once they land.
		}
	}
}

Class MVP_MBTRWS : MVP_BaseTurret
{
	Default
	{
		Health 200;
		Radius 16;
		Height 16;
		DeathHeight 16;
		XScale 0.5; //The remote weapon stations are rendered at double the resolution of the rest of the tank hull and turret, for extra detail.
		YScale 0.416666;
		Mass 50;
		FriendlySeeBlocks 64;
		MaxTargetRange 8192;
		KAI_BaseTurret.MaximumPitch -35;
		KAI_BaseTurret.MinimumPitch 15;
		KAI_BaseTurret.TurnSoundRadius 1.5;
		KAI_BaseTurret.AttackSpeed 230;
		KAI_BaseTurret.FastAttackSpeed 250;
		KAI_BaseTurret.CombatAngleTurnRate 50;
		KAI_BaseTurret.CombatPitchTurnRate 37;
		KAI_Actor.ThreatLevel THREAT_ABOVENORMAL;
		AttackSound "Vehicle/APC/MGFire";
		Tag "M20 Remote Weapon Station";
		Obituary "%o was gunned down by a tanks' remote weapon station";
		DamageFactor "Autocannon", 0.95;
		DamageFactor "Melee", 0.4;
		DamageFactor "Electric", 0.4;
		DamageFactor "ExplosiveImpact", 0.825;
		DamageFactor "Explosion", 0.825;
		DamageFactor "HitScan", 0.9;
		+MissileMore;
		+MissileEvenMore;
	}
	
	Int UpdateRWSElevation (Int FaceDown, Int FaceStraight, Int FaceUp, Int FaceUp2)
	{
		If (Pitch >= 8 && Pitch >= 0)
			Return FaceDown;
		Else If (Pitch < 8 && Pitch >= -17.5)
			Return FaceStraight;
		Else If (Pitch < -17.5 && Pitch >= -25)
			Return FaceUp;
		Else If (Pitch <= -25)
			Return FaceUp2;
		
		Return FaceStraight;
	}
	
	Bool FocusFire; //Makes the MG not actively avoid sharing the same target as the turret, even if the shared target isn't a powerful enemy.
	//ULTRA HIGH DEFINITION QUALITY DOLBY ATMOS RIPS.
	Const RWSAttackHeight = 12;
	Array <Actor> HitActors;
	
	Override Bool ShouldAttack (Bool NoStateJump)
	{
		If (!KAI_BaseTurret.ShouldAttack()) Return False;
		If (Target && !CheckFOV (Target,90/2)) Return False; //KLUDGE: We need to do the null check here, because as of GZDoom 4.10, it's not done internally. Crashing the game.
		If (IsOverPitchLimits (Target,RWSAttackHeight,Target.Height/2) != ELEVATION_INBOUNDS) Return False;
		
		If (Target != Self && KAI_CheckMissileRange(Target) && !IsDead (Target) && IsActorHostile (Target) && KAI_TurretCheckLOF (Target,0,0,(0,-8,12),0,"MVP_50CalBullet"))
		{
			If (!NoStateJump) SetStateLabel ("Fire");
			Return True;
		}
		
		Return False;
	}
	
	MVP_APCMachineGunLOFCheck MarineWarner; //A permanent pointer to a MG LOF check tracer. So that it can be fired when the turret is firing to warn marines.
	Override Void Tick()
	{
		Super.Tick();
		
		If (IsFrozen()) Return;
		//When shooting, fire a ray that alerts any marines that would be caught in the line of fire.
		If (IsInAttackState())
		{
			Vector3 Direction = (AngleToVector(Angle, Cos(Pitch)), -Sin(Pitch));
			
			Double Distance = Target ? Distance3D (Target)+32 : MaxTargetRange;
			MarineWarner.Shooter = Self;
			MarineWarner.Other = Target;
			MarineWarner.OnlyFindActors = True;
			MarineWarner.Trace ((Pos.X,Pos.Y,Pos.Z+RWSAttackHeight),CurSector,Direction,Distance,0);
			HitActors.Move(MarineWarner.Mobjs);
			//Check all the actors the trace hit.
			Name TheMarine = "SmartMarine";
			ForEach (Mobj : HitActors)
				If (Mobj && !IsDead (Mobj) && Mobj Is TheMarine && IsHostile(Mobj))
					WarnSpecificMarine(Mobj); //Then warn them.
			HitActors.Clear();
		}
	}
	
	Override Void Die (Actor Source, Actor Inflictor, Int DmgFlags, Name MeansOfDeath)
	{
		Super.Die (Source, Inflictor, DmgFlags, MeansOfDeath);
		If (MarineWarner) MarineWarner.Destroy();
		If (Master) Master.SetTag (Master.Default.GetTag());
	}
	
	Override Void OnDestroy()
	{
		If (Master) Master.SetTag (Master.Default.GetTag());
		If (MarineWarner) MarineWarner.Destroy();
		Super.OnDestroy();
	}
	//====================================================
	
	Override Void PostBeginPlay ()
	{
		Super.PostBeginPlay();
		
		MissileState = FindState ("Fire");
		AttackStates.Push (FindState("Fire",True));
		MarineWarner = New ("MVP_APCMachineGunLOFCheck"); //Create the warning trace for marines.
	}
	
	States
	{
		Spawn:
			MMBT S 0;
			MMBT # 1
			{
				RotateToVehicle();
				KAI_Look (maxseedist:MaxTargetRange,DEFAULT_HEARDISTANCE,extraflags:KAIL_CHASETARGET);
				Frame = UpdateRWSElevation (24,18,20,22); //Y, S, U, W
			}
			Wait;
		See:
			MMBT # 1;
			MMBT # 1
			{
				DoCombatTraverse();
				RotateToVehicle();
				MoveToParams Params;
				Params.RunRad = 256;
				Params.DetourFactor = 1.0;
				Params.Attempts = 32;
				Params.StepThreshold = 32;
				KAI_LandVehicleChase (chaseflags:CHF_DONTIDLE|CHF_DONTMOVE,moveparams:params);
				UpdateTurretSnapTimer();
				Frame = UpdateRWSElevation (24,18,20,22); //Y, S, U, W
			}
			Loop;
		Fire:
			MMBT ## 1 {Frame = UpdateRWSElevation (24,18,20,22); /*Y, S, U, W*/}
			MMBT # 3 Light ("50CalFiringLight") Bright
			{
				A_StartSound (AttackSound,CHAN_WEAPON,CHANF_OVERLAP,1.0,0.3);
				Actor Proj = A_SpawnProjectile ("MVP_50CalBullet",12,-8,flags:CMF_AIMDIRECTION,Pitch); //pew pew
				AddProjectileSpread (Proj,(0.8,-0.8),(1.0,-1.0));
				A_SpawnItemEx ("MVP_BulletCasing",-32,32,8,FRandom(2,-2),FRandom(8,14),FRandom(6,12));
				Frame = UpdateRWSElevation (25,19,21,23); //Z, T, V, X
			}
			MMBT # 1
			{
				//If you have no target, or it's dead.
				If (!Target || IsDead (Target))
				{
					A_ClearTarget();
					LookForPlayers (True); //Look for a new target.
				}
				
				//If you share a target with the turret, then try finding a different one.
				//Unless the shared target is stronger than the turret, in which case don't force yourself to attack a different target.
				If (!FocusFire && Target && Master && Target == Master.Target && AssessThreatLevel (Master.Target, False) <= KAI_Actor(Master).ThreatLevel)
				{
					Actor NewTarget = PickDifferentTarget (Master.Target,Master.Target,2048,512);
					If (NewTarget)
						Target = NewTarget;
				}
				
				If (Random2[pr_monsterrefire]() < 48 &&
				//If the target is too high or low to shoot.
				((Target && IsOverPitchLimits (Target,12,Target.Height/2) != ELEVATION_INBOUNDS) ||
				!KAI_TurretCheckLOF (Target,0,0,(0,-8,12),0,"MVP_50CalBullet")))
				{
					A_ClearTarget();
					Return ResolveState ("See");
				}
				
				HandleChaseTimer();
				
				Frame = UpdateRWSElevation (24,18,20,22); //Y, S, U, W
				Return State (Null);
			}
			MMBT # 0 KAI_TurretRefire (48,"See",True,fov:90/2);
			Goto Fire+2;
		Death:
			MBTD Q 1
			{
				If (Master)
				{
					Angle = Master.Angle;
					TurretRotationOffset = 0;
				}
				RotateToVehicle (RTVF_NOTARGETCHECK);
				Actor Boom = Spawn ("MVP_Explosion",Pos);
				Boom.Scale *= 0.6;
				Boom.SetDamage (32);
				Boom.MaxTargetRange = 96;
				Boom.MeleeRange = 12;
				Boom.bNoGravity = True;
			}
			MBTD Q 1 RotateToVehicle (RTVF_NOTARGETCHECK);
			Wait;
		XDeath:
			TNT1 A 0
			{
				Actor Boom = Spawn ("MVP_Explosion",Pos);
				Boom.Scale *= 0.9;
				Boom.SetDamage (56);
				Boom.MaxTargetRange = 128;
				Boom.MeleeRange = 48;
				Boom.bNoGravity = True;
				
				SmokeCounter = 48;
				Bool b; Actor Debris;
				For (Int I; I <= SmokeCounter; I++)
				{
					[B, Debris] = A_SpawnItemEx ("MVP_DiCokkaDebris",FRandom (Radius,-Radius),FRandom(Radius,-Radius),FRandom (0,Height),FRandom (-12,12),FRandom (-12,12),FRandom (6,16));
					If (Debris)
					{
						Debris.Scale *= FRandom (0.1,0.3);
						Debris.bXFlip = Random (False,True);
					}
				}
			}
			Stop;
		GenericFreezeDeath:
			MMBT # 0 {Frame = UpdateRWSElevation (24,18,20,22); /*Y, S, U, W*/}
			Goto Super::GenericFreezeDeath;
	}
}

Class MVP_MBTRWSMinigun : MVP_MBTRWS
{
	Default
	{
		//FriendlySeeBlocks 48;
		//MaxTargetRange 6144;
		KAI_BaseTurret.AttackSpeed 200;
		KAI_BaseTurret.FastAttackSpeed 220;
		AttackSound "Vehicle/Tank/CoaxialFire";
		Obituary "%o drowned in lead";
		Tag "M20 Minigun Remote Weapon Station";
	}
	
	Mixin MVP_AutocannonWarningZoneHandling; //Listen, the minigun works basically the same way as this. It just fires normal non-ripping bullet projectiles.
	
	Int ShotsFired;
	
	Override Bool ShouldAttack (Bool NoStateJump)
	{
		If (!KAI_BaseTurret.ShouldAttack()) Return False;
		If (Target && !CheckFOV (Target,90/2)) Return False;
		If (IsOverPitchLimits (Target,8,Target.Height/2) != ELEVATION_INBOUNDS) Return False;
		
		If (Target != Self && KAI_CheckMissileRange(Target) && !IsDead (Target) && IsActorHostile (Target) && KAI_TurretCheckLOF (Target,150,0,(0,0,8)))
		{
			If (!NoStateJump)
			{
				SetStateLabel ("Fire");
				WarningZone = WarnMarines (0,48); //Create a warning zone to warn marines of wherever the machine gun is aiming.
				If (WarningZone) WarningZone.SetOrigin (GetAttackLocation(),True);
			}
			Return True;
		}
		
		Return False;
	}
	
	States
	{
		Spawn:
			AMBT G 0;
			AMBT # 1
			{
				RotateToVehicle();
				KAI_Look (maxseedist:MaxTargetRange,DEFAULT_HEARDISTANCE,extraflags:KAIL_CHASETARGET);
				Frame = UpdateRWSElevation (12,6,8,10); //M, G, I, K
			}
			Loop;
		See:
			AMBT # 1
			{
				If (ShotsFired > 0) ShotsFired--;
				If (ShotsFired > 40) ThreatLevel = THREAT_DANGEROUS;
				Else ThreatLevel = Default.ThreatLevel;
				If (WarningZone) WarningZone.Destroy();
				DoCombatTraverse();
				RotateToVehicle();
				KAI_LandVehicleChase (chaseflags:CHF_DONTIDLE|CHF_DONTMOVE);
				UpdateTurretSnapTimer();
				Frame = UpdateRWSElevation (12,6,8,10); //M, G, I, K
			}
			Loop;
		Fire:
			AMBT ######## 1 {Frame = UpdateRWSElevation (12,6,8,10); /*M, G, I, K*/}
			AMBT # 4 Light ("RifleFiringLight") Bright
			{
				//The minigun also becomes more dangerous when it reaches max fire rate.
				If (ShotsFired > 200)
				{
					ThreatLevel = THREAT_DANGEROUS;
					A_SetTics (1);
				}
				Else If (ShotsFired > 40) A_SetTics (2);
				Else If (ShotsFired > 10) A_SetTics (3);
				If (ShotsFired <= 40) ThreatLevel = Default.ThreatLevel;
				//console.printf ("tics are %d",tics);
				Actor Proj = A_SpawnProjectile ("MVP_RifleBullet",8,flags:CMF_AIMDIRECTION,Pitch);
				AddProjectileSpread (Proj,(0.8,-0.8),(1.0,-1.0));
				A_StartSound (AttackSound,CHAN_WEAPON,CHANF_OVERLAP,1.0,0.4);
				Actor Casing; Bool B;
				[B, Casing] = A_SpawnItemEx ("MVP_BulletCasing",-16,-3,8,FRandom(1,-1),FRandom(-6,-10),FRandom(6,10));
				Casing.Scale.X = 0.125; Casing.Scale.Y = 0.104166;
				Frame = UpdateRWSElevation (13,7,9,11); //N, H, J, L
				ShotsFired++;
			}
			AMBT # 1
			{
				//If you have no target, or it's dead.
				If (!Target || IsDead (Target))
				{
					Actor Prev = Target;
					A_ClearTarget();
					LookForPlayers (True); //Look for a new target.
					If (!Target) //If the sight check didn't return something like it tends to do sometimes, try finding a target right around the old one.
						Target = PickDifferentTarget (Prev,Prev,512);
				}
				
				//If you share a target with the autocannon, then try finding a different one.
				//Unless the shared target is stronger than the turret you are on, in which case don't force yourself to attack a different target.
				If (!FocusFire && Target && Master && Target == Master.Target && AssessThreatLevel (Master.Target, False) <= KAI_Actor(Master).ThreatLevel)
				{
					Actor NewTarget = PickDifferentTarget (Master.Target,Master.Target,2048,512);
					If (NewTarget)
						Target = NewTarget;
				}
				
				If (Random2[pr_monsterrefire]() < 128 &&
				((Target && IsOverPitchLimits (Target,12,Target.Height/2) != ELEVATION_INBOUNDS) || Target && Distance3DSquared (Target) > MaxTargetRange*MaxTargetRange||
				!KAI_TurretCheckLOF (Target,150,0,(0,0,8))))
				{
					Actor Prev = Target;
					A_ClearTarget();
					LookForPlayers (True); //Look for a new target.
					If (!Target || IsOverPitchLimits (Prev,12,Prev.Height/2))
						Target = PickDifferentTarget (Prev,Prev,512);
					Return ResolveState ("See");
				}
				
				HandleChaseTimer();
				
				Frame = UpdateRWSElevation (12,6,8,10); //M, G, I, K
				Return State (Null);
			}
			AMBT # 0
			{
				Int Chance;
				/*If (ShotsFired > 200) Chance = 8;
				Else If (ShotsFired > 40) Chance = 12;
				Else If (ShotsFired > 10) */Chance = 32;
				KAI_TurretRefire (Chance,"See",True,fov:90/2);
			}
			Goto Fire+8;
		Death:
			MBTD R 1
			{
				If (Master)
				{
					Angle = Master.Angle;
					TurretRotationOffset = 0;
				}
				RotateToVehicle (RTVF_NOTARGETCHECK);
				Actor Boom = Spawn ("MVP_Explosion",Pos);
				Boom.Scale *= 0.6;
				Boom.SetDamage (32);
				Boom.MaxTargetRange = 96;
				Boom.MeleeRange = 12;
				Boom.bNoGravity = True;
			}
			MBTD R 1 RotateToVehicle (RTVF_NOTARGETCHECK);
			Wait;
		XDeath:
			TNT1 A 0
			{
				Actor Boom = Spawn ("MVP_Explosion",Pos);
				Boom.Scale *= 0.9;
				Boom.SetDamage (56);
				Boom.MaxTargetRange = 128;
				Boom.MeleeRange = 48;
				Boom.bNoGravity = True;
			}
			Stop;
		GenericFreezeDeath:
			MMBT # 0 {Frame = UpdateRWSElevation (12,6,8,10); /*M, G, I, K*/}
			Goto Super::GenericFreezeDeath;
	}
}

Mixin Class MVP_MBT_SmokeHandling
{
	Bool FlamingWreck; //Called from the wrecked version of the hull.
	Override Bool SpawnDamageSmoke()
	{
		Bool Dead = IsInState (Self,"Death"); //Tank died normally, spawn extra flames at the hole the engine was in.
		If (FlamingWreck) Dead = FlamingWreck;
		If (!Super.SpawnDamageSmoke() && !Dead) Return False;
		Vector3 SpawnPos = Vec3Angle (96,GetNearestCardinalAngle(True));
		
		//Spawn extra wide fire once dead.
		If (!Dead)
			SpawnPos = Level.Vec3Offset (SpawnPos,(FRandom(-16,16),FRandom(-16,16),48));
		Else
			SpawnPos = Level.Vec3Offset (SpawnPos,(FRandom(-32,32),FRandom(-32,32),48));
		
		SpawnPos.XY = KAI_Math.RotateAround (Pos.XY,SpawnPos.XY,SpriteRotation);
		Let FX = (WoundHealth/2 >= Health || FlamingWreck) ? "MVP_BrightFireParticle" : "MVP_DamageSmoke";
		For (Int I; I < 2; I++)
		{
			Actor Smoke = Spawn (FX,SpawnPos);
			Smoke.Roll = FRandom(-180,180);
			Smoke.A_SetScale (FRandom(0.7,1.2));
			Smoke.Vel.Z = !Dead ? FRandom (1,4) : FRandom (4,8);
		}
		
		//Spawn flames around the turret ring.
		If (Dead && User_T72Mode)
		{
			For (Int I; I < 4; I++)
			{
				SpawnPos = Vec3Offset (FRandom(Radius/2,-Radius/2),FRandom(Radius/2,-Radius/2),Height-12);
				SpawnPos.XY = KAI_Math.RotateAround (Pos.XY,SpawnPos.XY,SpriteRotation);
				Actor Smoke = Spawn (FX,SpawnPos);
				Smoke.Roll = FRandom(-180,180);
				Smoke.A_SetScale (FRandom(0.7,1.2));
				Smoke.Vel.Z = !Dead ? FRandom (1,4) : FRandom (4,8);
			}
		}
		Return True;
	}
}

Mixin Class MVP_MBTTurret_SmokeHandling
{
	//Funky function positioning.
	Override Bool SpawnDamageSmoke()
	{
		If (!IsDead (Self) || SmokeCounter >= 255) Return False;
		Vector3 SpawnPos;
		Bool T72 = IsInState (Self,"FlyingDeath");
		Int Flames = !T72 ? 2 : 4;
		For (Int I; I < Flames; I++)
		{
		
			If (!T72)
			{
				SpawnPos = Vec3Angle (48,GetNearestCardinalAngle(True));
				SpawnPos = Level.Vec3Offset (SpawnPos,(FRandom(-24,24),FRandom(-32,32),8));
			}
			Else
			{
				//Going up.
				If (Vel.Z > 0)
					SpawnPos = Pos;
				//Famous Doom mapset made by online animator Cyriak Harris.
				Else
					SpawnPos = Pos.PlusZ(Height);
				
				SpawnPos = Level.Vec3Offset (SpawnPos,(FRandom(-Radius,Radius),FRandom(-Radius,Radius),0));
			}
			
			SpawnPos.XY = KAI_Math.RotateAround (Pos.XY,SpawnPos.XY,SpriteRotation);
			Actor Smoke = Spawn ("MVP_BrightFireParticle",SpawnPos);
			Smoke.Roll = FRandom(-180,180);
			Smoke.A_SetScale (FRandom(0.7,1.2));
			Smoke.Vel.Z = FRandom (4,8);
		}
		SmokeCounter++;
		Return True;
	}
}
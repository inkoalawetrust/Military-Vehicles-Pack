//TODO:
//Also make a recolored (Orange?) gyrojet variant, which is THREAT_ABOVENORMAL.
//MAYDO: I can afford to make these more expensive, so maybe make a group structure for each of them that allows them to split focus on targets. Among other things.

Class MVP_Quadcopter : MVP_BaseFlyer
{
	Default
	{
		//$Title Quadcopter
		//$Category Vehicles/Panopticon
		//$Sprite PND2B1
		
		Tag "Quadcopter Drone";
		KAI_Actor.ThreatLevelThreshold THREAT_DANGEROUS;
		KAI_Actor.ThreatLevel THREAT_NORMAL;
		KAI_Actor.FlightAcceleration 0.25;
		KAI_Actor.FlightDeceleration 0.25;
		KAI_Actor.FlightWrongDirFactor 2.5;
		+WindThrust;
		+Pushable;
		+SlidesOnWalls;
		+FloatBob; //Scales with speed
		+LookAllAround;
		+AvoidMelee;
		
		Health 50;
		GibHealth 30;
		XScale 0.3;
		YScale 0.25; //0.3/1.2
		FloatSpeed 3;
		FloatBobStrength 0.5;
		Mass 35;
		Height 14;
		DeathHeight 8;
		Radius 16;
		CameraHeight 5;
		Obituary "%o died from a drone strike";
		ActiveSound "Vehicle/Drone/Fly";
		Speed 10;
		FastSpeed 16;
		//Friction 0.5;
	}
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		A_StartSound (ActiveSound,flags:CHANF_LOOPING,attenuation:1.5);
	}
	
	Override Void Tick()
	{
		Super.Tick();
		If (IsFrozen())
			Return;
		
		//Scale visual bobbing with speed.
		If (!IsDead(Self))
		{
			FloatBobStrength = KAI_Math.LinearMap (Vel.Length(),0,6,Default.FloatBobStrength,0.05);
			FloatBobStrength = Clamp (FloatBobStrength,0,Default.FloatBobStrength);
		}
		//Console.Printf ("Bob strength %.2f",FloatBobStrength);
		
		//Replace sprites to make it visually lean based on how high its' velocity is and where it's heading relative to its' current angle.
		If (!IsInState (Self,"Death"))
		{
			//HACK: Frames are offset by -1 to stop the states from flickering to the default state sprite for one tick on every state change.
			//KLUDGE: Oh also do NOT shift them by +1 instead, as that makes them basically switch every tick regardless of the state machine!
			Switch (Frame)
			{
				Case 2: //A
					Frame = LeanFlyerAround (1,4,0,6); // B, E, A
					Break;
				Case 0: //B
					Frame = LeanFlyerAround (2,5,0,6); // C, F, A
					Break;
				Case 1: //C
					Frame = LeanFlyerAround (3,6,0,6); // D, G, A
					Break;
				Default:
					Break;
			}
		}
		Else If (Frame == 24) //We only care about frame Y.
			Frame = LeanFlyerAround (22,23,24); //W, X, Y
	}
	
	//Added more obituaries (And gyrojet ones) later.
	Override String GetObituary (Actor Victim, Actor Inflictor, Name MOD, Bool PlayerAttack)
	{
		Return Super.GetObituary (Victim, Inflictor, MOD, PlayerAttack);
	}
	
	Void MVP_QuadcopterChase ()
	{
		KAI_Chase_PreChecks();
		If (IsDead (Target)) Target = Null;
		KAI_Chase_Retarget(0,True);
		
		Bool MovedAlready; Bool B;
		Int KMTFlags = KMT_3D;
		
		//DETERMINE IF WE SHOULD BE MOVING AWAY FROM THE TARGET.
		//TODO: Add support for hazards. Maybe using an averaged position between all hazards in range and/or the target.
		Bool RunAway = (!bNoFear && (IsFrightening (Target) || bFrightened)); //Run away from spooky actors, or maybe we're just a little bitch.
		//If we're set to run away from targets over our threat threshold that get too close, do so.
		Double RunRange = RetreatRange;
		If (Target) RunRange += Target.Radius;
		If (!bNoFear && Target != Goal && !RunAway && RunRange > 0 && ThreatLevelThreshold != THREAT_ASSESS && Distance3DSquared(Target) <= RunRange*RunRange &&
		AssessThreatLevel(Target, True) >= ThreatLevelThreshold && CheckSight (Target,SF_IGNOREWATERBOUNDARY))
			RunAway = True;
		
		//Avoid melee attackers.
		If (!RunAway && Target && (bAvoidMelee || Level.Info.Flags3 & LEVEL3_AVOIDMELEE))
		{
			Bool IsMeleeAttacker;
			If (!Target.Player && Target.MeleeState) //Melee NPC
			{
				Double Dist = (Target.MeleeRange + Target.Radius)*2;
				IsMeleeAttacker = Distance3DSquared (Target) < Dist*Dist;
			}
			Else If (Target.Player && Target.Player.ReadyWeapon && Target.Player.ReadyWeapon.bMeleeWeapon) //Melee player
				IsMeleeAttacker = Distance3dSquared(Target) <= 192*192;
			
			RunAway = IsMeleeAttacker;
		}
		
		Actor Proj;
		If ((Proj = MVP_QuadcopterDodge(256)))
		{
			//KAI_Chase_HandleStrafing (Proj,0,True,INT.MAX);
			Double Delta = DeltaAngle (Angle,AngleTo(Proj));
			If (Delta >= -2)
				KMT_3D_SpeedLimit(15,(AngleToVector (Angle-90,15),0));
			Else
				KMT_3D_SpeedLimit(15,(AngleToVector (Angle+90,15),0));
			
			LastProjectile = Proj; //So we don't constantly dodge the same thing.
		}
		
		//Push yourself away from the enemy.
		If (RunAway)
		{
			A_FaceTarget(TurnHorz,TurnVert);
			//If there's already a prior position to move to, begin moving there instead. Until within melee range of that position.
			If (!KAI_Math.IsEmptyVector3 (NextMovePos) && NewPosStepCount <= 32 && Level.Vec3Diff (Pos,NextMovePos).Length() >= MeleeRange)
			{console.printf ("going to next move pos");
				KMT_3D_SpeedLimit (Speed/2,KAI_Math.AngleToVector3D(GetAngleToPos(NextMovePos,0),-GetPitchToPos(NextMovePos,0),FlightAcceleration));
				NewPosStepCount++;
				Return;
			}
			//Once the position is reached, get a new one.
			Else
			{console.printf ("set nextmovepos");
				NextMovePos = FindRandomMovePos(Target.Pos,full3D:True);
				NewPosStepCount = 0;
			}
			MovedAlready = True;
		}
		
		//Stay slightly off the ground when not in a tight space.
		If ((CeilingZ - FloorZ) >= 72)
		{
			LineTrace (0,32,90,TRF_BLOCKSELF,data:Ground);
			If (Ground.Distance < 32)
				KMT_3D_SpeedLimit (Speed,(0,0,0.1));
		}
		
		//Move to target, and also handle patrolling but then seeing a target.
		If (Target && Target != Goal && !MovedAlready)
		{
			KAI_MoveTowards (Target.Pos.PlusZ(Target.Height/2),1,TurnHorz,flags:KMTFlags,TurnVert);
			//If (Random (0,255) < 1) KAI_Chase_HandleStrafing(Target,0,True,MaxTargetRange);
			MovedAlready = True;
		}
		
		If (!MovedAlready)
		{
			MeleeRange = 32;
			[B, MovedAlready] = KAI_Chase_PatrolHandling ("Stand",1,TurnHorz,flags:KMTFlags,TurnVert);
			MeleeRange = Default.MeleeRange;
			//If (b && goal) spawn ("kai_debugpoint",goal.pos);
			//if (goal)console.printf ("patrolling, goal is at %d %d %d, moved already %d, reached point %d",goal.pos,movedalready,b);
		}
		
	}
	
	//IDEA: Also make it handle flying away from homing projectiles maybe?
	Actor MVP_QuadcopterDodge (Double Range = 128)
	{
		Array <Actor> Threats;
		//Actually find projectiles.
		ForEach (Proj : KAIHandler.ProjectileList)
		{
			If (!Proj || Proj == LastProjectile) Continue;
			
			Bool DodgeAllyProjectiles;
			
			Bool IsHoming = Proj.bSeekerMissile; //HACK: NO stupid revenant rocket check.

			Double Dist = Distance3DSquared (Proj);
			If ((Dist > Range*Range || IsHoming && Proj.Tracer == Self && Dist > (Range*Range)*2 )) //Out of range. But if it's a seeker, check at double the range to potentially run away.
				Continue;
			
			//Dodge even friendly projectiles if they'd do too much damage, unless friendly fire is off.
			DodgeAllyProjectiles = (!(Proj Is "KAI_BaseProjectile" && KAI_BaseProjectile(Proj).bNoFriendlyFire) && Proj.GetMissileDamage (1,7) >= Health/2);
			
			If (!DodgeAllyProjectiles && !IsActorHostile (Proj.Target)) //Ignore friendly projectiles.
				Continue;
			
			//Is the projectile about to hit me ? Weird math nonsense written by RaveYard.
			double blackBox = -0.15;
			If (IsHoming && Proj.Tracer == Self) blackBox = -0.075;
			bool projectile_is_flying_towards_me = (Vec3To(proj).Unit() dot proj.vel.Unit()) < blackBox;
			double projectileSafeRadius = sqrt(2 * ((proj.radius + radius) ** 2.5));
			if(projectile_is_flying_towards_me && KAI_Math.distance3dline(pos, proj.pos, proj.pos + proj.vel) < projectileSafeRadius && CheckSight(Proj,SF_IGNOREWATERBOUNDARY))
				Threats.Push (Proj);
		}
		
		Double HighestDamage;
		Actor StrongestProj;
		For (Int I = Threats.Size()-1; I >= 0; I--)
		{
			Double CurrentDamage = Threats[I].GetMissileDamage(1,7);
			If (HighestDamage < CurrentDamage)
			{
				HighestDamage = CurrentDamage;
				StrongestProj = Threats[I];
			}
		}
		
		Return StrongestProj;
	}
	
	Const TurnHorz = 15;
	Const TurnVert = 60;
	Const RetreatRange = 384;
	Actor LastProjectile;
	FLineTraceData Ground;
	
	States
	{
		Spawn:
			PND2 ABC 1 KAI_Look(extraflags:KAIL_CHASETARGET); //NOTE: The ABCD frames are replaced dynamically.
			Loop;
		See:
			PND2 ABC 1 MVP_QuadcopterChase();
			Loop;
		Death:
			TNT1 A 0
			{
				//A_Explode (32,72);
				Actor Boom = Spawn ("MVP_Explosion",Pos);
				Boom.Scale *= 0.75;
				Boom.SetDamage (32);
				Boom.MaxTargetRange = 72;
				Boom.MeleeRange = 0;
				Boom.bNoGravity = True;
				Boom.bGetOwner = True;
				Boom.Target = Self; //We exploded, this explosion is ours.
				bFloatBob = False;
				A_StopSound (CHAN_BODY);
			}
			PND2 Y 1 //Falling loop.
			{
				If (!TestMobjZ(True) || GetZAt ()+1 >= Pos.Z)
					Return A_JumpIf (True == True, 1); //Hit the floor.
				
				Return State(Null);
			}
			Goto Death+1;
			PND2 UV 4;
			PND2 V -1;
			Stop;
		XDeath:
			TNT1 A 0
			{
				Actor Boom = Spawn ("MVP_Explosion",Pos);
				Boom.Scale *= 1.25;
				Boom.SetDamage (64);
				Boom.MaxTargetRange = 144;
				Boom.MeleeRange = Radius+24;
				Boom.bNoGravity = True;
				Boom.bGetOwner = True;
				Boom.Target = Self; //Does it even matter if we're gone? Very philosophical.
				
				SmokeCounter = Random (8,16);
				Bool B; Actor Debris;
				For (Int I; I <= SmokeCounter; I++)
				{
					[B, Debris] = A_SpawnItemEx ("MVP_DiCokkaDebris",FRandom (Radius,-Radius),FRandom(Radius,-Radius),FRandom (0,Height),FRandom (-6,6),FRandom (-6,6),FRandom (2,8));
					If (Debris)
					{
						Debris.Scale *= FRandom (0.1,0.4);
						Debris.bXFlip = Random (False,True);
					}
				}
				
				Spawn ("MVP_QuadcopterGib",Pos); //Just fall straight down lol.
				SmokeCounter = Random (1,4);
				For (Int I = 0; I < SmokeCounter; I++)
				{
					Actor Prop = Spawn ("MVP_QuadcopterGib",Pos);
					Prop.SetOrigin (Level.Vec3Offset(Pos,(Random (16,-16),Random (22,-22),0)),True); //Pick random position to put the propeller at.
					Prop.SmokeCounter = 1;
					Prop.Vel = (FRandom (8,-8),FRandom (8,-8),FRandom (4,8));
				}
				
				A_StopSound (CHAN_BODY);
			}
			Stop;
	}
}

Class MVP_QuadcopterGib : Actor
{
	Default
	{
		+RollSprite;
		XScale 0.5;
		YScale 0.41666; //0.5/1.2
		-Solid;
		+NoBlockmap;
	}
	
	States
	{
		Spawn:
			PND2 [ 0 A_JumpIf (SmokeCounter == 0,"Fall"); //Gun
			PND2 ] 0 A_JumpIf (SmokeCounter == 1,"Fall"); //Rotor
		Fall:
			PND2 # 1
			{
				Roll += 20;
				If (!TestMobjZ(True) || GetZAt ()+1 >= Pos.Z)
				{
					If (SmokeCounter == 0) //Hit the floor.
					{
						Roll = 13;
						Return FindState ("Death",True);
					}
					Else
					{
						Roll = 0;
						Return FindState ("Death.Propeller",True);
					}
				}
				
				Return State(Null);
			}
			Loop;
		Death:
			PND2 [ -1;
			Stop;
		Death.Propeller:
			PND2 ^ -1;
			Stop;
	}
}
//TODO:
//Also make a recolored (Orange?) gyrojet variant, which is THREAT_ABOVENORMAL.
//Add the ability for it to land and walk on the ground.
//Add an OnWander() override to handle following the player (And anything else) more properly.

//BUG: If the drone is frozen, it will then stack overflow upon shattering, very cool!

Class MVP_Quadcopter : MVP_BaseFlyer
{
	Default
	{
		//$Title Quadcopter
		//$Category Vehicles/Panopticon
		//$Sprite PND2B1
		
		Tag "Quadcopter Drone";
		KAI_Actor.ThreatLevelThreshold THREAT_DANGEROUS;
		KAI_Actor.ThreatLevel THREAT_NORMAL;
		KAI_Actor.FlightAcceleration 0.25;
		KAI_Actor.FlightDeceleration 0.25;
		KAI_Actor.FlightWrongDirFactor 2.5;
		MVP_BaseVehicle.SmokeDelay 8;
		KAI_BaseVehicle.HeadlightLevel 88;
		KAI_Actor.Inaccuracy (32,32,32);
		KAI_Actor.InaccuracyFrequency 0.6;
		
		+WindThrust;
		//+Pushable;
		//+SlidesOnWalls;
		+FloatBob; //Scales with speed
		+LookAllAround;
		+AvoidMelee;
		
		Health 50;
		WoundHealth 20;
		GibHealth 30;
		XScale 0.3;
		YScale 0.25; //0.3/1.2
		FloatSpeed 1;
		FloatBobStrength 0.5;
		Mass 35;
		Height 14;
		DeathHeight 8;
		Radius 16;
		CameraHeight 5;
		MeleeRange 64;
		Obituary "%o died from a drone strike";
		ActiveSound "Vehicle/Drone/Fly";
		AttackSound "Vehicle/APC/SmallMGFire";
		Speed 10;
		FastSpeed 16;
		//Friction 0.5;
		RipLevelMin 1;
	}
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		A_StartSound (ActiveSound,flags:CHANF_LOOPING,attenuation:1.5);
		If (KAIHandler) Yapper = KAIHandler.GetNPCVoice ("Panopticon");
	}
	
	Override Void UserVariableDefaults()
	{
		If (User_ChaseTime == 0) User_ChaseTime = 35*30;
		If (User_RetreatDistance == 0) User_RetreatDistance = 384;
	}
	
	Override Void SpawnHeadlights()
	{
		Headlights.Push (SpawnVehicleHeadlight (Self,(16,0,0),VHSF_SPRITEROT,(255,0,0),128,(15,80)));
	}
	
	Override Bool CanAttack()
	{
		If (CurSector.Flags & Sector.SECF_NOATTACK) Return False;
		Return True;
	}
	
	Override Bool SpawnDamageSmoke()
	{
		If (!Super.SpawnDamageSmoke()) Return False;
		Vector3 SpawnPos = Level.Vec3Offset (Pos,(FRandom(-8,8),FRandom(-8,8),FRandom(2,8)));
		Actor Smoke = Spawn ("MVP_DamageSmoke",SpawnPos);
		Smoke.Roll = FRandom(-180,180);
		Smoke.A_SetScale (FRandom(0.1,0.5));
		Smoke.Vel.Z = FRandom (1,2);
		Return True;
	}
	
	Override Void Tick()
	{
		Super.Tick();
		If (IsFrozen())
			Return;
		
		Bool Ded = IsDead(Self);
		//Scale visual bobbing with speed.
		If (!Ded)
		{
			FloatBobStrength = KAI_Math.LinearMap (Vel.Length(),0,6,Default.FloatBobStrength,0.05);
			FloatBobStrength = Clamp (FloatBobStrength,0,Default.FloatBobStrength);
		}
		//Console.Printf ("Bob strength %.2f",FloatBobStrength);
		
		If (!IsInAttackState())
		{
			If (FireDelay) FireDelay--;
			If (!Ded && Target && Target != Goal) //Adjust imaginary turret, as long as the target isn't actually a goal point. So that bChaseGoal works.
			{
				Double RealAngle = Angle; Double RealPitch = Pitch;
			
				Angle = FireAngle; Pitch = FirePitch;
				FireAngle = GetAngleToPos (Target.Pos,5);
				FirePitch = GetPitchToPos (Target.Pos,5);
				Angle = RealAngle; Pitch = RealPitch;
				//FirePitch = PitchTo (Target);//-GetPitchToPos (Target.Pos,5); //HACK: Pitches are fucking haunted in GZDoom, so we can't increment THAT one over time!
				//FirePitch = Clamp (FirePitch,MaxGunPitch,90);
				//kai_lofraycast.visualizetracepath (Pos,level.vec3offset(pos,kai_math.angletovector3d(fireangle,-firepitch,256)),256);
			}
			//Replace sprites to make it visually lean based on how high its' velocity is and where it's heading relative to its' current angle.
			If (!Ded)
			{
				//HACK: Frames are offset by -1 to stop the states from flickering to the default state sprite for one tick on every state change.
				//KLUDGE: Oh also do NOT shift them by +1 instead, as that makes them basically switch every tick regardless of the state machine!
				Switch (Frame)
				{
					Case 2: //A
						Frame = LeanFlyerAround (1,4,0,4,offset:SpriteRotation); // B, E, A
						Break;
					Case 0: //B
						Frame = LeanFlyerAround (2,5,0,4,offset:SpriteRotation); // C, F, A
						Break;
					Case 1: //C
						Frame = LeanFlyerAround (3,6,0,4,offset:SpriteRotation); // D, G, A
						Break;
					Default:
						Break;
				}
			}
			Else If (Frame == 24) //We only care about frame Y.
				Frame = LeanFlyerAround (22,23,24); //W, X, Y
		}
		Else
		{
			//We aim ahead using a separate set of pitches and angles, allowing the drone to not have to actually change angle and pitch mid move.
			Double RealAngle = Angle; Double RealPitch = Pitch;
			
			Angle = FireAngle; Pitch = FirePitch;
			AimAtTarget (5,5,flags:FAF_MIDDLE,attackspeed:170,200);
			FireAngle = Angle; FirePitch = Pitch;
			
			Angle = RealAngle; Pitch = RealPitch;
			console.printf ("attack angle %d, real angle %d, attack pitch %d, real pitch %d",fireangle,angle,firepitch,pitch);
			MVP_QuadcopterChase(); //Oh yes, we can run n' gun quite fine.
			
			If (FirePitch >= 15)
			{
				If (Frame == 0) //A
					Frame = 8; //I
				Else If (Frame == 7) //H
					Frame = 9; //J
			}
		}
	}
	
	//Added more obituaries (And gyrojet ones) later.
	Override String GetObituary (Actor Victim, Actor Inflictor, Name MOD, Bool PlayerAttack)
	{
		Return Super.GetObituary (Victim, Inflictor, MOD, PlayerAttack);
	}
	
	Override Bool ShouldAttack (Bool NoStateJump)
	{
		If (!CanAttack() || IsInAttackState() || Target == Goal || FireDelay > 0) //Don't run from within attack states to allow the drone to run n' gun by calling its' chase function.
			Return False;
		
		If (MVP_QuadcopterLOF() && KAI_CheckMissileRange (Target,CMR_3DDISTANCE|CMR_NOHITFRIEND))
		{
			If (!NoStateJump)
				SetStateLabel ("Missile");
			
			Return True;
		}
		
		Return False;
	}
	
	Override Void HandleNPCGroupEvent (Int EventType, Actor Affected, KAI_NPCGroup WhatGroup)
	{
		If (EventType == KAI_NPCGroup.GRPEVNT_NONE || !Affected || IsDead(Self))
			Return;
		
		//Swarm member died, but only speak if they are like, remotely important and also not just one of the flying bombs
		If ((EventType == KAI_NPCGroup.GRPEVNT_DEATH || EventType == KAI_NPCGroup.GRPEVNT_ERASED) && WhatGroup Is "MVP_DroneSwarm" && Random (0,255) < 16 &&
		AssessThreatLevel (Affected,True,checkdead:True) >= THREAT_MILD && !(Affected Is "MVP_KamikazeDrone"))
			{SayVoiceLine (VOICE_SEE,Yapper);console.printf ("NOOOOOOOOOOOO!!!!!!!!!");}
	}
	
	Void MVP_QuadcopterChase ()
	{
		KAI_Chase_PreChecks();
		If (IsDead (Target)) Target = Null;
		KAI_Chase_Retarget(0,True);
		
		Bool MovedAlready; Bool B;
		Int KMTFlags = KMT_3D;
		
		//DETERMINE IF WE SHOULD BE MOVING AWAY FROM THE TARGET.
		Bool RunAway = (!bNoFear && (IsFrightening (Target) || bFrightened)); //Run away from spooky actors, or maybe we're just a little bitch.
		//If we're set to run away from targets over our threat threshold that get too close, do so.
		Double RunRange = User_RetreatDistance;
		Int TargetLevel;
		If (Target)
		{
			RunRange += Target.Radius;
			TargetLevel = AssessThreatLevel(Target, True);
		}
		
		Bool TargetInSight = CheckSight (Target,SF_IGNOREWATERBOUNDARY);
		Bool LockedIn = bChaseGoal && Goal; //Don't run away if you have a target but are also patrolling in bChaseGoal mode. Since you do that by just flying around.
		Bool BigThreat = (ThreatLevelThreshold != THREAT_ASSESS && TargetLevel >= ThreatLevelThreshold); //Target's threat level is over the threshold.
		If (RunRange != -1 && !bNoFear && Target && Target != Goal && !LockedIn && !RunAway && BigThreat && RunRange > 0 && Distance3DSquared(Target) <= RunRange*RunRange && TargetInSight)
			RunAway = True;
		
		//Avoid melee attackers.
		If (!LockedIn && !RunAway && Target && (bAvoidMelee || Level.Info.Flags3 & LEVEL3_AVOIDMELEE))
		{
			Bool IsMeleeAttacker;
			If (!Target.Player && Target.MeleeState) //Melee NPC
			{
				Double Dist = (Target.MeleeRange + Target.Radius)*2;
				IsMeleeAttacker = Distance3DSquared (Target) < Dist*Dist;
			}
			Else If (Target.Player && Target.Player.ReadyWeapon && Target.Player.ReadyWeapon.bMeleeWeapon) //Melee player
				IsMeleeAttacker = Distance3dSquared(Target) <= 192*192;
			
			RunAway = IsMeleeAttacker;
		}
		
		If (Health > WoundHealth) //Ignore weak hazards if not weak yourself.
		{
			For (Int I = Hazards.Size()-1; I >= 0; I--)
			{
				If (Hazards[I] && Hazards[I].Level <= HazardInfo.HAZARD_LOW)
					Hazards.Delete(I);
			}
		}
		HazardInfo Haz = GetNearestHazard(Hazards);
		Double HazardDist = GetHazardDistance (Haz); //Get distance to nearest hazard that you're in range of.
		
		//Keep different distances for targets under the threshold.
		If (!LockedIn && !RunAway && Target && (TargetLevel < ThreatLevelThreshold || RunRange != -1))
		{
			Double Dist = 0;
			Switch (TargetLevel)
			{
				//Case THREAT_UNSTOPPABLE:
				//	Dist = 8192;
				//	Break;
				Case THREAT_SUPERDANGER:
					Dist = 768;
					Break;
				Case THREAT_VERYDANGEROUS:
					Dist = 512;
					Break;
				Case THREAT_DANGEROUS:
					Dist = 384;
					Break;
				//Just in case the threshold is changed ^^^^^
				Case THREAT_ABOVENORMAL:
					Dist = 192;
					Break;
				Case THREAT_NORMAL:
					Dist = 128;
					Break;
				Case THREAT_MILD:
				Case THREAT_LOW:
					Dist = 32;
					Break;
				Case THREAT_VERYLOW:
				Default:
					Break;
			}
			If (Dist > 0) Dist += Target.Radius;
			If (Health <= WoundHealth) //Keep some extra distance when hurt.
				Dist += 32;
			
			Double TargDist = Distance3D (Target);
			//Run from target if hazard isn't closer.
			//BUG: Yeah so this just doesn't run if we have a hazard in range I guess? Isn't that just splendid?
			If (Dist && TargDist <= Dist && !(Haz && TargDist >= HazardDist))
			{
				RunAway = True;
				Haz = Null; //Signify that we shouldn't run from a hazard later in the function.
			}
		}
		//Also check for scary hazards.
		If (Haz)
			RunAway = True;
		
		Actor Proj;
		If ((Proj = MVP_QuadcopterDodge(256)))
		{
			//KAI_Chase_HandleStrafing (Proj,0,True,INT.MAX);
			Double Delta = DeltaAngle (Angle,AngleTo(Proj));
			If (Delta >= -2)
				KMT_3D_SpeedLimit(15,(AngleToVector (Angle-90,15),0));
			Else
				KMT_3D_SpeedLimit(15,(AngleToVector (Angle+90,15),0));
			
			LastProjectile = Proj; //So we don't constantly dodge the same thing.
		}
		
		//Push yourself away from the enemy or hazard.
		If (!LockedIn && RunAway)
		{
			A_FaceTarget(TurnHorz,TurnVert);
			//If there's already a prior position to move to, begin moving there instead. Until within melee range of that position.
			If (!KAI_Math.IsEmptyVector3 (NextMovePos) && NewPosStepCount <= 16 && Level.Vec3Diff (Pos,NextMovePos).Length() >= MeleeRange)
			{
				KMT_3D_SpeedLimit (Speed/2,KAI_Math.AngleToVector3D(GetAngleToPos(NextMovePos,0),-GetPitchToPos(NextMovePos,0),FlightAcceleration));
				NewPosStepCount++;
				Return;
			}
			//Once the position is reached, get a new one. Do take a few extra steps away though.
			Else If (NewPosStepCount++ <= 24)
			{console.printf ("set nextmovepos, hazard is %p",haz);
				Vector3 RuNpos = !Haz ? Target.Pos : GetHazardOriginPos(Haz);
				NextMovePos = FindRandomMovePos(RunPos,full3D:True);
				NewPosStepCount = 0;
			}
			MovedAlready = True;
		}
		
		//Stay slightly off the ground when not in a tight space.
		If ((CeilingZ - FloorZ) >= 72)
		{
			LineTrace (0,32,90,TRF_BLOCKSELF,data:Ground);
			If (Ground.Distance < 32)
				KMT_3D_SpeedLimit (Speed,(0,0,0.1));
		}
		
		//Target is too high up to fire at.
		Bool CantAttack;
		If (Target && TargetInSight && PitchTo (Target) <= MaxGunPitch)
		{console.printf ("drone rising up to fire");
			CantAttack = True;
			KMT_3D_SpeedLimit (Speed,(0,0,0.5));
		}
		
		Vector3 Scale = ScaleInAdvance (384);
		If (!KAI_Math.IsEmptyVector3(Scale))
		{
			KMT_3D_SpeedLimit (Speed,(0,0,FloatSpeed));
		}
		
		//Move to target, and also handle patrolling but then seeing a target.
		If (Target && Target != Goal && !(IsPatrolling(Self) && bChaseGoal) && !MovedAlready)
		{
			KAI_MoveTowards (Target.Pos.PlusZ(Target.Height/2),DetourFactor,TurnHorz,flags:KMTFlags,TurnVert);
			MovedAlready = True;
		}
		
		//Patrol handling.
		//BUG: ZDoom's hacky usage of ReactionTime makes the drone not wait at patrol points when it has a target.
		If (!MovedAlready)
		{
			[B, MovedAlready] = KAI_Chase_PatrolHandling ("Spawn",DetourFactor,TurnHorz,flags:KMTFlags,TurnVert);
			If (bChaseGoal && Goal && Target != Goal) //Manually go to goal when it "don't chase target" mode.
			{
				KAI_MoveTowards (Goal.Pos,DetourFactor,TurnHorz,flags:KMTFlags,TurnVert);
				//Also handle visually offseting the drone to the imaginary turrets' position when we have a target.
				If (TargetInSight) SpriteRotation = DeltaAngle (Angle,FireAngle);
				Else SpriteRotation = 0;
			}
			Else
				SpriteRotation = 0;
			//If (b && goal) spawn ("kai_debugpoint",goal.pos);
			if (goal)console.printf ("patrolling, goal is at %d %d %d, moved already %d, reached point %d, reactiontime %d",goal.pos,movedalready,b,reactiontime);
		}
		
		If (!CantAttack && ShouldAttack())
			Return;
		
		HandleChaseTimer();
	}
	
	Vector3 ScaleInAdvance (Double Range)
	{
		Vector3 Where = (Double.NaN, Double.NaN, Double.NaN); Bool Success;
		FLineTraceData Check;
		LineTrace (Angle,Range,-Pitch,TRF_BLOCKSELF,data:Check);
		Vector3 HitPos = Check.HitDir * (Check.Distance-(Radius*0.5)); //Can't be the exact hit location outside ScaleObstacle just returns false.
		HitPos = Level.Vec3Offset(Pos,HitPos);
		
		If (Check.HitType)
			Success = KMT_3D_ScaleObstacle(HitPos,Where.Z);
		
		If (!Success)
			Where = (Double.NaN, Double.NaN, Double.NaN);
		Else
			Where.XY = HitPos.XY;
		
		kai_lofraycast.visualizetracepath (Pos,hitpos,check.distance);
		
		Return Where;
	}
	
	//IDEA: Also make it handle flying away from homing projectiles maybe?
	Actor MVP_QuadcopterDodge (Double Range = 128)
	{
		Array <Actor> Threats;
		//Actually find projectiles.
		ForEach (Proj : KAIHandler.ProjectileList)
		{
			If (!Proj || Proj == LastProjectile) Continue;
			
			Bool DodgeAllyProjectiles;
			
			Bool IsHoming = Proj.bSeekerMissile; //HACK: NO stupid revenant rocket check.

			Double Dist = Distance3DSquared (Proj);
			If ((Dist > Range*Range || IsHoming && Proj.Tracer == Self && Dist > (Range*Range)*2 )) //Out of range. But if it's a seeker, check at double the range to potentially run away.
				Continue;
			
			//Dodge even friendly projectiles if they'd do too much damage, unless friendly fire is off.
			DodgeAllyProjectiles = (!(Proj Is "KAI_BaseProjectile" && KAI_BaseProjectile(Proj).bNoFriendlyFire) && Proj.GetMissileDamage (1,7) >= Health/2);
			
			If (!DodgeAllyProjectiles && !IsActorHostile (Proj.Target)) //Ignore friendly projectiles.
				Continue;
			console.printf ("matrix");
			//Is the projectile about to hit me ? Weird math nonsense written by RaveYard.
			double blackBox = -0.15;
			If (IsHoming && Proj.Tracer == Self) blackBox = -0.075;
			bool projectile_is_flying_towards_me = (Vec3To(proj).Unit() dot proj.vel.Unit()) < blackBox;
			double projectileSafeRadius = sqrt(2 * ((proj.radius + radius) ** 2.5));
			if(projectile_is_flying_towards_me && KAI_Math.distance3dline(pos, proj.pos, proj.pos + proj.vel) < projectileSafeRadius && CheckSight(Proj,SF_IGNOREWATERBOUNDARY))
				Threats.Push (Proj);
		}
		
		Double HighestDamage;
		Actor StrongestProj;
		For (Int I = Threats.Size()-1; I >= 0; I--)
		{
			Double CurrentDamage = Threats[I].GetMissileDamage(1,7);
			If (HighestDamage < CurrentDamage)
			{
				HighestDamage = CurrentDamage;
				StrongestProj = Threats[I];
			}
		}
		
		Return StrongestProj;
	}
	
	//Return true if we are aiming ahead of our target and also have a valid LOF straight at them.
	Bool MVP_QuadcopterLOF()
	{
		//If (!AimingAheadOfTarget())
		If (!Target)
			Return False;
			
		Let Check = New ("KAI_ProjectileLOFCheck");
		
		Check.Shooter = Self;
		Check.Other = Target;
		//Check.SplashRadius = SplashRadius;
		Check.PropHealthThreshold = 50;
		Check.FriendlyFire = False;
		
		Check.ProjInfo = New ('LOFProjInfo'); //Assign data class.
		Check.ProjInfo.Projectile = "MVP_SmallRifleBullet"; //Pass projectile class to class.
		Check.ProjInfo.InitializeProjectileInfo(); //Let it infer the rest.
		
		Check.Trace (Pos,CurSector,KAI_Math.AngleToVector3D(AngleTo(Target),PitchTo(Target,targzofs:Target.Height/2)),Distance3D (Target)+32,0);
		
		If (Check.BadLOF)
		{
			If (Check.ProjInfo) Check.ProjInfo.Destroy();
			Check.Destroy();
			Return False;
		}
		
		If (Check.ProjInfo) Check.ProjInfo.Destroy();
		Check.Destroy();
		Return True;
	}
	
	Void MVP_QuadcopterFire ()
	{
		A_StartSound (AttackSound,CHAN_WEAPON,CHANF_OVERLAP,1.0,0.3);
		Actor Proj = A_SpawnProjectile ("MVP_SmallRifleBullet",0,angle:FireAngle,flags:CMF_AIMDIRECTION|CMF_ABSOLUTEANGLE,FirePitch); //pew pew
		AddProjectileSpread (Proj,(0.3,-0.3),(0.6,-0.6));
		Bool B; Actor Casing;
		[B, Casing] = A_SpawnItemEx ("MVP_BulletCasing",0,0,0,FRandom(2,-2),FRandom(2,8),FRandom(2,6));
		Casing.Scale.X = 0.125; Casing.Scale.Y = 0.104166;
		FireDelay = 35*Random (2,4);
	}
	
	//When in a group
	Void MVP_QuadcopterSwitchTargets()
	{
		Array <Actor> Taken; //Other drones are already targeting these.
		Array <Actor> Others; //Other potential targets.
		
		ForEach (Grp : Groups)
		{
			If (Grp && Grp Is "MVP_DroneSwarm")
			{
				ForEach (Mem : Grp.Members)
				{
					If (Mem Is "MVP_Quadcopter" && Mem.Target && !IsDead(Mem) && Mem.Target != Goal)
					{
						console.printf ("%p is already targeting %p",mem,mem.target);
						Taken.Push (Mem.Target);
					}
				}
			}
		}
		If (!Taken.Size())
			Return;
		
		LookForEnemiesEx (Others, 1024, False, True);
		
		ForEach (Targ : Others)
		{
			If (IsDead (Targ))
				Continue;
			
			If (Taken.Find (Targ) == Taken.Size()) //This target isn't taken.
			{
				Target = Targ;
				If (Random (0,255) < 8 && Yapper) SayVoiceLine (VOICE_SEE,Yapper);
				console.printf ("found something my gang isn't targeting already");
				Break;
			}
		}
	}
	
	//Speak with other quadcopters.
	Void MVP_QuadcopterSpeak()
	{
		Array <Actor> Frens;
		ForEach (Grp : Groups)
		{
			If (Grp && Grp Is "MVP_DroneSwarm" && MVP_DroneSwarm(Grp).Quadcopters.Size())
			{
				ForEach (Fren : MVP_DroneSwarm(Grp).Quadcopters)
				{
					If (Distance3DSquared (Fren) <= 512*512)
						Frens.Push (Fren);
				}
			}
		}
		
		If (Frens.Size())
		{
			Actor Fren = Frens[Random(0,Frens.Size()-1)];
			console.printf ("what is bro waffling on about");
			SayVoiceLine (VOICE_SEE,Yapper);
			If (Random (True, False) == True) //Sometimes the other drone speaks back.
				MVP_Quadcopter(Fren).SayVoiceLine (VOICE_SEE,MVP_Quadcopter(Fren).Yapper);
		}
	}
	
	Const TurnHorz = 15;
	Const TurnVert = 60;
	Const DetourFactor = 1.5;
	Const MaxGunPitch = -20; //How much the imaginary gun can aim up.
	
	Actor LastProjectile;
	Double FireAngle, FirePitch; //The actual orientation used when firing. Think of it like an imaginary turret actor.
	UInt FireDelay;
	FLineTraceData Ground;
	KAI_Voice Yapper;
	
	States
	{
		Spawn:
			PND2 ABC 1
			{
				KAI_Look(extraflags:KAIL_CHASETARGET); //NOTE: The ABC frames are replaced dynamically.
				KMT_3D_SpeedLimit (0,(0,0,0)); //Stand still.
			}
			Loop;
		See:
			PND2 ABC 1 MVP_QuadcopterChase();
			Loop;
		Idle:
			PND2 ABC 1
			{
				KAI_Look(extraflags:KAIL_CHASETARGET);
				KAI_Wander (anglelimit:TurnHorz,flags:KMT_3D,TurnVert);
				
				If (Random(0,2048) == Random (0,2048) && Yapper)
					MVP_QuadcopterSpeak();
			}
			Loop;
		Missile:
			PND2 A 3;
			PND2 H 2 Light ("RifleFiringLightNoSelfLighting") MVP_QuadcopterFire();
			PND2 A 3;
			PND2 H 2 Light ("RifleFiringLightNoSelfLighting") MVP_QuadcopterFire();
			PND2 A 3;
			PND2 H 2 Light ("RifleFiringLightNoSelfLighting") MVP_QuadcopterFire();
			PND2 H 0 MVP_QuadcopterSwitchTargets();
			Goto See;
		Death:
			TNT1 A 0
			{
				//A_Explode (32,72);
				Actor Boom = Spawn ("MVP_Explosion",Pos);
				Boom.Scale *= 0.75;
				Boom.SetDamage (32);
				Boom.MaxTargetRange = 72;
				Boom.MeleeRange = 0;
				Boom.bNoGravity = True;
				Boom.bGetOwner = True;
				Boom.Target = Self; //We exploded, this explosion is ours.
				bFloatBob = False;
				A_StopSound (CHAN_BODY);
			}
			PND2 Y 1 //Falling loop.
			{
				If (!TestMobjZ(True) || GetZAt ()+1 >= Pos.Z)
					Return A_JumpIf (True == True, 1); //Hit the floor.
				
				Return State(Null);
			}
			Goto Death+1;
			PND2 UV 4;
			PND2 V -1;
			Stop;
		XDeath:
			TNT1 A 0
			{
				Actor Boom = Spawn ("MVP_Explosion",Pos);
				Boom.Scale *= 1.25;
				Boom.SetDamage (64);
				Boom.MaxTargetRange = 144;
				Boom.MeleeRange = Radius+24;
				Boom.bNoGravity = True;
				Boom.bGetOwner = True;
				Boom.Target = Self; //Does it even matter if we're gone? Very philosophical.
				
				SmokeCounter = Random (8,16);
				Bool B; Actor Debris;
				For (Int I; I <= SmokeCounter; I++)
				{
					[B, Debris] = A_SpawnItemEx ("MVP_DiCokkaDebris",FRandom (Radius,-Radius),FRandom(Radius,-Radius),FRandom (0,Height),FRandom (-6,6),FRandom (-6,6),FRandom (2,8));
					If (Debris)
					{
						Debris.Scale *= FRandom (0.1,0.4);
						Debris.bXFlip = Random (False,True);
					}
				}
				
				Spawn ("MVP_QuadcopterGib",Pos); //Just fall straight down lol.
				SmokeCounter = Random (1,4);
				For (Int I = 0; I < SmokeCounter; I++)
				{
					Actor Prop = Spawn ("MVP_QuadcopterGib",Pos);
					Prop.SetOrigin (Level.Vec3Offset(Pos,(Random (16,-16),Random (22,-22),0)),True); //Pick random position to put the propeller at.
					Prop.SmokeCounter = 1;
					Prop.Vel = (FRandom (8,-8),FRandom (8,-8),FRandom (4,8));
				}
				
				A_StopSound (CHAN_BODY);
			}
			Stop;
	}
}

//Drone swarm group structure. The group leader is kinda irrelevant for this group type.
//TODO:
//MAYDO: Make the leader pointer useful by making it so non-drone actors are automatically set as leaders and become what the drones follow?

Class MVP_DroneSwarm : KAI_NPCGroup
{
	Override Void PreInitialize () //No need to set group icons!
	{
		ChangeNPCGroupFlags (NPCGRP_NOICONS,0);
	}
	
	Array <Actor> Quadcopters;
	
	Override Void HandleGroupEvent (Int EventType, Actor Affected)
	{
		Super.HandleGroupEvent (EventType, Affected);
		
		//Every time the membership status of the group changes, check if there's any loitering drones in it to assign them to quadcopters randomly.
		//Also handle distinguishing said quadcopters.
		If (EventType == GRPEVNT_JOIN || EventType == GRPEVNT_LEFT || EventType == GRPEVNT_DEATH || EventType == GRPEVNT_ERASED)
		{
			If (Affected Is "MVP_Quadcopter")
			{
				If (!IsDead(Affected))
					Quadcopters.Push (Affected);
				Else //The drone is considered dead if it doesn't exist too!
					Quadcopters.Delete(Quadcopters.Find(Affected));
			}
			
			ForEach (Loit : Members)
			{
				If (Loit Is "MVP_KamikazeDrone" && Quadcopters.Size())
				{
					Loit.Master = Quadcopters[Random(0,Quadcopters.Size()-1)];
					console.printf ("randomly assigned %p to follow a quadcopter",loit);
				}
			}
		}
	}
}

Class MVP_QuadcopterGib : Actor
{
	Default
	{
		+RollSprite;
		XScale 0.5;
		YScale 0.41666; //0.5/1.2
		-Solid;
		+NoBlockmap;
	}
	
	States
	{
		Spawn:
			PND2 [ 0 A_JumpIf (SmokeCounter == 0,"Fall"); //Gun
			PND2 ] 0 A_JumpIf (SmokeCounter == 1,"Fall"); //Rotor
		Fall:
			PND2 # 1
			{
				Roll += 20;
				If (!TestMobjZ(True) || GetZAt ()+1 >= Pos.Z)
				{
					If (SmokeCounter == 0) //Hit the floor.
					{
						Roll = 13;
						Return FindState ("Death",True);
					}
					Else
					{
						Roll = 0;
						Return FindState ("Death.Propeller",True);
					}
				}
				
				Return State(Null);
			}
			Loop;
		Death:
			PND2 [ -1;
			Stop;
		Death.Propeller:
			PND2 ^ -1;
			Stop;
	}
}
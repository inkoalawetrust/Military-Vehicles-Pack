//TODO:
//Add a landed mode where it takes off first. And maybe also idles by landing again.
//Add a master mode, where it can have a master that launched it, and then appropriately informs other actors of who is responsible for the attack, like a missile.

Class MVP_KamikazeDrone : MVP_BaseFlyer
{
	Default
	{
		//$Title Loitering Munition
		//$Category Vehicles/Panopticon
		//$Sprite PND1E1
		
		+KAI_Actor.NoTargetPrediction; //It's a flying bomb.
		Tag "Loitering Munition";
		KAI_Actor.ThreatLevelThreshold THREAT_ASSESS; //We don't care.
		KAI_Actor.FlightAcceleration 0.25;
		KAI_Actor.FlightDeceleration 0.5;
		KAI_Actor.FlightWrongDirFactor 2.5;
		+WindThrust;
		+Pushable;
		+SlidesOnWalls;
		-AvoidHazards; //You stupid.
		+SeeInvisible; //Fuck
		+FloatBob; //Scales with speed
		+LookAllAround; //Fuck x2
		+DontFollowPlayers; //Only when trying to kill them.
		
		Health 15;
		XScale 0.3;
		YScale 0.25; //0.3/1.2
		WoundHealth 8;
		ExplosionRadius 192;
		ExplosionDamage 128;
		FloatSpeed 3;
		FloatBobStrength 0.5;
		Mass 16; //Going by the convention that each integer is a kilo, this thing shouldn't be 16 kilos, but you know how Jazzy Doom is.
		Height 12;
		Radius 10;
		CameraHeight 5;
		Obituary "%o didn't hear the buzzing in time";
		ActiveSound "Vehicle/Drone/Buzz";
		DamageType "Explosive";
		MeleeRange 96; //Once in here, check if we will hit the target.
		Speed 12;
		FastSpeed 16;
		Friction 0.5;
		DamageFunction (Random(16,32));
		Decal "BulletChip"; //HACK: This isn't the explosions' decal, that's manually sprayed, nope, this is the decal of the shrapnel, not the one on the shrapnel puff!
		
		//The loitering munition is incredibly fragile to everything vehicles are normally protected against.
		RipLevelMin 0;
		DamageFactor "Melee", 0.8; //May change this to have melee damage do nothing to the vehicles, unless it exceeds a certain ammount.
		DamageFactor "Electric", 0.8;
		DamageFactor "ExplosiveImpact", 1.5;
		DamageFactor "Explosion", 1.5;
		DamageFactor "Explosive", 1.5;
		DamageFactor "Grenade", 1;
		DamageFactor "HitScan", 1; //The generic damage type of hitscan attacks.
		DamageFactor "Shrapnel", 0.8;
		DamageFactor "Fire", 1;
		DamageFactor "Crush", 1.5;
		DamageFactor "Disintegrate", 1.5;
		DamageFactor "Railgun", 2.0;
		DamageFactor "Falling", 1.25;
		DamageFactor "MarineHMG", 1;
		DamageFactor "LargeRifleBullet", 1; //Replaces MarineHMG.
		DamageFactor "MarineGrenade", 1;
		DamageFactor "MarineRifle", 1;
		DamageFactor "Autocannon", 1;
		DamageFactor "RifleBullet", 1;
		DamageFactor "SmallRifleBullet", 1;
	}
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		A_StartSound (ActiveSound,flags:CHANF_LOOPING,attenuation:1.5);
	}
	
	Override Void Tick()
	{
		KAI_Actor.Tick(); //It's a VERY basic vehicle.
		If (IsFrozen())
			Return;
		
		//Still keep the debug stuff though.
		If (DebugPoint)
				DebugPoint.SetOrigin (KAI_Math.IsEmptyVector3(NextMovePos) ? Pos : NextMovePos,True);
		
		//Scale visual bobbing with speed.
		FloatBobStrength = KAI_Math.LinearMap (Vel.Length(),0,6,Default.FloatBobStrength,0.05);
		FloatBobStrength = Clamp (FloatBobStrength,0,Default.FloatBobStrength);
		//Console.Printf ("Bob strength %.2f",FloatBobStrength);
		
		//Replace sprites to make it visually lean based on how high its' velocity is and where it's heading relative to its' current angle.
		If (CurState && !IsInState (Self,"Death"))
		{
			//HACK: Frames are offset by -1 to stop the states from flickering to the default state sprite for one tick on every state change.
			//KLUDGE: Oh also do NOT shift them by +1 instead, as that makes them basically switch every tick regardless of the state machine!
			Switch (Frame)
			{
				Case 3: //A
					Frame = LeanFlyerAround (4,8,0); // E, I, A
					Break;
				Case 0: //B
					Frame = LeanFlyerAround (5,9,1); // F, J, B
					Break;
				Case 1: //C
					Frame = LeanFlyerAround (6,10,2); // G, K, C
					Break;
				Case 2: //D
					Frame = LeanFlyerAround (7,11,3); // H, L, D
					Break;
				Default:
					Break;
			}
		}
		
		If (IsInState (Self,"See"))
		{
			//In seeking mode, so also detonate at any other enemy we bump to along the way.
			//HACK: This apparently just doesn't fucking work!
			//If (BlockingMobj && !IsInanimateObject(BlockingMobj) && IsActorHostile(BlockingMobj))
			//	ExplodeMissile (Null,BlockingMobj);
			
			//Slow down the closer we are to hitting a wall so that we can climb it, kinda like crude obstalce avoidance.
			If (Health > WoundHealth && LineTrace (Angle,Radius+144,Pitch,TRF_BLOCKSELF,Height/2,data:Front) && Front.HitLine)
			{
				Speed = KAI_Math.LinearMap (Front.Distance,0,Front.Distance,GetDefaultSpeed(GetClass()),2);
				console.printf ("hit a blocking line, so we scaled the speed to %.2f",speed);
			}
			Else
				Speed = GetDefaultSpeed(GetClass());
		}
	}
	
	Override Int TakeSpecialDamage (Actor Inflictor, Actor Source, Int Damage, Name DamageType)
	{
		Int Res = Super.TakeSpecialDamage (Inflictor,Source,Damage,DamageType);
		
		If (Source Is "MVP_KamikazeDrone" && !IsActorHostile(Source)) //Drones can't harm each other even with their shrapnel.
			Res = 0;
		
		Return Res;
	}
	
	//IDEA: I will probably make this generic to share it with any future flying NPCs like the larger quadcopter.
	//Forward: The frame to switch to when the actor is sufficiently propelling towards' its facing angle.
	//Back: Ditto, but when facing too far back.
	//Straight: The fallback frame to use when it's not moving too strongly either way.
	//Threshold: If the horizontal velocity of the actor is below this value, just make it face straight.
	//Diff: Using a dot product of the front of the actor and the actual XY direction. If the difference is at above this threshold, the actor is moving backwards.
	Int LeanFlyerAround (Int Forward, Int Back, Int Straight, Double Threshold = 3, Double Diff = -0.6)
	{
		Double Dir = Vel.XY Dot AngleToVector (Angle,Speed);
		
		If (Vel.XY.Length() < Threshold || (Abs(Dir)-Abs(Diff) <= Abs(Diff))) //Too slow, or facing more sideways than either the back or front, just face straight up.
			Return Straight;
		
		//The difference between the front and back is large enough that we are clearly going AWAY from where we're facing.
		If (Dir <= Diff)
			Return Back;
		//No it's not, we are moving forwards yippie.
		Else
			Return Forward;
		
		Return Straight; //Fallback
	}
	
	Void MVP_KamikazeChase ()
	{
		KAI_Chase_PreChecks();
		KAI_Chase_Retarget(0);
		
		Bool MovedAlready; Bool B;
		Int KMTFlags = KMT_3D;
		
		If (Health <= WoundHealth)
		{
			bSkyExplode = True;
			//FlightAcceleration = 0.5;
			Speed = GetDefaultSpeed(GetClass())*1.5; //Fly faster.
			
			A_Weave(4,4,2,2);
			Vector3 Front = Level.Vec3Offset(Pos,KAI_Math.AngleToVector3D(Angle,Pitch,Speed));
			KAI_MoveTowards (Front,1,TurnHorz,flags:KMTFlags,TurnVert);
			If (MovementBlockingLine || BlockingFloor || BlockingCeiling || Blocking3DFloor || BlockingMObj) //Explode on impact with anything.
				ExplodeMissile (BlockingLine,BlockingMobj,True);
			MovedAlready = True;
			
			If (!IsActorPlayingSound(CHAN_VOICE))
				A_StartSound ("Vehicle/Drone/Beep",CHAN_VOICE,attenuation:ATTN_STATIC);
			
			SpriteRotation += 10; //Visually spiralling out of control.
			
			//Smoke occasionally
			Actor Smoke = Random (0,255) < 64 ? Spawn ("MVP_DamageSmoke",Pos) : Null;
			If (Smoke)
			{
				Smoke.Alpha = 0.8;
				Smoke.Roll = FRandom(-180,180);
				Smoke.A_SetScale (FRandom(0.2,0.6));
			}
			
			//Spark randomly
			If (Random (0,255) < 6)
			{
				Vector3 Sparkle = (Random(Radius,-Radius),Random(Radius,-Radius),Random (0,Height));
				Actor Spark = Spawn ("MVP_Spark",Level.Vec3Offset(Pos,Sparkle));
				If (Spark)
				{
					Spark.Master = Self;
					MVP_Spark(Spark).Rel = Sparkle;
				}
			}
		}
		Else
		{
			FlightAcceleration = Default.FlightAcceleration;
			Speed = GetDefaultSpeed (GetClass());
			bSkyExplode = Default.bSkyExplode;
		}
		
		//Move to target, and also handle patrolling but then seeing a target.
		If (Target && Target != Goal && !MovedAlready)
		{
			KAI_MoveTowards (Target.Pos.PlusZ(Target.Height/2),1,TurnHorz,flags:KMTFlags,TurnVert);
			MovedAlready = True;
		}
		
		If (!MovedAlready)
		{
			MeleeRange = 32;
			[B, MovedAlready] = KAI_Chase_PatrolHandling ("Stand",1,TurnHorz,flags:KMTFlags,TurnVert);
			MeleeRange = Default.MeleeRange;
			If (b && goal) spawn ("kai_debugpoint",goal.pos);
			//if (goal)console.printf ("patrolling, goal is at %d %d %d, moved already %d, reached point %d",goal.pos,movedalready,b);
		}
		
		//In range to detonate.
		If (Target != Goal && KAI_CheckMeleeRange (Target,flags:CMR_3DDISTANCE))
		{
			LineTrace (Angle,Radius+MeleeRange,Pitch,TRF_BLOCKSELF,Height/2,data:Front);
			KAI_LOFRaycast.VisualizeTracePath (Pos.PlusZ(Height/2),Front.HitLocation,Front.Distance);
			
			//If we are on a collision course with the target or some other hostile, then we exploded and hit them.
			//NOTE: Kinda funny how a direct trace-based hit means that, without even having it in mind. I made the drone function like a shaped charge.
			If (Front.HitActor && (Front.HitActor == Target || !IsInanimateObject(Front.HitActor) && IsActorHostile (Front.HitActor)))
				{console.printf ("direct hit");ExplodeMissile (Null,Front.HitActor);}
			//Not on a direct course to the target or an enemy, do an airburst.
			Else
				ExplodeMissile();
		}
	}
	
	Void SpawnHitscanShrapnel (Int Amount, Int Damage = 2, Double Range = 512, Class <Actor> Puff = "MVP_ShrapnelPuff")
	{
		For (Int I = Amount; 0 <= I; I--)
			LineAttack (FRandom (0,360),Range*FRandom(0.5,1.5),FRandom (90,-90), Int(Damage*FRandom(0.75,1.25)) ,'Shrapnel',Puff, LAF_OVERRIDEZ,offsetz:Height/2);
	}
	
	FLineTraceData Front;
	Const TurnHorz = 15;
	Const TurnVert = 60;
	
	States
	{
		Spawn:
			PND1 ABCD 2 KAI_Look (KAIL_NOTEMPSTAND);
			Loop;
		See:
			PND1 AABBCCDD 1 MVP_KamikazeChase();
			Loop;
		Idle:
			PND1 AABBCCDD 1
			{
				KAI_Wander(16,768,anglelimit:TurnHorz,flags:KMT_3D,pitchlimit:TurnVert);
				KAI_Look (KAIL_NOTEMPSTAND);
			}
			Loop;
		Stand: //Before patrolling again
			PND1 AABBCCDD 1
			{
				KAI_Look ();
				Vel *= 0.90;
			}
			Loop;
		Death:
			TNT1 A 0
			{
				A_SprayDecal ("Scorch",Radius+MeleeRange,direction:KAI_Math.AngleToVector3D(Angle,Pitch,1));
				A_Stop();
				bDontThrust = bNoGravity = bNeverTarget = True;
				bFloatBob = False;
				A_NoBlocking();
				A_SetScale (3);
				A_SetRenderStyle (1.0,STYLE_ADD);
				MakeAlliesImmuneToExplosion (Self,ExplosionRadius);
				A_Explode (ExplosionDamage,ExplosionRadius,XF_HURTSOURCE|XF_CIRCULAR|XF_CIRCULARTHRUST|XF_NOTMISSILE,False,48);
				RemoveAllyExplosionImmunity();
				A_StartSound ("Vehicle/APC/AutocannonHit",attenuation:0.3);
				SpawnHitscanShrapnel (256,range:384);
				Actor Duster = Spawn ("MVP_GroundDustSpawner",Pos);
				Duster.ReactionTime = 192;
				Duster.Threshold = 192;
				Duster.Scale.X = 0.4;
				Duster.RadiusDamageFactor = 1.5;
			}
			GAXP ABCDEFGHIJ 4 Bright;
			Stop;
	}
}
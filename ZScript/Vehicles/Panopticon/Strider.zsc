//FIXME:
//The climb preperation frame (PNS1R1-8) has the foot spikes appearing over the top of the Striders' feet.
//IIRC one of the grenade frames is missing brightmaps.
//The AltDeath frame of the Strider fully fallen is cropped wrong.

//TODO:
//Make the strider run when its' target is too far.
//Don't forget to add the striders' ramming attack.
//Make it able to climb and crouch.

//HACK: Fucking christ shut up about overriding Tick() you bastard.
Class MVP_Humanoid : KAI_Humanoid
{
	Mixin MVP_DamageSmokeHandling;
	//Mixin MVP_SharedFunctions;
	//Mixin MVP_MarineFunctions;
	Mixin MVP_GenericShit;
}

Class MVP_Strider : MVP_Humanoid
{
	Default
	{
		//$Title Strider
		//$Category Vehicles/Panopticon
		//$Sprite PNS3A1
		Mass 100;
		Health 600;
		WoundHealth 200;
		XScale 0.8;
		YScale 0.666666; //0.8 / 1.2
		Radius 24;
		Height 88;
		DeathHeight 32;
		RipLevelMin 3;
		Speed 8;
		FriendlySeeBlocks 64;
		MeleeRange 64;
		Tag "R-11-B Pa≈ùegulo";
		
		+NoBlood;
		+DontCorpse;
		
		MVP_Humanoid.SmokeDelay 4;
		KAI_Actor.ThreatLevel THREAT_DANGEROUS;
		
		//Damage factors that act as the vehicles "armor".
		DamageFactor 0.75; //Generic damage factor for all damage.
		DamageFactor "Melee", 0.3;
		DamageFactor "Electric", 0.4;
		DamageFactor "ExplosiveImpact", 0.7;
		DamageFactor "Explosion", 0.7;
		DamageFactor "Explosive", 0.7;
		DamageFactor "Grenade", 0.7;
		DamageFactor "HitScan", 0.7; //The generic damage type of hitscan attacks.
		DamageFactor "Shrapnel", 0.4;
		DamageFactor "Fire", 0.6;
		DamageFactor "Crush", 1.3;
		DamageFactor "Disintegrate", 1.5;
		DamageFactor "Railgun", 2.0;
		DamageFactor "Falling", 0.0; //No
		
		//Vehicle damage factors
		DamageFactor "Autocannon", 0.8;
		DamageFactor "LargeRifleBullet", 0.9;
		DamageFactor "RifleBullet", 0.8;
		DamageFactor "SmallRifleBullet", 0.6;
	}
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		StriderMove.DetourFactor = 1.0;
		StriderMove.Attempts = 32;
		StriderMove.MaxSteps = 72;
		StriderMove.RunRad = 394;
		StriderMove.AngleLimit = 25;
		
		JumpPos = (Double.NaN,Double.NaN,Double.NaN);
		
		A_StartSound ("Vehicle/Drone/Motor",CHAN_BODY,CHANF_LOOPING,1,ATTN_STATIC);
		If (KAIHandler) Yapper = KAIHandler.GetNPCVoice ("Panopticon");
	}
	
	Override Void UserVariableDefaults()
	{
		Super.UserVariableDefaults();
		
		If (User_JumpRange == 0)
			User_JumpRange = 512;
	}
	
	Protected Double LastTickFallVel;
	
	Override Void Tick()
	{
		If (Vel.Z <= 0) LastTickFallVel = Abs(Vel.Z);
		Else LastTickFallVel = 0;
		kai_lofraycast.visualizetracepath (pos,vec3angle (256,angle),256);
		Super.Tick();
		
		If (IsFrozen()) Return;
		
		//Run fall impact code.
		//HACK: Yes this is a copy from KAI_BaseVehicle because it's like, the only feature 
		If (Vel.Z ~== 0 && LastTickFallVel && LastTickFallVel >= STRIDER_FALLTHRESHOLD && !IsDead(Self))
		{
			//Get victims under the vehicle.
			Array <Actor> IMFALLINGOVERHERE;
			Vector3 RealPos = Pos;
			SetOrigin (Pos.PlusZ(-LastTickFallVel),False); //Move down the vehicle as if it never stopped, to check for blocking actors in the way.
			BlockThingsIterator Blockers = BlockThingsIterator.Create(Self);
			While (Blockers.Next())
			{
				//Blocking actor found.
				If (Blockers.Thing && Blockers.Thing != Self && IsCollidable(Blockers.Thing,Self) && CheckHitboxIntersection(Self,Blockers.Thing))
					IMFALLINGOVERHERE.Push(Blockers.Thing);
			}
			SetOrigin (RealPos,False);
			
			//COPIED FROM THE MVP STOCK ONGROUNDIMPACT().
			//No actors that we were stopped by, so we probably hit level geometry.
			If (!IMFALLINGOVERHERE.Size())
			{
				Double Force = Mass * LastTickFallVel;
				//Impact sound
				A_StartSound ("Vehicle/Strider/Stomp",CHAN_AUTO,CHANF_OVERLAP,KAI_Math.LinearMap(Force,1000,2500,0.25,1.0),0.65);
				//Impact quake
				Double QuakeForce = KAI_Math.LinearMap(Force,50000,2500000,0.1,4.0);
				Double QuakeRange = KAI_Math.LinearMap(Force,50000,2500000,256,1024);
				Double QuakeThrust = KAI_Math.LinearMap(Force,50000,2500000,0.01,0.5);
				A_QuakeEx (QuakeForce/4,QuakeForce/4,QuakeForce/1,50,QuakeRange,QuakeRange,"",QF_SCALEDOWN|QF_GROUNDONLY|QF_AFFECTACTORS|QF_SHAKEONLY,
				rollintensity:QuakeForce,thrustmultiplier:QuakeThrust);
				//Impact dust
				Actor Duster = Spawn ("MVP_GroundDustSpawner",Pos);
				//Pass parameters to spawner.
				Duster.RadiusDamageFactor = 0;
				Duster.ReactionTime = KAI_Math.LinearMap(Force,100,25000,1,256);
				Duster.Threshold = Radius*1.55;
				Duster.Scale *= 0.5;
			}
			//We hit some actors, crush them and lose some fall speed in exchange (Very realistic and sophisticated physics simulation).
			Else
			{
				Double PostCrushVel = LastTickFallVel;
				//Squish
				Double VelReduction = KAI_Math.LinearMap (Mass,10,25000,10,0.25);
				VelReduction = Clamp (VelReduction,0.25,INT.MAX);
				ForEach (Bug : IMFALLINGOVERHERE)
				{
					Double Force = Mass * PostCrushVel;
					Int ImpactDamage = Force/300;
					Bug.DamageMobj (Self,Self,ImpactDamage,'Crush');
					PostCrushVel -= VelReduction*(Bug.Mass/100); //Reduce fall speed for every bug squashed before applying it back in.
					PostCrushVel = Clamp (PostCrushVel,0,INT.MAX);
					//Play impact sound on each victim based on impact velocity.
					Bug.A_StartSound (Bug.bNoBlood ? "SFX/MetalHit" : "SFX/FleshHit",CHAN_AUTO,CHANF_OVERLAP,KAI_Math.LinearMap(Force,100,2500000,0.075,1.0),0.65);
				}
				
				Vel.Z = -PostCrushVel;
			}
			
			LastTickFallVel = 0;
		}
	}
	
	Override Bool SpawnDamageSmoke()
	{
		Bool Dead = IsDead(Self);
		If (!DeathFlames && Dead) A_StopSound (CHAN_VOICE); //Flames stopped.
		If (!DeathFlames && Dead|| !Super.SpawnDamageSmoke() && !Dead || bIceCorpse) Return False;
		
		If (DeathFlames)
			DeathFlames--;
		
		If (Random (0,255) < 3)
			Spawn ("MVP_Spark",Level.Vec3Offset(Pos,(FRandom (Radius,Radius),FRandom (Radius,-Radius),FRandom (0,Height))));
		
		console.printf ("got %d flames left",deathflames);
		Int CardAng = GetNearestCardinalAngle(False);
		Vector3 SpawnPos = !Dead ? Vec3Angle (32,CardAng) : Vec3Angle (32,CardAng+135);
		If (IsInState (Self,"AltDeath"))
			SpawnPos = Vec3Angle (48,CardAng-45);
		
		If (!Dead) //Spawn smoke behind engine
			SpawnPos.XY = KAI_Math.RotateAround (Pos.XY,SpawnPos.XY,SpriteRotation);
		Let FX = Dead ? "MVP_BrightFireParticle" : "MVP_DamageSmoke";
		Int Times = !Dead ? 1 : 3;
		For (Int I; I < Times; I++)
		{
			If (!Dead)
				SpawnPos = Level.Vec3Offset (SpawnPos,(FRandom(-16,16),FRandom(-16,16),72));
			Else
				SpawnPos = Level.Vec3Offset (SpawnPos,(FRandom(-16,16),FRandom(-16,16),24));
			
			For (Int I; I < 4; I++)
			{
				Actor Smoke = Spawn (FX,SpawnPos);
				Smoke.Roll = FRandom(-180,180);
				If (!Dead) Smoke.A_SetScale (FRandom(0.25,0.8));
				Else Smoke.A_SetScale (FRandom(0.25,0.5));
				Smoke.Vel.Z = !Dead ? FRandom (1,4) : FRandom (4,8);
			}
		}
		
		Return True;
	}
	
	Void MVP_StriderJump (Vector3 Where, JFlags Flags = 0)
	{
		If (Level.Vec3Diff (Pos,Where).Length() > User_JumpRange) //Too far to jump.
			Return;
		
		JumpFlags = Flags;
		JumpPos = Where;
		SetStateLabel ("Jump");
	}
	
	//Strider loves lean(ing)
	//Returns one of the sprite frames passed, and also a JumpDir
	Int, Int MVP_StriderLean (Int Forward, Int Left, Int Right, Int Back, Bool IgnoreVel = False)
	{
		Double Dir = Vel.XY.Unit() Dot AngleToVector (Angle);
		If (IgnoreVel)
			{console.printf ("ignoring actual speed");Dir = AngleToVector (GetAngleToPos(JumpPos,0)) Dot AngleToVector (Angle);}
		console.printf ("leandir %.2f",dir);
		If (Dir <= -0.5) //Facing back
			{console.printf ("going back");Return Back, JDIR_BACK;}
		Else If (Dir >= 0.5) //Facing forward
			{console.printf ("going forward"); Return Forward, JDIR_NORMAL;}
		Else If (Dir <= 0.5 && Dir >= -0.5) //Facing orthogonally, or in actual english, to the side
		{
			//console.printf ("facing sideways");
			If (DeltaAngle (Angle,GetAngleToPos(JumpPos,0)) < 20)
				{console.printf ("going left"); Return Left, JDIR_LEFT;}
			Else
				{console.printf ("going right"); Return Right, JDIR_RIGHT;}
		}
		
		Return Forward, JDIR_NORMAL;
	}
	
	Protected Int MVP_StriderLeanIndex (Int Dir)
	{
		Switch (Dir)
		{
			Case JDIR_LEFT:
			Case JDIR_RIGHT:
			Case JDIR_BACK:
				Return GetSpriteIndex ('PNS1');
		}
		Return GetSpriteIndex ('PNS0');
	}
	
	KAIMoveParams StriderMove;
	KAI_Voice Yapper;
	Int DeathFlames;
	
	//Jumping variables.
	Vector3 JumpPos;
	Int JumpFlags; //Flags used for every jump in progress. Then cleared once the jump's done.
	Int JumpDir; //The direction the strider is jumping at.
	Const STRIDER_FALLTHRESHOLD = 8;
	
	Enum JumpDirs //The direction it starts off jumping to, determined by the angle difference between where it wants to go and its' angle at the time of jumping.
	{
		JDIR_NORMAL, //Standard nondescript jump
		JDIR_LEFT,
		JDIR_RIGHT,
		JDIR_RUN, //Running jump //MAYDO: Since the jump direction is determined dynamically, make this a flag instead?
		JDIR_BACK, //Jump backwards
	}
	
	//BUG: FACEDIRECTION causes a weird bug where the jump sprites sometimes don't render rotations? Wtf? Also it doesn't even seem to properly angle to JumpPos...
	Enum JFlags
	{
		SJUMP_FACEDIRECTION = 1 << 0, //Constantly update the striders' in-flight sprites to match the movement direction.
		SJUMP_FAST			= 1 << 1, //Jump faster. Used for running jumps and dodges.
	}
	
	Double User_JumpRange;
	
	States
	{
		StriderSprites: //Do I even need to do this still? Not in the mood to find out.
			PNS1 ABCDEFGHIJKLMNOPQRSTUVWXYZ[] 0;
		Spawn:
			PNS3 A 1 KAI_Look ();
			Loop;
		See:
			PNS0 ABCDEF 4
			{
				If (Frame == 1 || Frame == 4) //Play stomp sound on frames where it steps on the ground.
					A_StartSound ("Vehicle/Strider/Stomp",volume:FRandom(0.05,0.15));
				
				KAI_Wander (32,384,anglelimit:25);
				if (random (0,255) < 8)
				{
					vector3 where = FindRandomMovePos (self.pos,8,checkrad:384);
					//where = vec3angle (randompick(256,-256),RandomPick(90,-90,0,0));
					KAI_DebugPointDelay.KAI_TempPointSpawn(where,35);
					MVP_StriderJump (where, (random (true, false) == true) ? SJUMP_FAST : 0);
				}
			}
			Loop;
		
		//JUMP STATES
		//You can check if the strider is jumping by seeing if they are in any Jump.##### state.
		Jump:
			Jump.Start:
				#### # Random(5,12) Fast
				{
					If (JumpFlags & SJUMP_FAST)
						Tics = Random (3,7);
					
					[Frame, JumpDir] = MVP_StriderLean (24, 7, 6, 0, True); //Y, H, G, A
					Sprite = MVP_StriderLeanIndex (JumpDir);

					A_StartSound ("Vehicle/Strider/Motor",flags:CHANF_OVERLAP);
				}
				#### Y 0 KAI_JumpTo (JumpPos,maxlength:User_JumpRange);
			Jump.Loop:
				#### # 1
				{
					[Frame, JumpDir] = MVP_StriderLean (25, 10, 8, 1); //Z, K, I, B
					Sprite = MVP_StriderLeanIndex(JumpDir);
				}
				#### # 1
				{
					[Frame, JumpDir] = MVP_StriderLean (25, 10, 8, 1); //Z, K, I, B
					Sprite = MVP_StriderLeanIndex(JumpDir);
					If (JumpFlags & SJUMP_FACEDIRECTION)
						{Angle += GetAngleToPos (JumpPos,StriderMove.AngleLimit);console.printf ("aiming to %.2f %.2f %.2f",jumppos);}
					//Going down, or maybe we already landed.
					If (Vel.Z <= -2 || bOnMobj || Pos.Z <= FloorZ || Pos.Z <= GetZAt ())
						Return FindState ("Jump.Loop.Down",True);
					Return State (Null);
				}
				Goto Jump.Loop+1;
			Jump.Loop.Down:
				//Coming down frame.
				#### # 1
				{
					If (JumpFlags & SJUMP_FACEDIRECTION)
						{Angle += GetAngleToPos (JumpPos,StriderMove.AngleLimit);console.printf ("aiming to %.2f %.2f %.2f",jumppos);}
					[Frame, JumpDir] = MVP_StriderLean (26, 8, 10, 3); //[, I, K, D
					Sprite = MVP_StriderLeanIndex (JumpDir);
					If (bOnMobj || Pos.Z <= FloorZ || Pos.Z <= GetZAt ()) //The eagle has landed.
					{
						bNoFriction = Default.bNoFriction; //Do friction again.
						Return FindState ("Jump.End",True);
					}
					Return State (Null);
				}
				Loop;
			Jump.End: //All comes back here.
				#### # 8
				{
					If (JumpFlags & SJUMP_FAST)
						Tics = 4;
					
					Frame = MVP_StriderLean (28, 13, 12, 5, True); //], N, M, F
					Sprite = MVP_StriderLeanIndex (JumpDir);
					
					JumpFlags = 0;
					JumpDir = 0;
					JumpPos = (Double.NaN,Double.NaN,Double.NaN);
					NextMovePos = (Double.NaN,Double.NaN,Double.NaN);
				}
				Goto See;
		//TODO: Add running death state later.
		Death:
			PNS9 A 8
			{
				Tics = Random (4,10);
				If (Random (1,4) == 2)
					DeathFlames = Random (80,150)*10;
				
				A_StopSound (CHAN_BODY);
				A_StartSound ("SFX/Fire",CHAN_VOICE,CHANF_LOOPING,0.5,1.1);
				Actor Boom = Spawn ("MVP_Explosion",Pos.PlusZ(48));
				Boom.Scale *= FRandom (1.8f,2.2f);
				Boom.SetDamage (192);
				Boom.MaxTargetRange = 256;
				Boom.MeleeRange = Radius+64;
				Boom.bNoGravity = True;
				Boom.bGetOwner = True;
				Boom.Target = Self; //Does it even matter if we're gone? Very philosophical.
				
				SmokeCounter = Random (8,16);
				Bool B; Actor Debris;
				For (Int I; I <= SmokeCounter; I++)
				{
					[B, Debris] = A_SpawnItemEx ("MVP_DiCokkaDebris",FRandom (Radius,-Radius),FRandom(Radius,-Radius),FRandom (Height-24,Height+24),FRandom (-6,6),FRandom (-6,6),FRandom (2,8));
					If (Debris)
					{
						Debris.Scale *= FRandom (0.1,0.8);
						Debris.bXFlip = Random (False,True);
					}
				}
				
				If (Random (True, False) == True)
					Return FindState ("AltDeath");
				Return State (Null);
			}
			PNS9 B 4;
			PNS9 C 3;
			PNS9 D -1
			{
				If (GetZAt() <= Pos.Z)
				{
					A_StartSound ("SFX/MetalHit");
					Actor Duster = Spawn ("MVP_GroundDustSpawner",Pos);
					//Pass parameters to spawner.
					Duster.RadiusDamageFactor = 0;
					Duster.ReactionTime = 32;
					Duster.Threshold = Radius*2.25;
					Duster.Scale *= 0.25;
				}
			}
			Stop;
		//URGENT: TODO: Fix the fucking cropping. Fucking great, can't wait for my entire system to break a THIRD time because of the Strider sprites!!!!!
		AltDeath:
			PNS9 EF 4;
			PNS9 G -1
			{
				If (GetZAt() <= Pos.Z)
				{
					A_StartSound ("SFX/MetalHit");
					Actor Duster = Spawn ("MVP_GroundDustSpawner",(Vec2Angle(24,Angle),Pos.Z));
					//Pass parameters to spawner.
					Duster.RadiusDamageFactor = 0;
					Duster.ReactionTime = 32;
					Duster.Threshold = Radius*2.25;
					Duster.Scale *= 0.5;
				}
			}
			Stop;
		XDeath:
			PNS9 K 8
			{
				Tics = Random (4,10);
				
				A_StopSound (CHAN_BODY);
				Actor Boom = Spawn ("MVP_Explosion",Pos.PlusZ(48));
				Boom.Scale *= FRandom (2.75f,3.5f);
				Boom.SetDamage (256);
				Boom.MaxTargetRange = 384;
				Boom.MeleeRange = Radius+64;
				Boom.bNoGravity = True;
				Boom.bGetOwner = True;
				Boom.Target = Self; //Does it even matter if we're gone? Very philosophical.
				
				Bool Alt = Random (True, False);
				Bool B; Actor Debris;
				//No gibs.
				If (Random (True,False) == True)
				{
					SmokeCounter = Random (48,64);
					
					For (Int I; I <= SmokeCounter; I++)
					{
						[B, Debris] = A_SpawnItemEx ("MVP_DiCokkaDebris",FRandom (Radius,-Radius),FRandom(Radius,-Radius),FRandom (Height-24,Height+24),FRandom (-6,6),FRandom (-6,6),FRandom (2,8));
						If (Debris)
						{
							Debris.Scale *= FRandom (0.1,0.8);
							Debris.bXFlip = Random (False,True);
						}
					}
				}
				Else
				{
					If (!Alt) //No head gib if we are going the XDeath where the whole body is destroyed.
					{
						[B, Debris] =  A_SpawnItemEx ("MVP_StriderHeadGib",zofs:64,FRandom (4,-4),FRandom (-4,-8),FRandom (6,16));
						If (Debris)
						{
							Debris.SmokeCounter = Random (2,6);
							Debris.Master = Self;
						}
					}
					[B, Debris] =  A_SpawnItemEx ("MVP_StriderArmGib",zofs:64,FRandom (-6,-16),FRandom (-6,-12),FRandom (2,8));
					If (Debris)
					{
						Debris.SmokeCounter = Random (2,6);
						Debris.Master = Self;
					}
				}
				
				If (Alt)
					Return FindState ("AltXDeath");
				Return State (Null);
			}
			PNS9 LM 4;
			PNS9 N -1
			{
				A_StartSound ("SFX/MetalHit");
				Actor Duster = Spawn ("MVP_GroundDustSpawner",(Vec2Angle(-24,Angle),Pos.Z));
				//Pass parameters to spawner.
				Duster.RadiusDamageFactor = 0;
				Duster.ReactionTime = 32;
				Duster.Threshold = Radius*2.25;
				Duster.Scale *= 0.5;
			}
			Stop;
		AltXDeath:
			PNS9 OPQ 3;
			PNS9 R -1;
			Stop;
	}
}

Class MVP_StriderHeadGib : Actor
{
	Default
	{
		Radius 24;
		Height 32;
		XScale 0.8;
		YScale 0.666666; //0.8 / 1.2
		Mass 250;
		+Solid;
		+Shootable;
		//+NoBlockmap;
		+BloodlessImpact;
		+Blasted;
	}
	
	Override Bool CanCollideWith (Actor Other, Bool Passive)
	{
		If (Other && (Other Is GetClassName() || Other == Master))
			Return False;
		Return Super.CanCollideWith (Other, Passive);
	}
	
	States
	{
		Spawn:
			PNS9 STU 4
			{
				Tics = SmokeCounter;
				If (!TestMobjZ(True) || GetZAt ()+1 >= Pos.Z)
					Return FindState("Death");
				
				Return State(Null);
			}
			Loop;
		Death:
			PNS9 V -1
			{
				A_StartSound ("SFX/MetalHit");
				Actor Duster = Spawn ("MVP_GroundDustSpawner",pOS);
				//Pass parameters to spawner.
				Duster.RadiusDamageFactor = 0;
				Duster.ReactionTime = 32;
				Duster.Threshold = Radius*2.25;
				Duster.Scale *= 0.5;
			}
			Stop;
	}
}

Class MVP_StriderArmGib : MVP_StriderHeadGib
{
	Default
	{
		Radius 12;
		Height 16;
		Mass 50;
	}
	States
	{
		Spawn:
			PNS9 XYY 4
			{
				Tics = SmokeCounter;
				If (!TestMobjZ(True) || GetZAt ()+1 >= Pos.Z)
					Return FindState("Death");
				
				Return State(Null);
			}
			Loop;
		Death:
			PNS9 Z -1
			{
				SpriteOffset.Y -= 3;
				A_StartSound ("SFX/MetalHit");
				Actor Duster = Spawn ("MVP_GroundDustSpawner",pOS);
				//Pass parameters to spawner.
				Duster.RadiusDamageFactor = 0;
				Duster.ReactionTime = 32;
				Duster.Threshold = Radius*1.5;
				Duster.Scale *= 0.5;
			}
			Stop;
	}
}
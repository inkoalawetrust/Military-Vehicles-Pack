//FIXME:
//The climb preperation frame (PNS1R1-8) has the foot spikes appearing over the top of the Striders' feet.
//IIRC one of the grenade frames is missing brightmaps.
//The AltDeath frame of the Strider fully fallen is cropped wrong.

//TODO:
//Make the strider run when its' target is too far.
//Don't forget to add the striders' ramming attack.
//Make it able to climb and crouch.

//HACK: Fucking christ shut up about overriding Tick() you bastard.
Class MVP_Humanoid : KAI_Humanoid
{
	Mixin MVP_DamageSmokeHandling;
	//Mixin MVP_SharedFunctions;
	//Mixin MVP_MarineFunctions;
	Mixin MVP_GenericShit;
	Int SearchTime;
	Int ChaseTimer;
	
	Void HandleChaseTimer()
	{
		//Stop chasing your target after it's out of sight for long enough.
		If (SearchTime > 0)
		{
			If (ChaseTimer >= SearchTime)
			{
				A_ClearTarget();
				ChaseTimer = 0;
				//Vehicles ordered to stay also go back to standing still once the timer runs out.
				If (CurrentOrder == ORDER_STAY)
				{
					SetStateLabel ("Spawn");
					Return;
				}
			}
			
			If (!IsPatrolling(Self))
			{
				If (!Target || Target && !CheckSight (Target,SF_SEEPASTBLOCKEVERYTHING))
					ChaseTimer++;
				//Target is visible again, reset the timer.
				Else
					ChaseTimer = 0;
			}
		}
	}
}

Class MVP_Strider : MVP_Humanoid
{
	Default
	{
		//$Title Strider
		//$Category Vehicles/Panopticon
		//$Sprite PNS3A1
		Mass 1000;
		Health 600;
		WoundHealth 200;
		XScale 0.8;
		YScale 0.666666; //0.8 / 1.2
		Radius 24;
		Height 88;
		DeathHeight 32;
		RipLevelMin 3;
		Speed 10;
		FastSpeed 14;
		FriendlySeeBlocks 64;
		MeleeRange 64;
		Tag "R-11-B Pa≈ùegulo";
		
		+NoBlood;
		+DontCorpse;
		
		MVP_Humanoid.SmokeDelay 4;
		KAI_Actor.ThreatLevel THREAT_DANGEROUS;
		
		//Damage factors that act as the vehicles "armor".
		DamageFactor 0.75; //Generic damage factor for all damage.
		DamageFactor "Melee", 0.3;
		DamageFactor "Electric", 0.4;
		DamageFactor "ExplosiveImpact", 0.7;
		DamageFactor "Explosion", 0.7;
		DamageFactor "Explosive", 0.7;
		DamageFactor "Grenade", 0.7;
		DamageFactor "HitScan", 0.7; //The generic damage type of hitscan attacks.
		DamageFactor "Shrapnel", 0.4;
		DamageFactor "Fire", 0.6;
		DamageFactor "Crush", 1.3;
		DamageFactor "Disintegrate", 1.5;
		DamageFactor "Railgun", 2.0;
		DamageFactor "Falling", 0.0; //No
		
		//Vehicle damage factors
		DamageFactor "Autocannon", 0.8;
		DamageFactor "LargeRifleBullet", 0.9;
		DamageFactor "RifleBullet", 0.8;
		DamageFactor "SmallRifleBullet", 0.6;
	}
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		SearchTime = User_ChaseTime;
		
		StriderMove.DetourFactor = 0.6;
		StriderMove.Attempts = 32;
		StriderMove.MaxSteps = 72;
		StriderMove.RunRad = 394;
		StriderMove.AngleLimit = 25;
		//IDEA: Make it run behind corners.
		
		JumpPos = (Double.NaN,Double.NaN,Double.NaN);
		CoverPos = (Double.NaN,Double.NaN,Double.NaN);
		
		A_StartSound ("Vehicle/Drone/Motor",CHAN_BODY,CHANF_LOOPING,1,ATTN_STATIC);
		If (KAIHandler) Yapper = KAIHandler.GetNPCVoice ("Panopticon");
	}
	
	Override Void UserVariableDefaults()
	{
		Super.UserVariableDefaults();
		
		If (User_JumpRange == 0)
			User_JumpRange = 512;
		If (User_ChaseTime == 0)
			User_ChaseTime = User_ChaseTime = (35/4)*30;
		//URGENT: DEBUG
		User_NoCover = True;
	}
	
	Protected Double LastTickFallVel;
	
	Override Void Tick()
	{
		If (Vel.Z <= 0) LastTickFallVel = Abs(Vel.Z);
		Else LastTickFallVel = 0;
		
		Super.Tick();
		
		If (IsFrozen()) Return;
		
		//Run fall impact code.
		//HACK: Yes this is a copy from KAI_BaseVehicle because it's like, the only feature 
		If (Vel.Z ~== 0 && LastTickFallVel && LastTickFallVel >= STRIDER_FALLTHRESHOLD && !IsDead(Self))
		{
			//Get victims under the vehicle.
			Array <Actor> IMFALLINGOVERHERE;
			Vector3 RealPos = Pos;
			SetOrigin (Pos.PlusZ(-LastTickFallVel),False); //Move down the vehicle as if it never stopped, to check for blocking actors in the way.
			BlockThingsIterator Blockers = BlockThingsIterator.Create(Self);
			While (Blockers.Next())
			{
				//Blocking actor found.
				If (Blockers.Thing && Blockers.Thing != Self && IsCollidable(Blockers.Thing,Self) && CheckHitboxIntersection(Self,Blockers.Thing))
					IMFALLINGOVERHERE.Push(Blockers.Thing);
			}
			SetOrigin (RealPos,False);
			
			//COPIED FROM THE MVP STOCK ONGROUNDIMPACT().
			//No actors that we were stopped by, so we probably hit level geometry.
			If (!IMFALLINGOVERHERE.Size())
			{
				Double Force = Mass * LastTickFallVel;
				//Impact sound
				A_StartSound ("Vehicle/Strider/Stomp",CHAN_AUTO,CHANF_OVERLAP,KAI_Math.LinearMap(Force,1000,2500,0.25,1.0),0.65);
				//Impact quake
				Double QuakeForce = KAI_Math.LinearMap(Force,50000,2500000,0.1,4.0);
				Double QuakeRange = KAI_Math.LinearMap(Force,50000,2500000,256,1024);
				Double QuakeThrust = KAI_Math.LinearMap(Force,50000,2500000,0.01,0.5);
				A_QuakeEx (QuakeForce/4,QuakeForce/4,QuakeForce/1,50,QuakeRange,QuakeRange,"",QF_SCALEDOWN|QF_GROUNDONLY|QF_AFFECTACTORS|QF_SHAKEONLY,
				rollintensity:QuakeForce,thrustmultiplier:QuakeThrust);
				//Impact dust
				Actor Duster = Spawn ("MVP_GroundDustSpawner",Pos);
				//Pass parameters to spawner.
				Duster.RadiusDamageFactor = 0;
				Duster.ReactionTime = KAI_Math.LinearMap(Force,100,25000,1,256);
				Duster.Threshold = Radius*1.55;
				Duster.Scale *= 0.5;
			}
			//We hit some actors, crush them and lose some fall speed in exchange (Very realistic and sophisticated physics simulation).
			Else
			{
				Double PostCrushVel = LastTickFallVel;
				//Squish
				Double VelReduction = KAI_Math.LinearMap (Mass,10,25000,10,0.25);
				VelReduction = Clamp (VelReduction,0.25,INT.MAX);
				ForEach (Bug : IMFALLINGOVERHERE)
				{
					Double Force = Mass * PostCrushVel;
					Int ImpactDamage = Force/300;
					Bug.DamageMobj (Self,Self,ImpactDamage,'Crush');
					PostCrushVel -= VelReduction*(Bug.Mass/100); //Reduce fall speed for every bug squashed before applying it back in.
					PostCrushVel = Clamp (PostCrushVel,0,INT.MAX);
					//Play impact sound on each victim based on impact velocity.
					Bug.A_StartSound (Bug.bNoBlood ? "SFX/MetalHit" : "SFX/FleshHit",CHAN_AUTO,CHANF_OVERLAP,KAI_Math.LinearMap(Force,100,2500000,0.075,1.0),0.65);
				}
				
				Vel.Z = -PostCrushVel;
			}
			
			LastTickFallVel = 0;
		}
	}
	
	Override Bool SpawnDamageSmoke()
	{
		Bool Dead = IsDead(Self);
		If (!DeathFlames && Dead) A_StopSound (CHAN_VOICE); //Flames stopped.
		If (!DeathFlames && Dead|| !Super.SpawnDamageSmoke() && !Dead || bIceCorpse) Return False;
		
		If (DeathFlames)
			DeathFlames--;
		
		If (Random (0,255) < 3)
			Spawn ("MVP_Spark",Level.Vec3Offset(Pos,(FRandom (Radius,Radius),FRandom (Radius,-Radius),FRandom (0,Height))));
		
		console.printf ("got %d flames left",deathflames);
		Int CardAng = GetNearestCardinalAngle(False);
		Vector3 SpawnPos = !Dead ? Vec3Angle (32,CardAng) : Vec3Angle (32,CardAng+135);
		If (IsInState (Self,"AltDeath"))
			SpawnPos = Vec3Angle (48,CardAng-45);
		
		If (!Dead) //Spawn smoke behind engine
			SpawnPos.XY = KAI_Math.RotateAround (Pos.XY,SpawnPos.XY,SpriteRotation);
		Let FX = Dead ? "MVP_BrightFireParticle" : "MVP_DamageSmoke";
		Int Times = !Dead ? 1 : 3;
		For (Int I; I < Times; I++)
		{
			If (!Dead)
				SpawnPos = Level.Vec3Offset (SpawnPos,(FRandom(-16,16),FRandom(-16,16),72));
			Else
				SpawnPos = Level.Vec3Offset (SpawnPos,(FRandom(-16,16),FRandom(-16,16),24));
			
			For (Int I; I < 4; I++)
			{
				Actor Smoke = Spawn (FX,SpawnPos);
				Smoke.Roll = FRandom(-180,180);
				If (!Dead) Smoke.A_SetScale (FRandom(0.25,0.8));
				Else Smoke.A_SetScale (FRandom(0.25,0.5));
				Smoke.Vel.Z = !Dead ? FRandom (1,4) : FRandom (4,8);
			}
		}
		
		Return True;
	}
	
	Void MVP_StriderJump (Vector3 Where, JFlags Flags = 0)
	{
		If (Level.Vec3Diff (Pos,Where).Length() > User_JumpRange) //Too far to jump.
			Return;
		
		JumpFlags = Flags;
		JumpPos = Where;
		SetStateLabel ("Jump");
	}
	
	//TODO: Add handling moving away from things by jumping.
	Void MVP_StriderChase()
	{
		KAI_Chase_PreChecks();
		If (IsDead (Target)) Target = Null;
		KAI_Chase_Retarget(0,True);
		
		Bool MovedAlready; Bool B;
		Int KMTFlags = 0;
		
		//DETERMINE IF WE SHOULD BE MOVING AWAY FROM THE TARGET.
		Bool RunAway = (!bNoFear && (IsFrightening (Target) || bFrightened)); //Run away from spooky actors, or maybe we're just a little bitch.
		//If we're set to run away from targets over our threat threshold that get too close, do so.
		Double RunRange = User_RetreatDistance;
		Int TargetLevel;
		If (Target)
		{
			RunRange += Target.Radius;
			TargetLevel = AssessThreatLevel(Target, True);
		}
		
		Bool TargetInSight = CheckSight (Target,SF_IGNOREWATERBOUNDARY);
		If (ReverseSteps > 0) RunAway = True;
		Bool LockedIn = bChaseGoal && Goal; //Don't run away if you have a target but are also patrolling in bChaseGoal mode. Since you do that by just flying around.
		Bool BigThreat = (ThreatLevelThreshold != THREAT_ASSESS && TargetLevel >= ThreatLevelThreshold); //Target's threat level is over the threshold.
		//TODO: Just jump from big threat instead.
		If (RunRange > 0 && !bNoFear && Target && Target != Goal && !LockedIn && !RunAway && BigThreat && Distance3DSquared(Target) <= RunRange*RunRange && TargetInSight)
			RunAway = True;
		
		//Avoid melee attackers.
		If (!LockedIn && !RunAway && Target && (bAvoidMelee || Level.Info.Flags3 & LEVEL3_AVOIDMELEE))
		{
			Bool IsMeleeAttacker;
			If (!Target.Player && Target.MeleeState) //Melee NPC
			{
				Double Dist = (Target.MeleeRange + Target.Radius)*2;
				IsMeleeAttacker = Distance3DSquared (Target) < Dist*Dist;
			}
			Else If (Target.Player && Target.Player.ReadyWeapon && Target.Player.ReadyWeapon.bMeleeWeapon) //Melee player
				IsMeleeAttacker = Distance3DSquared(Target) <= 192*192;
			
			RunAway = IsMeleeAttacker;
		}
		
		If (Health > WoundHealth) //Ignore weak hazards if not weak yourself.
		{
			For (Int I = Hazards.Size()-1; I >= 0; I--)
			{
				If (Hazards[I] && Hazards[I].Level <= HazardInfo.HAZARD_MEDIUM)
					Hazards.Delete(I);
			}
		}
		
		//Cover located, go there
		//TODO: Make it dodge by ducking when in cover.
		If (!KAI_Math.IsEmptyVector3(CoverPos) && !User_NoCover)
		{
			If (!KAI_Math.IsEmptyVector3 (CoverPos) && NewPosStepCount <= 128 && Level.Vec3Diff (Pos,CoverPos).Length() >= 24)
			{console.printf ("strider taking cover");
				KAI_MoveTowards (CoverPos,StriderMove.DetourFactor/2,StriderMove.AngleLimit); //No zigzag.
				KAI_DebugPointDelay.KAI_TempPointSpawn(coverpos,8);
				NewPosStepCount++;
				Return;
			}
			Else If (!NewPosStepCount)
			{
				CoverPos = (Double.NaN,Double.NaN,Double.NaN);
				//DodgePos = (Double.NaN,Double.NaN,Double.NaN);
				NewPosStepCount = 0;
				A_FaceTarget();
				A_StopSound (CHAN_BODY);
				SetStateLabel ("Idle.Cover");
				Return;
			}
			Else
			{
				CoverPos = (Double.NaN,Double.NaN,Double.NaN);
				//DodgePos = (Double.NaN,Double.NaN,Double.NaN);
				NewPosStepCount = 0;
			}
		}
		//Find nearby cover.
		Else If (!User_NoCover)
		{
			CoverPos = KAI_FindNearbyCover(384,Radius*2,Target,False,128,(72,192),(64,48),(Radius,30,100),Self);
		}
		
		/*NearestEnemy = FindNearestEnemy (256);
		
		If (NearestEnemy)
		{
			RunAway = True;
			ReverseSteps = Random (2,8);
		}*/
		
		HazardInfo Haz;
		If (!RunAway) Haz = GetStrongestHazard(Hazards); //Avoid strongest hazard around if not already busy with backing off from a nearby enemy.
		
		//Keep different distances for targets, by reversing
		If (!LockedIn && !RunAway && Target && Target != Goal)
		{
			Double Dist = 0;
			Switch (TargetLevel)
			{
				Case THREAT_UNSTOPPABLE:
					Dist = 1024;
					Break;
				Case THREAT_SUPERDANGER:
					Dist = 896;
					Break;
				Case THREAT_VERYDANGEROUS:
					Dist = 640;
					Break;
				Case THREAT_DANGEROUS:
					Dist = 448;
					Break;
				//Just in case the threshold is changed ^^^^^
				Case THREAT_ABOVENORMAL:
					Dist = 256;
					Break;
				Case THREAT_NORMAL:
					Dist = 192;
					Break;
				Case THREAT_MILD:
				Case THREAT_LOW:
					Dist = 72;
					Break;
				Case THREAT_VERYLOW:
				Default:
					Break;
			}
			If (Dist > 0) Dist += Target.Radius;
			If (Health <= WoundHealth) //Keep double distance when hurt.
				Dist *= 2;
			
			Double TargDist = Distance3D (Target);
			//MAYDO: Make it ignore this if it can melee the target.
			If (ReverseSteps == 0 && TargDist <= Dist+Radius) //Too close to target, reverse.
			{
				RunAway = True; //In case we otherwise wouldn't run away, like if retreatrange is turned off.
				ReverseSteps = Random (8,16);
			}
			
			//Run from target if hazard isn't closer.
			If (Dist && TargDist <= Dist && !(Haz && Distance3D (Target) <= GetHazardDistance (Haz)))
			{
				RunAway = True;
				Haz = Null; //Signify that we shouldn't run from a hazard later in the function.
			}
		}
		//Also check for scary hazards.
		If (Haz)
		{
			RunAway = True;
			ReverseSteps = 0; //Just run away. //MAYDO: Or jump away.
		}
		
		//Dodge projectiles by jumping out of the way.
		//TODO: Change this to something for the Strider.
		/*Actor Proj;
		If (!RunAway && KAI_Math.IsEmptyVector3 (DodgePos) && !LockedIn && (Proj = MVP_DroneDodge(User_DodgeRange,LastProj)))
		{
			LastProj = Proj;
			Double Delta = DeltaAngle (Proj.Angle,AngleTo(Proj));
			Vector3 Where = Delta >= -2 ? (Vec2Angle(128,Angle+90),0) : (Vec2Angle(128,Angle-90),0);
			Where.Z = GetZAt (Where.X,Where.Y,flags:GZF_ABSOLUTEPOS);
			[B, DodgePos] = IsPosReachable (DodgePos);
			DodgePos = B ? Where : DodgePos; //We can just go where we want, do that. If not, go to the closest position IsPosReachable() returned.
		}*/
		
		//Run away from threat, be it the target itself, a hazard, or a nearby enemy.
		If (!LockedIn && RunAway)
		{
			Vector3 RunPos = (!Haz && Target) ? Target.Pos : GetHazardOriginPos(Haz);
			//If (NearestEnemy)
			//	RunPos = NearestEnemy.Pos;
			
			If (Target && RunPos == Target.Pos && BigThreat) //Just run away from very dangerous enemies if you haven't jumped.
				ReverseSteps = 0;
			
			If (ReverseSteps <= 0)
				KAI_MoveAway (Null,StriderMove.Attempts,StriderMove.RunRad,StriderMove.MaxSteps,StriderMove.DetourFactor,StriderMove.AngleLimit,flags:KMTFlags,targpos:RunPos,StriderMove);
			Else //Reverse away from threat.
			{
				KMTFlags &= ~(KMT_ZIGZAG); //Don't zigzag when backing off.
				Frame = RevFrame;
				If (Rev++ >= 3) //Every 4 tics, switch frame.
				{
					//Rev = 0;
					If (RevFrame == 0)
						RevFrame = 5;
					Else
						RevFrame--;
				}
				//Tics--; //Reduce tics twice as fast to make it reverse faster.
				Angle -= 180;
				Speed *= 1.2;
				KAI_MoveAway (Null,0,StriderMove.RunRad,6,StriderMove.DetourFactor,StriderMove.AngleLimit,flags:KMTFlags,KMA_STRAIGHT,RunPos,StriderMove);
				Speed /= 1.2;
				Angle += 180;
			}
			
			If (ReverseSteps > 0)
				ReverseSteps--;
			
			Console.Printf ("reversesteps %u",reversesteps);
			
			MovedAlready = True;
		}
		
		//Move to target.
		If (!MovedAlready && Target && Target != Goal && !LockedIn)
		{
			KAI_MoveTowards (Target.Pos.PlusZ(Target.Height/2),StriderMove.DetourFactor,StriderMove.AngleLimit,flags:KMTFlags);
			MovedAlready = True;
		}
		
		//Patrol handling.
		If (!MovedAlready)
		{
			[B, MovedAlready] = KAI_Chase_PatrolHandling ("Spawn",StriderMove.DetourFactor,StriderMove.AngleLimit,flags:KMTFlags);
			If (bChaseGoal && Goal && Target != Goal) //Manually go to goal when it "don't chase target" mode.
				KAI_MoveTowards (Goal.Pos,StriderMove.DetourFactor,StriderMove.AngleLimit,flags:KMTFlags);
			If (b && goal) spawn ("kai_debugpoint",goal.pos);
			if (goal)console.printf ("patrolling, goal is at %d %d %d, moved already %d, reached point %d, reactiontime %d",goal.pos,movedalready,b,reactiontime);
		}
		
		HandleChaseTimer();
	}
	
	//Strider loves lean(ing)
	//Returns one of the sprite frames passed, and also a JumpDir
	Int, Int MVP_StriderLean (Int Forward, Int Left, Int Right, Int Back, Bool IgnoreVel = False)
	{
		Double Dir = Vel.XY.Unit() Dot AngleToVector (Angle);
		If (IgnoreVel)
			Dir = AngleToVector (GetAngleToPos(JumpPos,0)) Dot AngleToVector (Angle);
		
		If (Dir <= -0.5) //Facing back
			Return Back, JDIR_BACK;
		Else If (Dir >= 0.5) //Facing forward
			Return Forward, JDIR_NORMAL;
		Else If (Dir <= 0.5 && Dir >= -0.5) //Facing orthogonally, or in actual english, to the side
		{
			If (DeltaAngle (Angle,GetAngleToPos(JumpPos,0)) < 20)
				Return Left, JDIR_LEFT;
			Else
				Return Right, JDIR_RIGHT;
		}
		
		Return Forward, JDIR_NORMAL;
	}
	
	Protected Int MVP_StriderLeanIndex (Int Dir)
	{
		Switch (Dir)
		{
			Case JDIR_LEFT:
			Case JDIR_RIGHT:
			Case JDIR_BACK:
				Return GetSpriteIndex ('PNS1');
		}
		Return GetSpriteIndex ('PNS0');
	}
	
	//MAYDO: Alternate frame mappings for when in run mode.
	Protected Void MVP_StriderFootsteps()
	{
		If (Frame == 1 || Frame == 4) //Play stomp sound on frames where it steps on the ground.
			A_StartSound ("Vehicle/Strider/Stomp",flags:CHANF_OVERLAP,volume:FRandom(0.075,0.2));
	}
	
	KAIMoveParams StriderMove;
	KAI_Voice Yapper;
	Int DeathFlames;
	Bool Running; //Strider is playing its' run animation and moving faster.
	Vector3 CoverPos;
	UInt8 RevFrame, Rev;
	UInt8 ReverseSteps;
	
	//Jumping variables.
	Vector3 JumpPos;
	Int JumpFlags; //Flags used for every jump in progress. Then cleared once the jump's done.
	Int JumpDir; //The direction the strider is jumping at.
	//Actor JumpTarget; //Who to fire at while mid-jump.
	Const STRIDER_FALLTHRESHOLD = 8; //Minimum negative Z vel need to produce impact effects.
	
	Enum JumpDirs //The direction it starts off jumping to, determined by the angle difference between where it wants to go and its' angle at the time of jumping.
	{
		JDIR_NORMAL, //Standard nondescript jump
		JDIR_LEFT,
		JDIR_RIGHT,
		JDIR_RUN, //Running jump //MAYDO: Since the jump direction is determined dynamically, make this a flag instead?
		JDIR_BACK, //Jump backwards
	}
	
	Enum JFlags
	{
		SJUMP_FACEDIRECTION = 1 << 0, //Change angle over time while in the air to face where you're jumping to.
		SJUMP_FAST			= 1 << 1, //Jump faster. Used for running jumps and dodges.
	}
	
	Double User_JumpRange;
	Double User_RetreatDistance;
	Int User_ChaseTime;
	Bool User_NoCover;
	
	States
	{
		StriderSprites: //Do I even need to do this still? Not in the mood to find out.
			PNS1 ABCDEFGHIJKLMNOPQRSTUVWXYZ[] 0;
		Spawn:
			PNS3 A 1 KAI_Look ();
			Loop;
		See:
			PNS0 ABCDEF 4
			{
				MVP_StriderFootsteps();
				MVP_StriderChase();
				/*//Debug wandering and random jumping.
				KAI_Wander (32,384,anglelimit:25);
				if (random (0,255) < 8)
				{
					vector3 where = FindRandomMovePos (self.pos,8,checkrad:384);
					//where = vec3angle (randompick(256,-256),RandomPick(90,-90,0,0));
					KAI_DebugPointDelay.KAI_TempPointSpawn(where,35);
					MVP_StriderJump (where);
				}*/
			}
			Loop;
		
		//JUMP STATES
		//You can check if the strider is jumping by seeing if they are in any Jump.##### state.
		Jump:
			Jump.Start:
				#### # Random(5,12) Fast
				{
					If (JumpFlags & SJUMP_FAST)
						Tics = Random (3,7);
					
					[Frame, JumpDir] = MVP_StriderLean (24, 7, 6, 0, True); //Y, H, G, A
					Sprite = MVP_StriderLeanIndex (JumpDir);

					A_StartSound ("Vehicle/Strider/Motor",flags:CHANF_OVERLAP);
				}
				#### Y 0 KAI_JumpTo (JumpPos,maxlength:User_JumpRange);
			Jump.Loop:
				#### # 1
				{
					[Frame, JumpDir] = MVP_StriderLean (25, 10, 8, 1); //Z, K, I, B
					Sprite = MVP_StriderLeanIndex(JumpDir);
				}
				#### # 1
				{
					[Frame, JumpDir] = MVP_StriderLean (25, 10, 8, 1); //Z, K, I, B
					Sprite = MVP_StriderLeanIndex(JumpDir);
					If (JumpFlags & SJUMP_FACEDIRECTION && !KAI_Math.IsEmptyVector3 (JumpPos))
						{Angle = GetAngleToPos (JumpPos,StriderMove.AngleLimit/5);console.printf ("aiming to %.2f %.2f %.2f",jumppos);}
					//Going down, or maybe we already landed.
					If (Vel.Z <= -2 || bOnMobj || Pos.Z <= FloorZ || Pos.Z <= GetZAt ())
						Return FindState ("Jump.Loop.Down",True);
					Return State (Null);
				}
				Goto Jump.Loop+1;
			Jump.Loop.Down:
				//Coming down frame.
				#### # 1
				{
					If (JumpFlags & SJUMP_FACEDIRECTION && !KAI_Math.IsEmptyVector3 (JumpPos))
						{Angle = GetAngleToPos (JumpPos,StriderMove.AngleLimit/5);console.printf ("aiming to %.2f %.2f %.2f",jumppos);}
					[Frame, JumpDir] = MVP_StriderLean (26, 8, 10, 3); //[, I, K, D
					Sprite = MVP_StriderLeanIndex (JumpDir);
					If (bOnMobj || Pos.Z <= FloorZ || Pos.Z <= GetZAt ()) //The eagle has landed.
					{
						bNoFriction = Default.bNoFriction; //Do friction again.
						Return FindState ("Jump.End",True);
					}
					Return State (Null);
				}
				Loop;
			Jump.End: //All comes back here.
				#### # 8
				{
					If (JumpFlags & SJUMP_FAST)
						Tics = 4;
					
					Frame = MVP_StriderLean (28, 13, 12, 5, True); //], N, M, F
					Sprite = MVP_StriderLeanIndex (JumpDir);
					
					JumpFlags = 0;
					JumpDir = 0;
					JumpPos = (Double.NaN,Double.NaN,Double.NaN);
					NextMovePos = (Double.NaN,Double.NaN,Double.NaN);
				}
				Goto See;
		//TODO: Add running death state later.
		Death:
			PNS9 A 8
			{
				Tics = Random (4,10);
				If (Random (1,4) == 2)
					DeathFlames = Random (80,150)*10;
				
				A_StopSound (CHAN_BODY);
				A_StartSound ("SFX/Fire",CHAN_VOICE,CHANF_LOOPING,0.5,1.1);
				Actor Boom = Spawn ("MVP_Explosion",Pos.PlusZ(48));
				Boom.Scale *= FRandom (1.8f,2.2f);
				Boom.SetDamage (192);
				Boom.MaxTargetRange = 256;
				Boom.MeleeRange = Radius+64;
				Boom.bNoGravity = True;
				Boom.bGetOwner = True;
				Boom.Target = Self; //Does it even matter if we're gone? Very philosophical.
				
				SmokeCounter = Random (8,16);
				Bool B; Actor Debris;
				For (Int I; I <= SmokeCounter; I++)
				{
					[B, Debris] = A_SpawnItemEx ("MVP_DiCokkaDebris",FRandom (Radius,-Radius),FRandom(Radius,-Radius),FRandom (Height-24,Height+24),FRandom (-6,6),FRandom (-6,6),FRandom (2,8));
					If (Debris)
					{
						Debris.Scale *= FRandom (0.1,0.8);
						Debris.bXFlip = Random (False,True);
					}
				}
				
				If (Random (True, False) == True)
					Return FindState ("AltDeath");
				Return State (Null);
			}
			PNS9 B 4;
			PNS9 C 3;
			PNS9 D -1
			{
				If (GetZAt() <= Pos.Z)
				{
					A_StartSound ("SFX/MetalHit");
					Actor Duster = Spawn ("MVP_GroundDustSpawner",Pos);
					//Pass parameters to spawner.
					Duster.RadiusDamageFactor = 0;
					Duster.ReactionTime = 32;
					Duster.Threshold = Radius*2.25;
					Duster.Scale *= 0.25;
				}
			}
			Stop;
		//URGENT: TODO: Fix the fucking cropping. Fucking great, can't wait for my entire system to break a THIRD time because of the Strider sprites!!!!!
		AltDeath:
			PNS9 EF 4;
			PNS9 G -1
			{
				If (GetZAt() <= Pos.Z)
				{
					A_StartSound ("SFX/MetalHit");
					Actor Duster = Spawn ("MVP_GroundDustSpawner",(Vec2Angle(24,Angle),Pos.Z));
					//Pass parameters to spawner.
					Duster.RadiusDamageFactor = 0;
					Duster.ReactionTime = 32;
					Duster.Threshold = Radius*2.25;
					Duster.Scale *= 0.5;
				}
			}
			Stop;
		XDeath:
			PNS9 K 8
			{
				Tics = Random (4,10);
				
				A_StopSound (CHAN_BODY);
				Actor Boom = Spawn ("MVP_Explosion",Pos.PlusZ(48));
				Boom.Scale *= FRandom (2.75f,3.5f);
				Boom.SetDamage (256);
				Boom.MaxTargetRange = 384;
				Boom.MeleeRange = Radius+64;
				Boom.bNoGravity = True;
				Boom.bGetOwner = True;
				Boom.Target = Self; //Does it even matter if we're gone? Very philosophical.
				
				Bool Alt = Random (True, False);
				Bool B; Actor Debris;
				//No gibs.
				If (Random (True,False) == True)
				{
					SmokeCounter = Random (48,64);
					
					For (Int I; I <= SmokeCounter; I++)
					{
						[B, Debris] = A_SpawnItemEx ("MVP_DiCokkaDebris",FRandom (Radius,-Radius),FRandom(Radius,-Radius),FRandom (Height-24,Height+24),FRandom (-6,6),FRandom (-6,6),FRandom (2,8));
						If (Debris)
						{
							Debris.Scale *= FRandom (0.1,0.8);
							Debris.bXFlip = Random (False,True);
						}
					}
				}
				Else
				{
					If (!Alt) //No head gib if we are going the XDeath where the whole body is destroyed.
					{
						[B, Debris] =  A_SpawnItemEx ("MVP_StriderHeadGib",zofs:64,FRandom (4,-4),FRandom (-4,-8),FRandom (6,16));
						If (Debris)
						{
							Debris.SmokeCounter = Random (2,6);
							Debris.Master = Self;
						}
					}
					[B, Debris] =  A_SpawnItemEx ("MVP_StriderArmGib",zofs:64,FRandom (-6,-16),FRandom (-6,-12),FRandom (2,8));
					If (Debris)
					{
						Debris.SmokeCounter = Random (2,6);
						Debris.Master = Self;
					}
				}
				
				If (Alt)
					Return FindState ("AltXDeath");
				Return State (Null);
			}
			PNS9 LM 4;
			PNS9 N -1
			{
				A_StartSound ("SFX/MetalHit");
				Actor Duster = Spawn ("MVP_GroundDustSpawner",(Vec2Angle(-24,Angle),Pos.Z));
				//Pass parameters to spawner.
				Duster.RadiusDamageFactor = 0;
				Duster.ReactionTime = 32;
				Duster.Threshold = Radius*2.25;
				Duster.Scale *= 0.5;
			}
			Stop;
		AltXDeath:
			PNS9 OPQ 3;
			PNS9 R -1;
			Stop;
	}
}

Class MVP_StriderHeadGib : Actor
{
	Default
	{
		Radius 24;
		Height 32;
		XScale 0.8;
		YScale 0.666666; //0.8 / 1.2
		Mass 250;
		+Solid;
		+Shootable;
		//+NoBlockmap;
		+BloodlessImpact;
		+Blasted;
	}
	
	Override Bool CanCollideWith (Actor Other, Bool Passive)
	{
		If (Other && (Other Is GetClassName() || Other == Master))
			Return False;
		Return Super.CanCollideWith (Other, Passive);
	}
	
	States
	{
		Spawn:
			PNS9 STU 4
			{
				Tics = SmokeCounter;
				If (!TestMobjZ(True) || GetZAt ()+1 >= Pos.Z)
					Return FindState("Death");
				
				Return State(Null);
			}
			Loop;
		Death:
			PNS9 V -1
			{
				A_StartSound ("SFX/MetalHit");
				Actor Duster = Spawn ("MVP_GroundDustSpawner",pOS);
				//Pass parameters to spawner.
				Duster.RadiusDamageFactor = 0;
				Duster.ReactionTime = 32;
				Duster.Threshold = Radius*2.25;
				Duster.Scale *= 0.5;
			}
			Stop;
	}
}

Class MVP_StriderArmGib : MVP_StriderHeadGib
{
	Default
	{
		Radius 12;
		Height 16;
		Mass 50;
	}
	States
	{
		Spawn:
			PNS9 XYY 4
			{
				Tics = SmokeCounter;
				If (!TestMobjZ(True) || GetZAt ()+1 >= Pos.Z)
					Return FindState("Death");
				
				Return State(Null);
			}
			Loop;
		Death:
			PNS9 Z -1
			{
				SpriteOffset.Y -= 3;
				A_StartSound ("SFX/MetalHit");
				Actor Duster = Spawn ("MVP_GroundDustSpawner",pOS);
				//Pass parameters to spawner.
				Duster.RadiusDamageFactor = 0;
				Duster.ReactionTime = 32;
				Duster.Threshold = Radius*1.5;
				Duster.Scale *= 0.5;
			}
			Stop;
	}
}
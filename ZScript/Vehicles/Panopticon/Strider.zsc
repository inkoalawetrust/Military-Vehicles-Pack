//FIXME:
//The climb preperation frame (PNS1R1-8) has the foot spikes appearing over the top of the Striders' feet.
//IIRC one of the grenade frames is missing brightmaps.
//The AltDeath frame of the Strider fully fallen is cropped wrong.

//BUG:
//It (Sometimes at least) VM aborts from OnProjectileDeflect() in MVP_GenericShit when it tries deflecting a projectile?
//Seems like the strider sometimes stops attacking and just walks around despite having a target.
//Dodges around too much. UPDATE: Looking at this a month later, gee, real fucking descriptive past me.
//Sometimes the constant engine hum doesn't play.
//The Strider seems to retreating by jumping away waaayyyy too much when fighting other KAI actors, might be considering all hazards as super dangerouns at all times.

//IDEA:
//Add jumping SpecialSpots. This requires a proper ballistic function so not happening until then.
//Add an action restrictor for the strider. Such as for stopping it from running in certain parkour-heavy areas.

//MAYDO:
//Look into improving the existing bullet and melee attacks.
//Think of some extra behaviors and such when in an MVP_DroneSwarm or groups in general.
//Make strider able to strafe fire rockets :>

//TODO:
//Add the remaining grenade attack.

//HACK: Fucking christ shut up about overriding Tick() you bastard.
Class MVP_Humanoid : KAI_Humanoid
{
	Mixin MVP_DamageSmokeHandling;
	Mixin MVP_SharedNonVehicleFunctions;
	//Mixin MVP_MarineFunctions;
	Mixin MVP_GenericShit;
	Int SearchTime;
	Int ChaseTimer;
	
	Void HandleChaseTimer()
	{
		//Stop chasing your target after it's out of sight for long enough.
		If (SearchTime > 0)
		{
			If (ChaseTimer >= SearchTime)
			{
				A_ClearTarget();
				ChaseTimer = 0;
				//Vehicles ordered to stay also go back to standing still once the timer runs out.
				If (CurrentOrder == ORDER_STAY)
				{
					SetStateLabel ("Spawn");
					Return;
				}
			}
			
			If (!IsPatrolling(Self))
			{
				If (!Target || Target && !CheckSight (Target,SF_SEEPASTBLOCKEVERYTHING))
					ChaseTimer++;
				//Target is visible again, reset the timer.
				Else
					ChaseTimer = 0;
			}
		}
	}
}

Class MVP_Strider : MVP_Humanoid
{
	Default
	{
		//$Title Strider
		//$Category Vehicles/Panopticon
		//$Sprite PNS3A1
		Mass 1000;
		Health 600;
		GibHealth 300;
		WoundHealth 200;
		XScale 0.8;
		YScale 0.666666; //0.8 / 1.2
		Radius 24;
		Height 88;
		DeathHeight 32;
		RipLevelMin 3;
		Speed 10;
		FastSpeed 14;
		FriendlySeeBlocks 64;
		MeleeRange 64;
		MaxStepHeight 32;
		MaxDropoffHeight 32; //This is different from the striders' ability to climb down to areas it has the range to jump back up from.
		Tag "R-11-B Paŝegulo";
		SeeSound "Vehicle/Strider/Alert";
		Obituary "%o was killed by a Strider";
		HitObituary "%o got too close to a Strider";
		
		+NoBlood;
		+DontCorpse;
		
		MVP_Humanoid.SmokeDelay 4;
		KAI_Actor.ThreatLevel THREAT_DANGEROUS;
		KAI_Actor.ThreatLevelThreshold THREAT_VERYDANGEROUS;
		KAI_Actor.ActorFollowDist 192;
		KAI_Actor.Inaccuracy (12,12,12);
		KAI_Actor.InaccuracyFrequency 0.6;
		
		//Damage factors that act as the vehicles "armor".
		DamageFactor 0.75; //Generic damage factor for all damage.
		DamageFactor "Melee", 0.3;
		DamageFactor "Electric", 0.4;
		DamageFactor "ExplosiveImpact", 0.7;
		DamageFactor "Explosion", 0.7;
		DamageFactor "Explosive", 0.7;
		DamageFactor "Grenade", 0.7;
		DamageFactor "HitScan", 0.7; //The generic damage type of hitscan attacks.
		DamageFactor "Shrapnel", 0.4;
		DamageFactor "Fire", 0.6;
		DamageFactor "Crush", 1.3;
		DamageFactor "Disintegrate", 1.5;
		DamageFactor "Railgun", 2.0;
		DamageFactor "Falling", 0.0; //No
		
		//Vehicle damage factors
		DamageFactor "Autocannon", 0.8;
		DamageFactor "LargeRifleBullet", 0.9;
		DamageFactor "RifleBullet", 0.8;
		DamageFactor "SmallRifleBullet", 0.6;
	}
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		SearchTime = User_ChaseTime;
		//FireDelay = Random (1,2)*GameTicRate;
		
		StriderMove.DetourFactor = 0.6;
		StriderMove.Attempts = 32;
		StriderMove.MaxSteps = 72;
		StriderMove.RunRad = 394;
		StriderMove.AngleLimit = 25;
		StriderMove.CornerDiv = 8;
		StriderMove.CornerDist = 192;
		
		JumpPos = (Double.NaN,Double.NaN,Double.NaN);
		CoverPos = (Double.NaN,Double.NaN,Double.NaN);
		ClimbPos = (Double.NaN,Double.NaN,Double.NaN);
		
		A_StartSound ("Vehicle/Drone/Motor",CHAN_BODY,CHANF_LOOPING,1,ATTN_STATIC);
		If (KAIHandler) Yapper = KAIHandler.GetNPCVoice ("Panopticon");
		
		MissileState = FindState ("Fire",True); //Fallback state, picks a random attack and amount.
		AttackStates.Push (FindState("Fire.Start",True));
		AttackStates.Push (FindState("Fire.MG",True));
		AttackStates.Push (FindState("Fire.Minigun",True));
		AttackStates.Push (FindState("Fire.Rocket",True));
		AttackStates.Push (FindState("Fire.Grenade",True));
		
		//Melee state is just called "Melee", no need to custom set it, and it functions like Fire:.
		AttackStates.Push (FindState("Melee.Kick",True));
		AttackStates.Push (FindState("Melee.Stomp",True));
		AttackStates.Push (FindState("Melee.Ram",True)); //Special attack where the strider runs up to the target to ram it.
	}
	
	Override Void UserVariableDefaults()
	{
		Super.UserVariableDefaults();
		
		If (User_JumpMode == 0)
			User_JumpMode = 1; //Default jump ranges.
		If (User_DodgeRange == 0)
			User_DodgeRange = 512;
		If (User_RetreatDistance == 0)
			User_RetreatDistance = 512;
		If (User_ChaseTime == 0)
			User_ChaseTime = User_ChaseTime = (35/4)*30;
		
		//Copied from how the  ̶S̶m̶a̶r̶t̶ ̶M̶a̶r̶i̶n̶e̶s̶'̶ tanks' color variable is handled.
		If (!User_Color || User_Color ~== ""){} //Don't run the code if User_Color is empty.
		Else
		{
			//Handles the random color choice that is performed if the color name given is "Random".
			If (User_Color ~== "Random")
			{
				Static Const String ColorArray[] = {"White","Black","Yellow","Orange","Red","Blue","Default"}; //Contains all the valid color names.
				
				User_Color = ColorArray[Random(0,ColorArray.Size()-1)]; //Randomly picks a color string.
			}
			
			If (!(User_Color ~== "Default"))
				A_SetTranslation (String.Format("Strider_%s", User_Color));
			Else
				A_SetTranslation ('');
		}
	}
	
	Protected Double LastTickFallVel;
	
	Override Void Tick()
	{
		If (Vel.Z <= 0) LastTickFallVel = Abs(Vel.Z);
		Else LastTickFallVel = 0;
		
		Super.Tick();
		
		If (IsFrozen()) Return;
		
		If (FireDelay >= 1)
			FireDelay--;
		
		If (ExplosiveDelay >= 1)
			ExplosiveDelay--;
		
		If (MeleeWindow >= 1)
			MeleeWindow--;
		
		Bool IsDead = IsDead(Self);
		Bool IsAttacking = IsInAttackState();
		
		//Target prediction during attack states.
		If (!IsDead && IsAttacking)
		{
			Vector3 AttackPos = MVP_StriderAttackPos (AttackType);
			
			//NOTE: Separate check from GetAttackLocation() because some types need more data.
			FLineTraceData Proj;
			bMissile = True; //HACK: Become missile for TRF_BLOCKSELF.
			LineTrace (Angle,MaxTargetRange,Pitch,TRF_SOLIDACTORS|TRF_BLOCKSELF,AttackPos.Z,AttackPos.X,AttackPos.Y,Proj);
			bMissile = False;
			
			Double ProjSpeed, FastProjSpeed;
			Array <String> AttackTags; AttackTags.Push ("Vehicle"); AttackTags.Push ("Drone"); AttackTags.Push ("Robot"); //Generic tags.
			Switch (AttackType) //Change speed generically based on attack. And also emit hazards.
			{
				Case ATTACK_MACHINEGUN:
					ProjSpeed = GetDefaultByType("MVP_RifleBullet").Speed;
					FastProjSpeed = GetDefaultByType("MVP_RifleBullet").FastSpeed;
					
					//Warn actor in LOF.
					HazardInfo MG = New ('HazardInfo');
					MG.Origin = Self;
					MG.Position = Proj.HitLocation;
					MG.Type = HazardInfo.HAZARD_ATTACK;
					MG.Level = HazardInfo.HAZARD_MEDIUM;
					MG.Range = 64;
					AttackTags.Push ("Bullet");
					MG.CustomTags = AttackTags;
					HazardInfo.GiveHazard (Proj.HitActor,MG);
					Break;
				Case ATTACK_MINIGUN:
					ProjSpeed = GetDefaultByType("MVP_SmallRifleBullet").Speed;
					FastProjSpeed = GetDefaultByType("MVP_SmallRifleBullet").FastSpeed;
					
					//Ditto but AOE.
					AttackTags.Push ("Bullet"); AttackTags.Push ("Minigun");
					HazardInfo.EmitHazard (Self,256,HazardInfo.HAZARD_ATTACK,HazardInfo.HAZARD_LARGE,tags:AttackTags,Proj.HitLocation,usepos:True);
					Break;
				Case ATTACK_ROCKETS:
					ProjSpeed = GetDefaultByType("MVP_70mmRocket").Speed;
					FastProjSpeed = GetDefaultByType("MVP_70mmRocket").FastSpeed;
					
					//Explosive hazard.
					AttackTags.Push ("Explosive"); AttackTags.Push ("Rocket");
					HazardInfo.EmitHazard (Self,512,HazardInfo.HAZARD_ATTACK,HazardInfo.HAZARD_LARGE,tags:AttackTags,Proj.HitLocation,UsePos:True);
					Break;
				/*Case ATTACK_GRENADE:
					ProjSpeed = GetDefaultByType("MVP_40mmGrenade").Speed;
					FastProjSpeed = GetDefaultByType("MVP_40mmGrenade").FastSpeed;
					
					AttackTags.Push ("Explosive"); AttackTags.Push ("Grenade");
					HazardInfo.EmitHazard (Self,512,HazardInfo.HAZARD_ATTACK,HazardInfo.HAZARD_LARGE,tags:AttackTags,Proj.HitLocation);
					Break;*/
			}
			Actor RealTarg = Target;
			Int Turn = 6;
			If (JumpFlags & SJUMP_STRAFE) //Currently strafing.
			{
				Target = JumpTarget;
				//Turn = StriderMove.AngleLimit;
			}
			//HACK: Bizzare hack to account for the striders firing way off their origin, fun part is that this happens in ALL actors I'm pretty sure!
			Int FAF = GetFAFAimPos(Target,AttackPos);
			Double AimOfs = GetFAFPosOffset(Target,FAF);
			SetZ (Pos.Z+AimOfs);
			AimAtTarget (Turn,Turn,flags:FAF,attackspeed:ProjSpeed,fastattackspeed:FastProjSpeed);
			SetZ (Pos.Z-AimOfs);
			if (target)
				kai_lofraycast.visualizetracepath (Pos,level.vec3offset(pos,kai_math.angletovector3d(angle,-pitch,distance3d(target))),distance3d(target));
			Target = RealTarg;
		}
		
		If (LastTickFallVel >= STRIDER_FALLTHRESHOLD*2 && !IsDead && !IsAttacking && !IsInState(Self,"Jump.Loop.Down"))
			SetStateLabel ("Jump.Loop.Down");
		
		//Run fall impact code.
		//HACK: Yes this is a copy from KAI_BaseVehicle because it's like, the only feature 
		If (Vel.Z ~== 0 && LastTickFallVel && LastTickFallVel >= STRIDER_FALLTHRESHOLD && !IsDead)
		{
			//Get victims under the vehicle.
			Array <Actor> IMFALLINGOVERHERE;
			Vector3 RealPos = Pos;
			SetOrigin (Pos.PlusZ(-LastTickFallVel),False); //Move down the vehicle as if it never stopped, to check for blocking actors in the way.
			BlockThingsIterator Blockers = BlockThingsIterator.Create(Self);
			While (Blockers.Next())
			{
				//Blocking actor found.
				If (Blockers.Thing && Blockers.Thing != Self && IsCollidable(Blockers.Thing,Self) && CheckHitboxIntersection(Self,Blockers.Thing))
					IMFALLINGOVERHERE.Push(Blockers.Thing);
			}
			SetOrigin (RealPos,False);
			
			//COPIED FROM THE MVP STOCK ONGROUNDIMPACT().
			//No actors that we were stopped by, so we probably hit level geometry.
			If (!IMFALLINGOVERHERE.Size())
			{
				Double Force = Mass * LastTickFallVel;
				//Impact sound
				A_StartSound ("Vehicle/Strider/Stomp",CHAN_AUTO,CHANF_OVERLAP,KAI_Math.LinearMap(Force,1000,2500,0.25,1.0),0.65);
				//Impact quake
				Double QuakeForce = KAI_Math.LinearMap(Force,50000,2500000,0.1,4.0);
				Double QuakeRange = KAI_Math.LinearMap(Force,50000,2500000,256,1024);
				Double QuakeThrust = KAI_Math.LinearMap(Force,50000,2500000,0.01,0.5);
				A_QuakeEx (QuakeForce/4,QuakeForce/4,QuakeForce/1,50,QuakeRange,QuakeRange,"",QF_SCALEDOWN|QF_GROUNDONLY|QF_AFFECTACTORS|QF_SHAKEONLY,
				rollintensity:QuakeForce,thrustmultiplier:QuakeThrust);
				//Impact dust
				Actor Duster = Spawn ("MVP_GroundDustSpawner",Pos);
				//Pass parameters to spawner.
				Duster.RadiusDamageFactor = 4;
				Duster.ReactionTime = KAI_Math.LinearMap(Force,100,25000,1,256);
				Duster.Threshold = Radius*1.55;
				Duster.Scale *= 0.5;
			}
			//We hit some actors, crush them and lose some fall speed in exchange (Very realistic and sophisticated physics simulation).
			Else
			{
				Double PostCrushVel = LastTickFallVel;
				//Squish
				Double VelReduction = KAI_Math.LinearMap (Mass,10,2500,10,0.25);
				VelReduction = Clamp (VelReduction,0.25,INT.MAX);
				ForEach (Bug : IMFALLINGOVERHERE)
				{
					Double Force = Mass * PostCrushVel;
					Int ImpactDamage = Force/25;
					Bug.DamageMobj (Self,Self,ImpactDamage,'Crush');
					PostCrushVel -= VelReduction*(Bug.Mass/100); //Reduce fall speed for every bug squashed before applying it back in.
					PostCrushVel = Clamp (PostCrushVel,0,INT.MAX);
					//Play impact sound on each victim based on impact velocity.
					Bug.A_StartSound (Bug.bNoBlood ? "SFX/MetalHit" : "SFX/FleshHit",CHAN_AUTO,CHANF_OVERLAP,KAI_Math.LinearMap(Force,100,2500000,0.075,1.0),0.65);
				}
				
				Vel.Z = -PostCrushVel;
			}
			
			LastTickFallVel = 0;
		}
	}
	
	Override Vector3 GetAttackLocation()
	{
		//If doing a ranged attack, we are attacking wherever we're aiming currently.
		If (AttackType == ATTACK_MACHINEGUN || AttackType == ATTACK_MINIGUN || AttackType == ATTACK_ROCKETS || AttackType == ATTACK_GRENADE)
		{
			Vector3 AttackPos = MVP_StriderAttackPos (AttackType);
			FLineTraceData Proj;
			bMissile = True; //HACK: Become missile for TRF_BLOCKSELF.
			LineTrace (Angle,MaxTargetRange,Pitch,TRF_SOLIDACTORS|TRF_BLOCKSELF,AttackPos.Z,AttackPos.X,AttackPos.Y,Proj);
			bMissile = Default.bMissile;
			Return Proj.HitLocation;
		}
		
		If (Target) //Doing melee attack, our attack location is the target. MAYDO: Make it be whatever is MeleeRange units in front of the strider?
			Return Target.Pos;
		Return (Double.NaN,Double.NaN,Double.NaN);
	}
	
	Override Bool SpawnDamageSmoke()
	{
		Bool Dead = IsDead(Self);
		If (!DeathFlames && Dead) A_StopSound (CHAN_VOICE); //Flames stopped.
		If (!DeathFlames && Dead|| !Super.SpawnDamageSmoke() && !Dead || bIceCorpse) Return False;
		
		If (DeathFlames)
			DeathFlames--;
		
		If (Random (0,255) < 3)
			Spawn ("MVP_Spark",Level.Vec3Offset(Pos,(FRandom (Radius,Radius),FRandom (Radius,-Radius),FRandom (0,Height))));
		
		Int CardAng = GetNearestCardinalAngle(False);
		Vector3 SpawnPos = !Dead ? Vec3Angle (32,CardAng) : Vec3Angle (32,CardAng+135);
		If (IsInState (Self,"AltDeath"))
			SpawnPos = Vec3Angle (48,CardAng-45);
		
		If (!Dead) //Spawn smoke behind engine
			SpawnPos.XY = KAI_Math.RotateAround (Pos.XY,SpawnPos.XY,SpriteRotation);
		Let FX = Dead ? "MVP_BrightFireParticle" : "MVP_DamageSmoke";
		Int Times = !Dead ? 1 : 3;
		For (Int I; I < Times; I++)
		{
			If (!Dead)
				SpawnPos = Level.Vec3Offset (SpawnPos,(FRandom(-16,16),FRandom(-16,16),72));
			Else
				SpawnPos = Level.Vec3Offset (SpawnPos,(FRandom(-16,16),FRandom(-16,16),24));
			
			For (Int I; I < 4; I++)
			{
				If (!Level.IsPointInLevel (SpawnPos))
					Continue;
				Actor Smoke = Spawn (FX,SpawnPos);
				Smoke.Roll = FRandom(-180,180);
				If (!Dead) Smoke.A_SetScale (FRandom(0.25,0.8));
				Else Smoke.A_SetScale (FRandom(0.25,0.5));
				Smoke.Vel.Z = !Dead ? FRandom (1,4) : FRandom (4,8);
			}
		}
		
		Return True;
	}
	
	Override String GetObituary (Actor Victim, Actor Inflictor, Name MOD, Bool PlayerAttack)
	{
		If (AttackType == ATTACK_NONE && MOD == 'Crush') //Strider fell on victim lmao.
			Return "A Strider fell on %os' head";
		
		If (MOD == 'Melee' || MOD == 'Crush' && AttackType == ATTACK_STOMP) //Melee attack obituaries.
		{
			If (Random (1,6) == 6) //Use the generic melee obituary sometimes.
				Return HitObituary;
			
			If (AttackType == ATTACK_PUNT)
			{
				If (Random (False, True) == True)
					Return "%o was punted by a Strider";
				Else
					Return "%o violated a Striders' personal space";
			}
			Else If (AttackType == ATTACK_ALTPUNT)
				Return "%o became a football";
			Else If (AttackType == ATTACK_STOMP)
			{
				String StompObituaries[] = {
				"%o was stepped on by a Strider",
				"%o got squashed by a Strider",
				"%k wasn't paying attention and stepped on %o"}; //Lol, all the other obituaries just call it a Strider while this one uses its' full untranslated name.
				
				Return StompObituaries[Random(0,StompObituaries.Size()-1)];
			}
			Else If (AttackType == ATTACK_RAMMING)
			{
				If (Random (False, True) == True)
					Return "%o didn't get out of a Striders' way";
				Else
					Return "%o showed red to a Strider";
			}
		}
		
		If (Inflictor Is "MVP_SmallRifleBullet") //Minigun spam.
			Return "%o got showered by a Strider";
		
		If (Inflictor Is "MVP_RifleBullet")
		{
			If (Distance3D (Victim) >= 6144)
			{
				If (Random (0, 255) < 192)
					Return "%o was sniped by a Strider";
				Else
					Return "%o will make a cameo in a Striders' montage video";
			}
			
			Return "%o was shot by a Strider";
		}
		
		If (Inflictor Is "MVP_70mmRocket") //MAYDO: Direct hit obituary?
			Return "%o was blown up by a Striders' rocket";
		
		Return Super.GetObituary (Victim, Inflictor, MOD, PlayerAttack);
	}
	
	Override Void Die (Actor Source, Actor Inflictor, Int DMGFlags, Name MeansOfDeath)
	{
		Super.Die (Source, Inflictor, DMGFlags, MeansOfDeath);
		
		A_RemoveLight ('StrafeLight');
		If (JumpFlags & SJUMP_STRAFE)
		{
			AttackStates.Delete (AttackStates.Find(FindState("Jump.Loop",True)));
			AttackStates.Delete (AttackStates.Find(FindState("Jump.Loop.Down",True)));
		}
		bNoFriction = Default.bNoFriction; //Do friction again.
		bNoGravity = Default.bNoGravity; //Do gravity again.
		InCover = False;
		SmokeCounter = 0;
		RamPower = 0;
	}
	
	Override Bool OnWander()
	{
		KAI_Look(LOF_NOJUMP,FOV: (CurrentOrder == ORDER_STAY && !Crouching) ? 360 : 0,extraflags:KAIL_CHASETARGET);
		If (Target)
		{
			SetState(SeeState);
			Return False;
		}
		
		If (MVP_StriderDodge())
			Return False;
		
		If (MVP_StriderParkour ()) //General handling of climbing, crouching, jumping down, yadda yadda.
			Return False;
		
		//Hazard handling.
		If (Health > WoundHealth) //Ignore weak hazards if not weak yourself, and also projectile attack hazards. We try to dodge those instead.
		{
			For (Int I = Hazards.Size()-1; I >= 0; I--)
			{
				Let Haz = Hazards[I];
				If (Haz && Haz.Level <= HazardInfo.HAZARD_LOW)
					Hazards.Delete(I);
				
				ForEach (CurTag : Haz.CustomTags)
				{
					If (CurTag ~== "Bullet" || CurTag ~== "Projectile")
						Hazards.Delete(I);
				}
			}
		}
		
		HazardInfo Haz = GetStrongestHazard(Hazards);
		If (Haz)
		{
			If (MVP_StriderJump (MVP_StriderJumpFromPos (GetHazardOriginPos(Haz),32,384)))
				Return False;
			Else If (!RunSteps && !Crouching) //Jumping away from the hazard failed, just try running off.
			{
				MVP_StartRun (Random(16,32));
				Return False;
			}
		}
		
		//Idle around, with 360 vision and looking all around.
		If (CurrentOrder == ORDER_STAY)
		{
			If (Crouching) //No 360 turning for crouching, just sit around.
			{
				Frame = FRAME_O;
				Return False;
			}
			Tics = 8;
			Sprite = GetSpriteIndex ('PNS3');
			A_StartSound ("Vehicle/Drone/Turret",CHAN_AUTO,volume:0.5,ATTN_STATIC);
			Return False;
		}
		
		MVP_UseCrouchAnim();
		
		Vector3 FolPos = (Double.NaN, Double.NaN, Double.NaN); Actor Followee;
		If (CurrentOrder == ORDER_FOLLOW)
			[FolPos, Followee] = HandleFollowingActor (FolPos,True);
		
		If (Random(0,3072) == Random (0,3072) && Yapper)
		//	MVP_QuadcopterSpeak();
			SayVoiceLine (VOICE_SEE,Yapper);
		
		//Follow something instead.
		If (CurrentOrder == ORDER_FOLLOW)
		{console.printf ("moving to %.2f %.2f %.2f, followee %p",folpos,followee);
			If (!KAI_Math.IsEmptyVector3(FolPos))
			{
				Double Dist = Distance3D(Followee);
				
				If (Followee && Dist >= (FollowDist+Followee.Radius))
				{
					If (Dist >= (FollowDist*2) && !Crouching)
						MVP_StartRun (6);
					
					If (Followee) FolPos.Z = Followee.Pos.Z+(Followee.Height/2);
					KAI_MoveTowards (FolPos,StriderMove.DetourFactor,StriderMove.AngleLimit);
					MVP_StriderFootsteps(RunSteps);
					Return False;
				}
				//Don't dogpile.
				Else If (Followee)
				{
					If (Crouching) //No 360 turning for crouching, just sit around.
					{
						Frame = FRAME_O;
						Return False;
					}
					Tics = 8;
					Sprite = GetSpriteIndex ('PNS3');
					If (Frame > FRAME_F)
						Frame = FRAME_F; //Clamp frame.
					A_StartSound ("Vehicle/Drone/Turret",CHAN_AUTO,volume:0.5,ATTN_STATIC);
					KAI_Look(0,FOV: 360,extraflags:KAIL_CHASETARGET); //NOTE: Look all around, yes, twice, whatever.
					Return False;
				}
			}
		}
		
		MVP_StriderFootsteps(RunSteps);
		
		Return True;
	}
	
	//HACK: BlockingMobj doesn't work of course!
	Override Void CollidedWith (Actor Other, Bool Passive)
	{
		Super.CollidedWith (Other, Passive);
		
		If (AttackType == ATTACK_RAMMING && !Passive)
			Rammed = Other;
	}
	
	Override Bool ShouldAttack (Bool NoStateJump)
	{
		If (!Target || Target == Goal) Return False; //Don't attack if you have no target or just following a goal.
		If (!CanAttack() || !CanBeTargeted(Self,Target) || IsInanimateObject (Target)) Return False;
		
		Int Threat = AssessThreatLevel (Target);
		Double Dist = Distance3D (Target);
		Bool InSight = CheckSight (Target,SF_IGNOREWATERBOUNDARY); //IDEA: Try to make the grenade launcher fire at out of sight target? Otherwise just abort if out of sight.
		
		Bool WhackTarget = KAI_CheckMeleeRange (Target,flags:CMR_3DDISTANCE);
		Actor NearestMeleeEnemy; //TL;DR Allow the strider to also kick other nearby enemies when surrounded.
		//BUG: This causes it to often kick corpses too, despite FindNearestEnemy() filtering them out, of course. But hey, at least it's funny.
		If (!WhackTarget)
		{
			NearestMeleeEnemy = FindNearestEnemy ( Radius+(MeleeRange*2) );
			If (IsDead (NearestMeleeEnemy))
				NearestMeleeEnemy = Null;
		}
		
		//==================
		//Mecha secretary bird.
		
		If (InSight && Random (0,255) < 3 && KAI_CheckMeleeRange (Target,640,CMR_3DDISTANCE) && IsPosReachable(Target.Pos,Target.Radius*2.2)) //Ram ranch
		{
			MeleeWindow = ReverseSteps = 0;
			AttackType = ATTACK_RAMMING;
			If (!NoStateJump) SetStateLabel ("Melee.Ram");
			Return True;
		}
		
		Bool Surrounded = MVP_IsSurrounded (256,8,True);
		//Separate chance to do a stomp if standing on an enemy and surrounded, AKA fighting swarms of enemies like pinkies without trying to shoot under your damn feet.
		If (Random (0,255) < 200 && Surrounded)
		{
			Actor Standing = MVP_StriderStandingOnEnemy();
			If (Standing)
			{console.printf ("EW IM STANDING ON SHIT");
				MeleeTarget = Standing;
				If (!NoStateJump) SetStateLabel ("Melee.Stomp");
				Return True;
			}
		}
		
		//Normal melee attack decisions.
		If (InSight && Random (0,255) < 220 && (WhackTarget || KAI_CheckMeleeRange (NearestMeleeEnemy,flags:CMR_3DDISTANCE)) ||
		Random (0,255) < 128 && Surrounded && NearestMeleeEnemy)
		{
			If (!WhackTarget || Surrounded && NearestMeleeEnemy)
				MeleeTarget = NearestMeleeEnemy;
			Else
				MeleeTarget = Target;
			
			//Should we stomp instead?
			//NOTE: For simplicity, just don't stomp at all if the actor is flying, no fancy "is beneath my feet anyways" checks or whatever.
			Bool EwISteppedOnShit = (Random (0,255) < 16 && !IsFlying (MeleeTarget) && Target.Height <= Height*0.7 && MeleeTarget.ApplyDamageFactor ('Crush',100) >= 30);
			If (EwISteppedOnShit) //https://www.youtube.com/watch?v=rkOib-MmTds
			{
				If (!NoStateJump) SetStateLabel ("Melee.Stomp");
				If (Surrounded && NearestMeleeEnemy) FireDelay = GameTicRate*8; //Wait a sec when surrounded by melee shits.
				Return True;
			}
			
			//Sometimes kick up delibaretely if the enemy can take fall damage and there's airspace.
			If (CanTakeFallDamage (MeleeTarget) && MeleeTarget.ApplyDamageFactor ("Falling",100) > 0 && CeilingZ - FloorZ >= 256)
			{
				AttackType = ATTACK_ALTPUNT;
				If (!NoStateJump) SetStateLabel ("Melee.Kick");
				If (Surrounded && NearestMeleeEnemy) FireDelay = GameTicRate*8; //Wait a sec when surrounded by melee shits.
				Return True;
			}
			
			//Mostly kick only if, you know, it works.
			If (MeleeTarget.ApplyDamageFactor ('Melee',100) >= 30 || Random (0,255) < 8)
			{
				If (Random (0,255) < 8) AttackType = ATTACK_ALTPUNT; //Variety kicking.
				If (!NoStateJump) SetStateLabel ("Melee.Kick");
				If (Surrounded && NearestMeleeEnemy) FireDelay = GameTicRate*8; //Wait a sec when surrounded by melee shits.
				Return True;
			}
		}
		//==================
		
		//==================
		//RANGED ATTACKS.
		If (FireDelay != 0) //Can't shoot right now and we didn't decide to melee an enemy either.
			Return False;
		
		//TODO: Better aerial target handling.
		/*When fighting fast flying monsters like the quadcopters (Which'll probably need hardcoded handling), be more likely to use the miniguns instead of the
		nose gun, unless the fast flyer is far away. And avoid firing slow rockets much (Or at all) unless the flyer is big, and/or really strong.*/
		
		//Fire rocket pods towards crowds and strong mofos.
		Vector3 FirePos = MVP_StriderAttackPos (ATTACK_ROCKETS); //The position we're firing from.
		Double RocketDist = InCover ? 8192 : 6144;
		//Check if we should fire rockets. As long as it's not too far for the rockets or the LOF for them is bad.
		If (Target && Dist <= RocketDist && ExplosiveDelay <= 0 && KAI_CheckLOF (Target,100,GetDefaultByType("MVP_70mmRocket").ExplosionRadius,FirePos,TLOF_OnlyAhead,"MVP_70mmRocket",GetFAFAimPos(Target,FirePos)))
		{
			Int Chance = AttackByQuantity (Target,GetDefaultByType("MVP_70mmRocket").ExplosionRadius,countorigin:True);
			Chance += Random (0,32);
			If (InCover) Chance += 25;
			If (Random (0,512) < 4) Chance += 60; //Fuck it, we ball.
			If (Health <= WoundHealth) Chance += 25; //Dying
			If (Threat >= ThreatLevelThreshold) Chance += 40;
			
			Bool ImmuneToBlasts = (Target.bNoRadiusDmg || Target.GetRadiusDamage (Target,1024,384,128,False,True) <= 512/8); //The enemy is immune or HIGHLY resistant to blasts.
			
			//Even more likely to fire rockets if the target is not necessarily immune to explosions, however it will still sometimes blast them sometimes even if they are.
			If (!ImmuneToBlasts && Random (0,255) < 128)
				Chance += 80;
			console.printf ("rocket chance %d",chance);
			If (Chance >= Random (80,180))
			{
				AttackType = ATTACK_ROCKETS;
				If (!NoStateJump) SetStateLabel ("Fire.Start");
				Return True;
			}
		}
		
		FirePos = MVP_StriderAttackPos (ATTACK_MINIGUN);
		
		//Fire miniguns if close enough. Especially for very dangerous enemies.
		Int MinigunChance = (Threat >= ThreatLevelThreshold) ? 192 : 128;
		If (InSight && Random (0,255) < MinigunChance &&
		KAI_CheckLOF (Target,1000,0,FirePos,TLOF_OnlyAhead,"MVP_SmallRifleBullet",GetFAFAimPos(Target,FirePos)) &&
		DetermineHitChance (Target,True,Dist,shots:100,FirePos,(10,-10,10,-10),MaxTargetRange,GetFAFPosOffset(Target,GetFAFAimPos(Target,FirePos)),DHC_THRUHOSTILES) >= 30)
		{
			AttackType = ATTACK_MINIGUN;
			Shots = Random (192,255);
			console.printf ("firing miniguns");
			If (!NoStateJump) SetStateLabel ("Fire.Start");
			Return True;
		}
		
		//Fire more accurate machine gun otherwise. With different firing modes like the AAF soldiers and the large ground drone.
		FirePos = MVP_StriderAttackPos (ATTACK_MACHINEGUN);
		If (InSight && KAI_CheckLOF (Target,150,0,FirePos,TLOF_OnlyAhead,"MVP_RifleBullet",GetFAFAimPos(Target,FirePos)))
		{
			AttackType = ATTACK_MACHINEGUN;
			
			Int Boolets = Random (15,30);
			Int Hits = DetermineHitChance (Target,True,Dist,shots:Boolets,FirePos,(1,-1,1,-1),MaxTargetRange,GetFAFPosOffset(Target,GetFAFAimPos(Target,FirePos)),DHC_THRUHOSTILES);
			If (Hits >= Boolets/3) //Over a third hit.
			{
				MGMode = MODE_AUTO;
				Shots = Boolets;
			}
			Else If (Hits < 3) //Bad luck (or aim).
			{
				MGmode = MODE_SINGLE;
				Shots = 1;
			}
			Else If (Hits <= Boolets/3) //Under a third hit but still decent.
			{
				MGMode = MODE_SEMI;
				Shots = 3;
			}
			console.printf ("firing machine gun with %d successful imaginary shots",hits);
			If (!NoStateJump) SetStateLabel ("Fire.Start");
			Return True;
		}
		//==================
		
		Return False;
	}
	
	Void MVP_StriderChase()
	{
		KAI_Chase_PreChecks();
		If (IsDead (Target)) Target = Null;
		KAI_Chase_Retarget(0,True);
		
		Bool MovedAlready; Bool B;
		Int KMTFlags = 0;
		
		//DETERMINE IF WE SHOULD BE MOVING AWAY FROM THE TARGET.
		Bool RunAway = (!bNoFear && (IsFrightening (Target) || bFrightened)); //Run away from spooky actors, or maybe we're just a little bitch.
		//If we're set to run away from targets over our threat threshold that get too close, do so.
		Double RunRange = User_RetreatDistance;
		Int TargetLevel;
		Double DistToTarget;
		Bool TargetInSight;
		If (Target)
		{
			RunRange += Target.Radius;
			TargetLevel = AssessThreatLevel(Target, True);
			DistToTarget = Distance3D(Target);
			TargetInSight = CheckSight (Target,SF_IGNOREWATERBOUNDARY);
		}
		
		If (ReverseSteps > 0) RunAway = True;
		Bool LockedIn = bChaseGoal && Goal; //Don't run away if you have a target but are also patrolling in bChaseGoal mode. Since you do that by just flying around.
		Bool BigThreat = (ThreatLevelThreshold != THREAT_ASSESS && TargetLevel >= ThreatLevelThreshold); //Target's threat level is over the threshold.
		If (RunRange > 0 && !bNoFear && Target && Target != Goal && !LockedIn && BigThreat && DistToTarget <= RunRange && TargetInSight)
		{
			//Try jumping away from the target, with a chance of trying to shot at it too.
			Int MayStrafe = Random (0,2) == 0 ? SJUMP_STRAFE : 0;
			If (MVP_StriderJump (MVP_StriderJumpFromPos (Target.Pos,32,384),flags:SJUMP_STEER | MayStrafe, enemy:Target))
			{
				If (JumpFlags & SJUMP_STRAFE) FireDelay = 0; //So we can fire immediately.
				Return;
			}
			Else If (!RunSteps && !Crouching) //Jumping away from the threat failed, just try running off.
			{
				MVP_StartRun (Random(16,32));
				Return;
			}
			Else If (RunSteps)
				RunAway = True;
		}
		
		//Avoid melee attackers.
		If (!LockedIn && !RunAway && Target && (bAvoidMelee || Level.Info.Flags3 & LEVEL3_AVOIDMELEE))
		{
			Bool IsMeleeAttacker;
			If (!Target.Player && Target.MeleeState) //Melee NPC
			{
				Double Dist = (Target.MeleeRange + Target.Radius)*2;
				IsMeleeAttacker = DistToTarget < Dist;
			}
			Else If (Target.Player && Target.Player.ReadyWeapon && Target.Player.ReadyWeapon.bMeleeWeapon) //Melee player
				IsMeleeAttacker = DistToTarget <= 192;
			
			RunAway = IsMeleeAttacker;
		}
		
		If (Health > WoundHealth) //Ignore weak hazards if not weak yourself, and also projectile attack hazards. We try to dodge those instead.
		{
			Bool Delet; //So we don't permaturely delete and cause VM aborts.
			For (Int I = Hazards.Size()-1; I >= 0; I--)
			{
				Let Haz = Hazards[I];
				If (Haz && Haz.Level <= HazardInfo.HAZARD_LOW)
					Hazards.Delete(I);
				Else If (!Delet && Haz.CustomTags.Size())
				{
					ForEach (CurTag : Haz.CustomTags)
					{
						If (CurTag ~== "Bullet" || CurTag ~== "Projectile")
							Hazards.Delete(I);
					}
				}
			}
		}
		
		If (MVP_StriderDodge())
			Return;
		
		If (MVP_StriderParkour ()) //General handling of climbing, crouching, jumping down, yadda yadda.
			MovedAlready = True;
		
		/*//If surrounded by melee-only enemies and you have enough space, or you are standing on an enemy, jump up sometimes to crush them.
		If (Random (0,255) < 64 && MVP_StriderStandingOnEnemy() || Random (0,255) < 4 && (GetZAt (flags:GZF_CEILING) - Pos.Z+Height) >= 128 && MVP_IsSurrounded())
		{
			//CREDIT: RaveYard for the formula.
			Double JumpHeight = Abs(Pos.Z - Pos.Z+Height)+128;
			Double JumpVel = 0.5 * (sqrt(GetGravity()) * sqrt(GetGravity() + 8 * JumpHeight) + GetGravity());
			console.printf ("jumping up with a velocity of %.2f",jumpvel);
			MVP_StriderJump (Pos.PlusZ(128),JumpVel,SJUMP_CLIMB);
			Return;
		}*/
		
		//Cover located, go there, unless an enemy that can see us (Covered by FindNearestEnemy()) is there.
		If (!KAI_Math.IsEmptyVector3(CoverPos) && !User_NoCover && !MovedAlready)
		{
			Vector3 Real = Pos;
			SetOrigin (CoverPos,True);
			Bool EnemyAtSpot = FindNearestEnemy (192);
			SetOrigin (Real,True);
			If (!KAI_Math.IsEmptyVector3 (CoverPos) && NewPosStepCount <= 128 && Level.Vec3Diff (Pos,CoverPos).Length() >= 24 && !EnemyAtSpot)
			{
				If (BigThreat && !RunSteps && !Crouching)
				{
					MVP_StartRun (Random (16,32));
					Return;
				}
				
				//MAYDO: Make the strider able to attack when heading to cover as long as it's not running there?
				
				KAI_MoveTowards (CoverPos,StriderMove.DetourFactor/2,StriderMove.AngleLimit); //No zigzag.
				
				KAI_DebugPointDelay.KAI_TempPointSpawn(coverpos,8);
				NewPosStepCount++;
				Return;
			}
			Else
			{
				CoverPos = (Double.NaN,Double.NaN,Double.NaN);
				If (NewPosStepCount > 128)
					NewPosStepCount = 0;
				Else
				{
					NewPosStepCount = 0;
					A_FaceTarget();
					A_StopSound (CHAN_BODY);
					InCover = True;
					SetStateLabel ("Idle.Cover");
					Return;
				}
			}
		}
		//Find nearby cover.
		Else If (!User_NoCover)
		{
			CoverPos = KAI_FindNearbyCover(384,Radius*2,Target,False,256,(72,192),(64,40),(Radius,30,100),Self);
		}
		
		HazardInfo Haz;
		If (!RunAway) Haz = GetStrongestHazard(Hazards); //Avoid strongest hazard around if not already busy with backing off from a nearby enemy.
		
		//Keep different distances for targets, by reversing
		If (!LockedIn && !RunAway && TargetInSight && Target && Target != Goal && TargetLevel > THREAT_VERYLOW)
		{
			Double Dist = 0;
			Switch (TargetLevel)
			{
				Case THREAT_UNSTOPPABLE:
					Dist = 1024;
					Break;
				Case THREAT_SUPERDANGER:
					Dist = 896;
					Break;
				Case THREAT_VERYDANGEROUS:
					Dist = 640;
					Break;
				Case THREAT_DANGEROUS:
					Dist = 448;
					Break;
				//Just in case the threshold is changed ^^^^^
				Case THREAT_ABOVENORMAL:
					Dist = 256;
					Break;
				Case THREAT_NORMAL:
					Dist = 192;
					Break;
				Case THREAT_MILD:
				Case THREAT_LOW:
					Dist = 72;
					Break;
				Default:
					Break;
			}
			
			If (Dist > 0) Dist += Target.Radius;
			If (Health <= WoundHealth) //Keep double distance when hurt.
				Dist *= 2;
			
			//Decide to open up a melee window sometimes, even if the enemy has ranged attacks too.
			If (!RunAway && MeleeWindow == 0 && Random (0,255) < 8 &&
			(StriderWhackChecks (Target,TargetLevel,SMELEE_GOODENOUGH) || StriderWhackChecks (Target,TargetLevel,SMELEE_MELEEONLY)))
				MeleeWindow = GameTicRate*Random (4,7);
			
			If (TargetLevel >= ThreatLevelThreshold)
				MeleeWindow = 0;
			
			Bool ShouldRun = (MeleeWindow == 0 && !StriderWhackChecks (Target,TargetLevel,SMELEE_MELEEONLY));
			
			If (ShouldRun && ReverseSteps == 0 && DistToTarget <= Dist+Radius) //Too close to target and we can't kick it, reverse.
			{
				RunAway = True; //In case we otherwise wouldn't run away, like if retreatrange is turned off.
				ReverseSteps = Random (8,16);
			}
			
			//Run from target if hazard isn't closer.
			If (ShouldRun && Dist && DistToTarget <= Dist && !(Haz && Distance3D (Target) <= GetHazardDistance (Haz)))
			{
				RunAway = True;
				Haz = Null; //Signify that we shouldn't run from a hazard later in the function.
			}
		}
		//Also check for scary hazards.
		If (Haz)
		{
			RunAway = True;
			ReverseSteps = 0; //Just run away.
			MeleeWindow = 0;
		}
		
		//Jump away from big crowds of melee enemies. Especially when low on health.
		/*If (!RunAway && Random (0,255) < 16 && MVP_IsSurrounded(384,(Health > WoundHealth) ? 24 : 12,True))
		{console.printf ("too many pinkies");
			Actor NearShit = FindNearestEnemy (384);
			MVP_StriderJump (MVP_StriderJumpFromPos (NearShit.Pos,32,256),flags:SJUMP_STRAFE,enemy:NearShit);
			Return;
		}*/
		
		If (MeleeWindow && Target && !RunSteps && !Crouching) //We decided to open up a window to punt a bitch.
		{
			MVP_StartRun (Random(16,32));
			Return;
		}
		
		//Run away from threat, be it the target itself, a hazard.
		If (!LockedIn && RunAway)
		{
			Vector3 RunPos = (!Haz && Target) ? Target.Pos : GetHazardOriginPos(Haz);
			If (Haz)
			{
				If (MVP_StriderJump (MVP_StriderJumpFromPos (GetHazardOriginPos(Haz),32,384),flags:SJUMP_STEER))
					Return;
				Else If (!RunSteps && !Crouching) //Jumping away from the hazard failed, just try running off.
				{
					MVP_StartRun (Random(16,32));
					Return;
				}
			}
			
			If (Target && RunPos == Target.Pos && BigThreat) //Just run away from very dangerous enemies if you haven't jumped.
				ReverseSteps = 0;
			
			If (ReverseSteps <= 0)
				KAI_MoveAway (Null,StriderMove.Attempts,StriderMove.RunRad,StriderMove.MaxSteps,StriderMove.DetourFactor,StriderMove.AngleLimit,flags:KMTFlags,targpos:RunPos,StriderMove);
			Else //Reverse away from threat.
			{
				RunSteps = 0;
				KMTFlags &= ~(KMT_ZIGZAG); //Don't zigzag when backing off.
				Frame = RevFrame;
				//Int Offset = !Crouching ? 0 : STRIDER_CROUCHFRAMEOFFSET;
				//If (Rev++ >= 3) //Every 4 tics, switch frame.
				{
					//Rev = 0;
					If (RevFrame == FRAME_A)
						RevFrame = FRAME_F;
					Else
						RevFrame--;
				}
				console.printf ("showing sprite %s",texman.getname(curstate.getspritetexture (0,spritenum:sprite,frame)));
				//Tics--; //Reduce tics twice as fast to make it reverse faster.
				Angle -= 180;
				Speed *= 1.2;
				If (!MVP_StriderParkour()) //General handling of climbing, crouching, jumping down, yadda yadda. But for reversing!
					KAI_MoveAway (Null,0,StriderMove.RunRad,6,StriderMove.DetourFactor,StriderMove.AngleLimit,flags:KMTFlags,KMA_STRAIGHT,RunPos,StriderMove);
				Speed /= 1.2;
				Angle += 180;
			}
			
			If (ReverseSteps > 0)
				ReverseSteps--;
			
			Console.Printf ("reversesteps %u",reversesteps);
			
			MovedAlready = True;
		}
		
		//Move to target.
		If (!MovedAlready && Target && Target != Goal && !LockedIn)
		{
			If (DistToTarget >= 768 && !Crouching && !RunSteps && CheckSight(Target,SF_IGNOREWATERBOUNDARY)) //Target too far, run to them.
			{
				MVP_StartRun (Random(32,64));
				Int Chance = DistToTarget >= 3072 ? 10 : 2;
				If (Random (0,512) < Chance) //May leapfrog towards enemy. Especially when really far but still in sight.
				{
					console.printf ("jumping to my enemy, angle to target is %.2f",angle);
					Angle = GetAngleToPos (Target.Pos,StriderMove.AngleLimit*2);
					JumpPos.XY = AngleToVector (Angle, MVP_GetStriderVal(STRIDER_JUMPRANGE));
					JumpPos.XY = Level.Vec2Offset (Pos.XY,JumpPos.XY);
					JumpPos.Z = GetZAt(JumpPos.X,JumpPos.Y);
					MVP_StriderJump (Target.Pos,flags:SJUMP_RUNNING|SJUMP_FAST,True);
				}
				Return;
			}
			KAI_MoveTowards (Target.Pos.PlusZ(Target.Height/2),StriderMove.DetourFactor,StriderMove.AngleLimit,flags:KMTFlags);
			MovedAlready = True;
		}
		
		//Patrol handling.
		If (!MovedAlready)
		{
			[B, MovedAlready] = KAI_Chase_PatrolHandling ("Idle.Stand",StriderMove.DetourFactor,StriderMove.AngleLimit,flags:KMTFlags);
			If (bChaseGoal && Goal && Target != Goal) //Manually go to goal when it "don't chase target" mode.
				KAI_MoveTowards (Goal.Pos,StriderMove.DetourFactor,StriderMove.AngleLimit,flags:KMTFlags);
			If (b && goal) spawn ("kai_debugpoint",goal.pos);
			if (goal)console.printf ("patrolling, goal is at %d %d %d, moved already %d, reached point %d, reactiontime %d",goal.pos,movedalready,b,reactiontime);
		}
		
		If (ShouldAttack ())
			Return;
		HandleChaseTimer();
	}
	
	//Strider is currently surrounded by melee-only enemies, and is also trying to traverse away. AKA, almost certainly overwhelmed by melee enemies.
	Bool MVP_IsSurrounded (Double Range = 128, Int TheThreshold = 6, Bool Stationary = False)
	{
		If (MoveCount <= 0 && !Stationary)
			Return False;
		
		Array <Actor> Enemies;
		Int MeleeShits;
		LookForEnemiesEx (Enemies,Range,False,True);
		
		ForEach (Mobj : Enemies)
		{
			If (Distance2DSquared(Mobj) > Range*Range || Mobj.Pos.Z > Pos.Z+Height || !(Mobj.MeleeState && !Mobj.MissileState)) Continue;
			MeleeShits++;
		}
		
		Return MeleeShits >= TheThreshold;
	}
	
	//Strider is standing on an enemy.
	Actor MVP_StriderStandingOnEnemy()
	{
		Bool FuckYou; Actor TheActualFuckingData;
		SetZ (Pos.Z-1);
		[FuckYou, TheActualFuckingData] = TestMobjZ(True);
		SetZ (Pos.Z+1);
		If (!IsInanimateObject(TheActualFuckingData) && !IsDead (TheActualFuckingData) && IsActorHostile(TheActualFuckingData))
		{
			console.printf ("JUMP ON ENEMY RAAAAAHHHH");
			Return TheActualFuckingData;
		}
		Return Null;
	}
	
	Enum SMELEE_CHECKS //Smelly
	{
		SMELEE_MELEEONLY,
		SMELEE_GOODENOUGH,
	}
	
	Bool StriderWhackChecks (Actor Who, Int Level, Int Type)
	{
		If (!Who)
			Return False;
		
		If (Type == SMELEE_MELEEONLY && Who.MeleeState && !Who.MissileState) //Melee only enemy.
			Return True;
		
		If (Type == SMELEE_GOODENOUGH && Target.MissileState && Level <= THREAT_ABOVENORMAL && Health > WoundHealth)
			Return True;
		
		Return False;
	}
	
	Bool MVP_StartRun (Int Steps)
	{
		If (Crouching)
			Return False;
		RunSteps = Steps;
		If (IsInState (Self,"See"))
			SetStateLabel ("See.Run");
		Else If (IsInState (Self,"Idle"))
			SetStatelabel ("Idle.Run");
		Return True;
	}
	
	Bool MVP_StriderDodge (Bool AlwaysStrafe = False)
	{
		//Dodge projectiles by jumping out of the way.
		Actor Proj;
		Bool B;
		If (!IsIndestructible (Self) && (Proj = MVP_DroneDodge(User_DodgeRange,LastProj)))
		{
			LastProj = Proj;
			Double Delta = DeltaAngle (Proj.Angle,AngleTo(Proj));
			
			Vector3 Block;
			
			Vector3 Left = (Vec2Angle(256,AngleTo(Proj)+90),0);
			Left.Z = GetZAt (Left.X,Left.Y,flags:GZF_ABSOLUTEPOS);
			[B, Block] = IsPosReachable (Left);
			//We can't really go to the left.
			If (!B && Level.Vec3Diff(Pos,Block).Length() <= (Radius*2)+MeleeRange)
				Left = (Double.NaN,Double.NaN,Double.NaN);
			
			Vector3 Right = (Vec2Angle(256,AngleTo(Proj)-90),0);
			Right.Z = GetZAt (Right.X,Right.Y,flags:GZF_ABSOLUTEPOS);
			[B, Block] = IsPosReachable (Right);
			//We can't really go to the left.
			If (!B && Level.Vec3Diff(Pos,Block).Length() <= (Radius*2)+MeleeRange)
				Right = (Double.NaN,Double.NaN,Double.NaN);
			
			//Only dodge if both positions aren't blocked.
			If (!KAI_Math.IsEmptyVector3(Left) || !KAI_Math.IsEmptyVector3(Right))
			{
				Vector3 DodgePos = Delta >= -2 ? Left : Right;
				If (KAI_Math.IsEmptyVector3(Left))
					DodgePos = Right;
				If (KAI_Math.IsEmptyVector3(Right))
					DodgePos = Left;
				
				Int Chance = Health > WoundHealth ? 24 : 48; //More likely to strafe fire when close to dying.
				Int Strafe = (Random (0,255) < Chance) ? SJUMP_STRAFE : 0;
				If (AlwaysStrafe)
					Strafe = SJUMP_STRAFE;
				MVP_StriderJump (DodgePos,flags:SJUMP_FAST|Strafe,enemy:Target);
				Return True;
			}
		}
		Return False;
	}
	
	Bool MVP_StriderParkour()
	{
		//Crouching comes first. Also sneak behind players. MAYDO: Have the sneaking up not be affected by parkour being disabled?
		Crouching = KAI_HandleCrouching(Default.Height,STRIDER_CROUCHHEIGHT);
		If (!Crouching && Target && Target.Player && !Target.CheckFOV (Self,90) && Distance3DSquared (Target) <= 384*384)
			Crouching = True;
			
		If (ReverseSteps == 0 && Crouching && Sprite == GetSpriteIndex ('PNS0')) //Offset into the crouching animation.
			Frame += STRIDER_CROUCHFRAMEOFFSET;
		
		Double JumpFac = (MVP_GetStriderVal(STRIDER_JUMPHEIGHT)/Height)+0.1; //The multiplier of the striders' to use for jumping up and down ledges, should be basically exactly the striders' jump height.
		
		If (!Crouching &&
		//DO NOT CLIMB OVER YOUR COVER
		//BUG: Probably prevents  ̶m̶a̶r̶i̶n̶e̶s̶ striders from climbing at all when running to cover.
		//BUG: Fix Strider getting stuck spazzing up on solid actors. Maybe by checking bOnMobj or something.
		(!KAI_Math.IsEmptyVector3 (CoverPos) || Level.Vec3Diff (Pos,CoverPos).Length() > Radius*1.2))
		{
			If (KAI_HandleClimbing(ClimbPos,JumpPos,"Climb","Jump.Up",0.8,JumpFac))
				Return True;
		}
		
		//Jump over gaps.
		Vector2 JumpPosition = (Double.NaN,Double.NaN);
		Double ZAt = Double.NaN;
		Double JumpVel =  MVP_GetStriderVal(STRIDER_VELOCITY);
		If (!Crouching)
		{
			Double Range = MVP_GetStriderVal(STRIDER_JUMPRANGE);
			
			//KLUDGE: Oh right! We can't make this work simply because the nodes can be in arbitrary positions and KAI_JumpTo() can't solve for ANY component of a ballistic formula!
			/*If (Target && Distance3D (Target) > Range && !IsPosReachable (Target.Pos)) //Parkour to an enemy by jumping to the node closest to them in range (But ONLY on the Z axis).
			{
				Array <Actor> Nodes;
				ForEach (Node : BlockThingsIterator.Create(Target,Distance2D(Target)))
				{
					Node = MVP_StriderJumpSpot(Node);
					//Node is too far away or too high up (Or, down?) to jump to. Or it's lower
					If (!Node || Distance3D(Node) > Range || Abs(Node.Z - Pos.Z) > MVP_GetStriderVal(STRIDER_JUMPHEIGHT))
						Continue;
					
					//This node is useless, it's already in the same vertical plane as us.
					If (Abs (Node.Pos.Z - Pos.Z) <= MaxStepHeight)
						Continue;
					
					Nodes.Push(Node);
					Break;
				}
				If (Nodes.Size())
				{
					
					Double NearestDistance = INT.MAX;
					
					Actor ClosestNode;
					For (Int I = Nodes.Size()-1; I >= 0; I--)
					{
						Double CurrentDistance = Abs (Target.Pos.Z - Nodes[I].Pos.Z);//Level.Vec3Diff(Pos,TempList[I].Pos).LengthSquared();
						If (NearestDistance > CurrentDistance && CurrentDistance <= Range)
						{
							NearestDistance = CurrentDistance;
							ClosestNode = Nodes[I];
						}
					}
		
					If (ClosestNode)
					{
						JumpPosition = ClosestNode.Pos.XY;
						ZAt = ClosestNode.Pos.Z;
						JumpVel *= 2;
					}
				}
			}*/
			
			//Didn't find jump node, so just look for a gap.
			If (JumpPosition != JumpPosition)
				JumpPosition = KAI_GetJumpPosition (Range,Angle);
		}
		If (JumpPosition == JumpPosition && Level.Vec2Diff (Pos.XY,JumpPosition).Length() > 8 && !IsInState (Self,"Idle.Cover")) //We have a valid position we must jump to, AKA the returned vector isn't null.
		{
			If (ZAt != ZAt) ZAt = GetZAt(JumpPosition.X,JumpPosition.Y,flags:GZF_ABSOLUTEPOS);
			If (MVP_StriderJump ((JumpPosition,ZAt),JumpVel,SJUMP_STEER|SJUMP_FACEDIRECTION))
				Return True;
		}
		
		//Climb down obstacles, jumping over gaps takes precedence though so it still jumps even over pits it can climb out of.
		Vector3 GoDown;
		Bool FuckOff;
		[FuckOff, GoDown] = MVP_StriderHandleClimbDown (Height*JumpFac);
		If (FuckOff)
		{
			MVP_StriderJump (GoDown,10);
			Return True;
		}
		
		Return False;
	}
	
	Bool, Vector3 MVP_StriderHandleClimbDown (Double DropoffHeight = 56)
	{
		If (Pos.Z > FloorZ) //In the air.
			Return False, (Double.NaN,Double.NaN,Double.NaN);
		
		Vector2 Ahead = Vec2Angle(Radius*2.2,Angle);
		Double ZAt = GetZAt (Ahead.X,Ahead.Y,0,GZF_ABSOLUTEPOS);
		If (!Level.IsPointInLevel((Ahead,ZAt))) //Welcome to boundary break.
			Return False, (Double.NaN,Double.NaN,Double.NaN);
		If (DropoffHeight > Pos.Z - ZAt && MaxDropoffHeight < Pos.Z - ZAt) //The dropoff height is as tall or shorter than the specified MaxDropoff.
			Return True, (Vec2Angle (104,Angle),ZAt);
		
		Return False, (Double.NaN,Double.NaN,Double.NaN);
	}
	
	Vector3 MVP_StriderJumpFromPos (Vector3 Avoid, Int Attempts, Double Dist)
	{
		Double RealStep = MaxStepHeight;
		MaxStepHeight = MVP_GetStriderVal(STRIDER_JUMPHEIGHT);
		Vector3 Away = FindRandomMovePos (Avoid,Attempts,Dist);
		If (Away.Z > Pos.Z+MaxStepHeight)
			Away = (Double.NaN,Double.NaN,Double.NaN);
		
		//Random move away failed, chart a path that's at most dist away instead.
		If (KAI_Math.IsEmptyVector3 (Away))
		{
			Vector2 Path = AngleToVector (GetAngleToPos(Avoid,0)-180,Dist);
			//Path = Level.Vec2Offset (Pos.XY,Path);
			Double Distance = Path.Length();
			Path /= Distance;
			
			Vector2 Cur;
			Double ZAt;
			//console.printf ("own pos is %d %d",pos.xy);
			//Go from the furthest point away from the Avoid pos in.
			For (Int I = Distance; I >= 0; I -= 16)
			{
				Cur = Level.Vec2Offset(Pos.XY, Path*I);
				console.printf ("curpos is %d %d",cur);
				ZAt = GetZAt(Cur.X,Cur.Y,flags:GZF_ABSOLUTEPOS);
				KAI_DebugPointDelay.KAI_TempPointSpawn((cur,zat),70*2);
				//If (IsPosReachable ((Cur,ZAt)))
				If (ZAt <= Pos.Z+MaxStepHeight)
				{
					Away = (Cur,ZAt);
					Break;
				}
			}
			
			If (Level.Vec3Diff (Pos,Away).Length() <= (Radius*2)+MeleeRange)
				Away = (Double.NaN,Double.NaN,Double.NaN);
		}
		
		MaxStepHeight = RealStep;
		Return Away;
	}
	
	Bool MVP_StriderJump (Vector3 Where, Double Velocity = 0, JFlags Flags = 0, Bool IgnoreDist = False, Actor Enemy = Null)
	{
		//Too far or crammed to jump.
		If (GetZAt(flags:GZF_CEILING)-(Pos.Z+Height) < Height/2 || 
		!IgnoreDist && (Level.Vec2Diff (Pos.XY,Where.XY).Length() > MVP_GetStriderVal(STRIDER_JUMPRANGE) || Where.Z > Pos.Z+MVP_GetStriderVal(STRIDER_JUMPHEIGHT))) 
		{
			console.printf ("can't jump to %.2f %.2f %.2f",where);
			console.printf ("too far, distance is %.2f, limit %.2f",Level.Vec2Diff (Pos.XY,Where.XY).Length(),MVP_GetStriderVal(STRIDER_JUMPRANGE));
			double high = MVP_GetStriderVal(STRIDER_JUMPheight);
			console.printf ("too high?, %d, where.z is %.2f with a total height of %.2f, limit %.2f",(Where.Z > Pos.Z+high),where.z,pos.z+high,high);
			actor fail = KAI_DebugPointDelay.KAI_TempPointSpawn(where,70*2);
			fail.a_settranslation ('kai_debugred');
			Return False;
		}
		
		If (Flags & SJUMP_STRAFE) //If strafe firing while jumping, don't leapfrog or face your jumping direction to not mess that up.
		{
			Flags &= ~ (SJUMP_FACEDIRECTION|SJUMP_RUNNING);
			JumpTarget = Enemy;
		}
		JumpFlags = Flags;
		JumpPos = Where;
		If (Velocity == 0)
			JumpSpeed = MVP_GetStriderVal(STRIDER_VELOCITY);
		Else
			JumpSpeed = Velocity;
		bNoFriction = True; //Go exactly where you're supposed to.
		KAI_DebugPointDelay.KAI_TempPointSpawn(where,70*2);
		SetStateLabel ("Jump");
		Return True;
	}
	
	//Strider loves lean(ing)
	//Returns one of the sprite frames passed, and also a JumpDir
	Int, Int MVP_StriderLean (Int Forward, Int Left, Int Right, Int Back, Bool IgnoreVel = False, Bool FlipSides = False, Int Running = 0)
	{
		If (JumpFlags & SJUMP_RUNNING) //Running jump.
			Return Running, JDIR_NORMAL;
		Double Dir = Vel.XY.Unit() Dot AngleToVector (Angle);
		If (IgnoreVel)
			Dir = AngleToVector (GetAngleToPos(JumpPos,0)) Dot AngleToVector (Angle);
		
		If (Dir <= -0.5) //Facing back
			Return Back, JDIR_BACK;
		Else If (Dir >= 0.5) //Facing forward
			Return Forward, JDIR_NORMAL;
		Else If (Dir <= 0.5 && Dir >= -0.5) //Facing orthogonally, or in actual english, to the side
		{
			Int Diff = FlipSides ? -20 : 20;
			If (DeltaAngle (Angle,GetAngleToPos(JumpPos,0)) < Diff)
				Return Left, JDIR_LEFT;
			Else
				Return Right, JDIR_RIGHT;
		}
		
		Return Forward, JDIR_NORMAL;
	}
	
	Protected Int MVP_StriderLeanIndex (Int Dir)
	{
		If (JumpFlags & SJUMP_RUNNING) //Doing running jump.
			Return GetSpriteIndex ('PNS1');
		
		Switch (Dir)
		{
			Case JDIR_LEFT:
			Case JDIR_RIGHT:
			Case JDIR_BACK:
				Return GetSpriteIndex ('PNS1');
		}
		Return GetSpriteIndex ('PNS0');
	}
	
	Int UpdateStriderElevation (Int FaceDown, Int FaceStraight, Int FaceUp)
	{
		If (Pitch >= 6 && Pitch >= 0)
			Return FaceDown;
		Else If (Pitch < 6 && Pitch >= -15)
			Return FaceStraight;
		Else If (Pitch < -14)
			Return FaceUp;
		
		Return FaceStraight;
	}
	
	Void MVP_UseCrouchAnim()
	{
		//HACK: Because, of course, we can't do a simple offset on the reverse walk animator OR ELSE IT READS OTHER LOADED FRAMES IN MEMORY!!!!!!!!!!!!!!
		If (Crouching)
		{
			Switch (Frame)
			{
				Case FRAME_F:
					Frame = FRAME_R;
					Break;
				Case FRAME_E:
					Frame = FRAME_Q;
					Break;
				Case FRAME_D:
					Frame = FRAME_P;
					Break;
				Case FRAME_C:
					Frame = FRAME_O;
					Break;
				Case FRAME_B:
					Frame = FRAME_N;
					Break;
				Case FRAME_A:
					Frame = FRAME_M;
					Break;
			}
		}
	}
	
	Protected Void MVP_StriderFootsteps (Bool Running)
	{
		If (AttackType == ATTACK_RAMMING)
		{
			If (Frame == FRAME_T || Frame == FRAME_W) //Play stomp sound on frames where it steps on the ground.
				A_StartSound ("Vehicle/Strider/Stomp",flags:CHANF_OVERLAP,volume:FRandom(0.1,0.3));
			Return;
		}
		
		If (Running)
		{
			If (Frame == FRAME_H || Frame == FRAME_K) //Play stomp sound on frames where it steps on the ground.
				A_StartSound ("Vehicle/Strider/Stomp",flags:CHANF_OVERLAP,volume:FRandom(0.1,0.3));
			Return;
		}
		
		If (Crouching)
		{
			If (Frame == FRAME_M || Frame == FRAME_O)
				A_StartSound ("Vehicle/Strider/Stomp",flags:CHANF_OVERLAP,volume:FRandom(0.05,0.1),1.25);
			Return;
		}
		
		If (Frame == FRAME_B || Frame == FRAME_D) //Play stomp sound on frames where it steps on the ground.
			A_StartSound ("Vehicle/Strider/Stomp",flags:CHANF_OVERLAP,volume:FRandom(0.075,0.2));
	}
	
	//Get the hardcoded jump values of the strider. HACK: This only exists because KAI_JumpTo() sucks.
	Double MVP_GetStriderVal (JumpVals What)
	{
		If (User_JumpMode == -1) //Nope
			Return -1;
		If (User_JumpMode == 1) //Normal params
		{
			Switch (What)
			{
				Case STRIDER_JUMPRANGE:
					Return 512;
				Case STRIDER_JUMPHEIGHT:
					Return 256;
				Case STRIDER_VELOCITY:
					Return -17.5;
				Default:
					Return -1;
			}
		}
		If (User_JumpMode == 2) //Extreme params
		{
			Switch (What)
			{
				Case STRIDER_JUMPRANGE:
					Return 1024;
				Case STRIDER_JUMPHEIGHT:
					Return 512;
				Case STRIDER_VELOCITY:
					Return -35;
				Default:
					Return -1;
			}
		}
		
		Return -1;
	}
	
	//Get the relative coordinates from where an attack on the strider comes out of.
	//PLAYTEST: Test the firing offsets (Crouched and uncrouched) for the rocket and grenade launchers.
	Vector3 MVP_StriderAttackPos (StriderAttacks Type)
	{
		Switch (Type)
		{
			Case ATTACK_NONE:
				Return (Double.NaN,Double.NaN,Double.NaN);
			Case ATTACK_MACHINEGUN:
				Return !Crouching ? (0,0,64) : (0,0,48);
			Case ATTACK_MINIGUN: //NOTE: Just flip this after each shot by doing Abs(Y), same with the rockets.
				Return !Crouching ? (0,-12,80) : (0,-12,64);
			Case ATTACK_ROCKETS:
				Return !Crouching ? (0,-12,68) : (0,-12,52);
			Case ATTACK_GRENADE:
				Return !Crouching ? (0,0,88) : (0,0,72);
			Default:
				Return (Double.NaN,Double.NaN,Double.NaN);
		}
	}
	
	Void MVP_StriderStrafeAttack (Bool GoingDown = False)
	{
		//Strafe fire as long as you aren't facing forward. Aiming at the JumpTarget is automatic.
		If (JumpFlags & SJUMP_STRAFE && FireDelay <= 0 && (JumpDir == JDIR_BACK || JumpDir == JDIR_LEFT || JumpDir == JDIR_RIGHT))
		{
			//No jump target, look for another one.
			//BUG: When dodge firing, it will sometimes decide to target dead enemies for some reason.
			If (IsDead(JumpTarget))
			{console.printf ("current jumptarget %p died",jumptarget);
				Vector3 Real = Pos;
				If (JumpTarget) SetOrigin (JumpTarget.Pos,True);
				Else If (Target) SetOrigin (Target.Pos,True);
				JumpTarget = FindNearestEnemy (512);
				SetOrigin (Real,True);console.printf ("attacking %p instead",jumptarget);
			}
			Vector3 FirePos = MVP_StriderAttackPos (ATTACK_MACHINEGUN);
			If (KAI_CheckLOF (JumpTarget,150,0,FirePos,TLOF_OnlyAhead,"MVP_RifleBullet",GetFAFAimPos(JumpTarget,FirePos)))
			{
				Tics = 2;
				A_AttachLightDef ('StrafeLight',"StriderFiringLight");
				//A_RemoveLight ('StrafeLight');
				A_StartSound ("Vehicle/APC/SmallMGFire",CHAN_WEAPON,CHANF_OVERLAP,1.0,0.5);
				Bool B; Actor Proj = A_SpawnProjectile ("MVP_RifleBullet",FirePos.Z,flags:CMF_AIMDIRECTION,Pitch); //pew pew
				AddProjectileSpread (Proj,(1.25,-1.25),(1.25,-1.25));
				[B, Proj] = A_SpawnItemEx ("MVP_BulletCasing",0,0,FirePos.Z,FRandom(4,-4),FRandom(4,8),FRandom(3,8));
				Proj.Scale.X = 0.125; Proj.Scale.Y = 0.104166;
				
				Switch (JumpDir)
				{
					Case JDIR_BACK:
						Frame = !GoingDown ? FRAME_C : FRAME_E;
						Break;
					Case JDIR_LEFT:
						Frame = !GoingDown ? FRAME_J : FRAME_L;
						Break;
					Case JDIR_LEFT:
						Frame = !GoingDown ? FRAME_L : FRAME_J;
						Break;
				}
				
				FireDelay = 4; //This is automatically reduced every tick.
			}
		}
		If (FireDelay > 0)
			A_RemoveLight ('StrafeLight');
	}
	
	Void MVP_StriderRocketBarrage()
	{
		Vector3 FireOfs = MVP_StriderAttackPos (ATTACK_MINIGUN);
		Bool B; Actor Proj;
		
		A_StartSound ("Vehicle/Tank/Artillery3",CHAN_WEAPON,CHANF_OVERLAP,0.6);
		Proj = A_SpawnProjectile ("MVP_70mmRocket",FireOfs.Z,FireOfs.Y,flags:CMF_AIMDIRECTION,Pitch);
		AddProjectileSpread (Proj,(0.65,-0.65),(0.65,-0.65));
		MVP_SpawnBackblastParticles (Self,Random (64,72),(FireOfs.X-16,FireOfs.Y,FireOfs.Z));
		
		A_StartSound ("Vehicle/Tank/Artillery3",CHAN_WEAPON,CHANF_OVERLAP,0.6);
		Proj = A_SpawnProjectile ("MVP_70mmRocket",FireOfs.Z,Abs(FireOfs.Y),flags:CMF_AIMDIRECTION,Pitch);
		AddProjectileSpread (Proj,(0.65,-0.65),(0.65,-0.65));
		MVP_SpawnBackblastParticles (Self,Random (64,72),(FireOfs.X-16,Abs(FireOfs.Y),FireOfs.Z));
		
		MakeAlliesImmuneToExplosion (Self,128);
		A_Explode (128,128,XF_CIRCULAR|XF_CIRCULARTHRUST,False); //Backblast
		RemoveAllyExplosionImmunity();
		
		//Sprite elevations
		If (!Crouching)
			Frame = UpdateStriderElevation (FRAME_O,FRAME_B,FRAME_R);
		Else
		{
			Frame = UpdateStriderElevation(FRAME_BRACKETOPEN,FRAME_BRACKETOPEN,FRAME_U);
			If (Frame == FRAME_BRACKETOPEN)
				Sprite = GetSpriteIndex ('PNS1');
		}
	}
	
	Void MVP_StriderEndFire()
	{
		A_StopSound (CHAN_WEAPON);
		AttackType = ATTACK_NONE;
		Inaccuracy = Default.Inaccuracy;
		InaccuracyFrequency = Default.InaccuracyFrequency;
	}
	
	KAIMoveParams StriderMove;
	KAI_Voice Yapper;
	Int DeathFlames;
	Vector3 CoverPos;
	Vector3 ClimbPos;
	UInt8 RevFrame, Rev;
	UInt8 ReverseSteps; //How many steps to walk backwards for.
	UInt8 RunSteps; //How many steps to stay in one of the Run substates for.
	Bool Crouching;
	Actor LastProj; //Last projectile dodged.
	
	UInt8 AttackType; //What do we attack with currently?
	UInt8 MGMode; //What mode to fire the nose gun at?
	Int Shots; //How many times to use our attack before stopping?
	UInt8 FireDelay; //Time before we can fire again. Used by SJUMP_STRAFE as a delay in the jump loop between shots instead.
	UInt8 MeleeWindow; //If this is not 0 during the chase loop, the Strider will not steer clear of its' target so it can kick it instead.
	Actor MeleeTarget; //Who we are meleeing, normally it's our target but sometimes it can also be some other nearby SOB.
	Actor Rammed;
	Double RamPower;
	UInt16 ExplosiveDelay; //Time before we can fire an explosive weapon again.
	
	Enum StriderAttacks //All strider attacks. The MG, minigun, and rockets visually update the strider to aim and down to the target.
	{
		ATTACK_NONE,
		ATTACK_MACHINEGUN,
		ATTACK_MINIGUN,
		ATTACK_ROCKETS,
		ATTACK_GRENADE,
		ATTACK_PUNT, //Old punt
		ATTACK_ALTPUNT, //NEW punt!!!!!!!!!1
		ATTACK_STOMP,
		ATTACK_RAMMING,
	}
	
	Enum MGModes
	{
		MODE_AUTO,
		MODE_SEMI,
		MODE_SINGLE,
	}
	
	//Cover variables
	Const COVER_WAIT = 350;
	Const COVER_DUCKTIME = 70;
	Bool InCover;
	Int OuttaSightTime; //How long has the target been out of sight while behind cover?
	Int DuckTime; //Dodging by ducking down.
	
	Mixin MVP_DroneVirtuals;
	Mixin MVP_DroneFunctions;
	
	//Jumping variables.
	Vector3 JumpPos;
	Double JumpSpeed; //Passed to KAI_JumpTo()/
	Int JumpFlags; //Flags used for every jump in progress. Then cleared once the jump's done.
	Int JumpDir; //The direction the strider is jumping at.
	Actor JumpTarget; //Who to fire at while mid-jump.
	Const STRIDER_FALLTHRESHOLD = 8; //Minimum negative Z vel need to produce impact effects.
	
	Enum JumpDirs //The direction it starts off jumping to, determined by the angle difference between where it wants to go and its' angle at the time of jumping.
	{
		JDIR_NORMAL, //Standard nondescript jump
		JDIR_LEFT,
		JDIR_RIGHT,
		JDIR_BACK, //Jump backwards
	}
	
	Enum JFlags
	{
		SJUMP_FACEDIRECTION = 1 << 0, //Change angle over time while in the air to face where you're jumping to.
		SJUMP_FAST			= 1 << 1, //Jump faster. Used for running jumps and dodges.
		SJUMP_STEER			= 1 << 2, //Steer yourself to the JumpPos on descent.
		SJUMP_CLIMB			= 1 << 3, //Jump straight up to the climb position. And also only use the generic jump sprites. Used in conjunction with SJUMP_STEER.
		SJUMP_RUNNING		= 1 << 4, //We are leaping to a position on loop.
		SJUMP_STRAFE		= 1 << 5, //The strider can also fire while leaping sideways or backwards.
	}
	
	//Used by the different jump modes.
	Enum JumpVals
	{
		STRIDER_JUMPRANGE,
		STRIDER_JUMPHEIGHT,
		STRIDER_VELOCITY,
	}
	
	UInt8 User_JumpMode; //-1 None, 0 Pick default, 1 Standard (Default), 2 High
	Double User_DodgeRange;
	Double User_RetreatDistance;
	Int User_ChaseTime;
	Bool User_NoCover;
	String User_Color;
	
	Const STRIDER_CROUCHHEIGHT = 64;
	Const STRIDER_RUNFACTOR = 2.5;
	Const STRIDER_CROUCHFRAMEOFFSET = 12; //Offset the PNS0 sprite name by 12 frames (From PNS0A) to map to the crouch animation instead.
	
	States
	{
		StriderSprites: //Do I even need to do this still? Not in the mood to find out.
			PNS1 ABCDEFGHIJKLMNOPQRSTUVWXYZ[] 0;
		Spawn:
			PNS3 A 1
			{
				KAI_Look (LOF_NOJUMP);
				If (Target)
				{
					Int Chance = (Distance3D(Target) <= 1024) ? 64 : 8;
					If (Target.CurSector.LightLevel <= 104)
						Chance += 32;
					If (Random (0,255) < Chance)
						A_StartSound (SeeSound,CHAN_VOICE,attenuation: 0.6);
					Return SeeState;
				}
				
				Return State (Null);
			}
			Loop;
		See:
			PNS0 ABCDEF 4
			{
				RunSteps = 0;
				MVP_StriderChase();
				MVP_StriderFootsteps(False);
				MVP_UseCrouchAnim();
				
				//Debug wandering and random jumping.
				//KAI_Wander (32,384,anglelimit:25);
				/*if (random (0,255) < 8)
				{
					vector3 where = FindRandomMovePos (self.pos,8,checkrad:384);
					//where = vec3angle (randompick(256,-256),RandomPick(90,-90,0,0));
					KAI_DebugPointDelay.KAI_TempPointSpawn(where,70*2);
					MVP_StriderJump (where);
				}*/
			}
			Loop;
		See.Run: //Originally I had made a system that essentially converts See: into this state, but jumping between states is easier so.
			PNS0 GHIJKL 2
			{
				Speed *= STRIDER_RUNFACTOR;
				MVP_StriderChase();
				Speed /= STRIDER_RUNFACTOR;
				MVP_StriderFootsteps(True);
				If (RunSteps > 0)
					RunSteps--;
				If (RunSteps <= 0 || Crouching)
				{
					RunSteps = 0;
					Return SeeState; //Back to walking.
				}
				
				Return State (Null);
			}
			Loop;
		Idle:
			PNS0 ABCDEF 4
			{
				//If (CurrentOrder != ORDER_STAY) MVP_StriderFootsteps(False);
				KAI_Wander (StriderMove.Attempts,StriderMove.RunRad,StriderMove.MaxSteps,StriderMove.DetourFactor,StriderMove.AngleLimit);
			}
			Loop;
		Idle.Run:
			PNS0 GHIJKL 2
			{
				//If (CurrentOrder != ORDER_STAY) MVP_StriderFootsteps(True);
				Speed *= STRIDER_RUNFACTOR;
				KAI_Wander (StriderMove.Attempts,StriderMove.RunRad,StriderMove.MaxSteps,StriderMove.DetourFactor,StriderMove.AngleLimit);
				Speed /= STRIDER_RUNFACTOR;
				
				If (RunSteps > 0)
					RunSteps--;
				If (RunSteps <= 0 || Crouching)
				{
					RunSteps = 0;
					Return FindState ("Idle",True); //Back to walking.
				}
				
				Return State (Null);
			}
			Loop;
		Idle.Stand: //Spinny 360 head state.
			PNS3 ABCDEF 8
			{
				If (Crouching) //No 360 turning for crouching, just sit around.
					Frame = FRAME_O;
				Else
					A_StartSound ("Vehicle/Drone/Turret",CHAN_AUTO,volume:0.5,ATTN_STATIC);
				KAI_Look (LOF_NOJUMP);
				If (Target)
				{
					Int Chance = (Distance3D(Target) <= 1024) ? 64 : 8;
					If (Target.CurSector.LightLevel <= 104)
						Chance += 32;
					If (Random (0,255) < Chance)
						A_StartSound (SeeSound,CHAN_VOICE,attenuation: 0.6);
					Return SeeState;
				}
				
				Return State (Null);
			}
			Loop;
		Idle.Cover:
			PNS1 UVW 4 A_StartSound ("Vehicle/Drone/Turret",CHAN_WEAPON);
			PNS1 W 0 A_StopSound (CHAN_WEAPON);
			//IDEA: This is copied from the tracked drone hull. Maybe replace it with a dedicated chase method for when behind cover?
			PNS1 W 1 //NOTE: We need this delay or otherwise the cover loop quits regardless.
			{
				Actor Proj;
				
				If (--DuckTime <= 0 && (Proj = MVP_DroneDodge(User_DodgeRange)))
				{
					DuckTime = COVER_DUCKTIME;
					A_SetSize (newheight:STRIDER_CROUCHHEIGHT);
					Return State (Null);
				}
				
				If (DuckTime > 0)
					Frame = 26;
				Else
					A_SetSize (newheight:Default.Height);

				If (IsDead (Target))
				{
					Target = Null;
					LookForPlayers (True);
				}
				
				If (!CheckSight (Target, SF_IGNOREWATERBOUNDARY) && OuttaSightTime++ > COVER_WAIT)
				{
					OuttaSightTime = 0;
					Return FindState ("Idle.Cover.End",True);
				}
				
				If (User_NoCover)
					Return FindState ("Idle.Cover.End",True);
				
				Return State (Null);
			}
			PNS1 W 0
			{
				//Stop hiding if the target is behind the cover, another enemy is too close, or if there's no target left.
				Bool InCover = KAI_HasCoverHere(Target,True,64,(72,192),(64,40),(Radius,30,100),Self);
				Actor NearestEnemy = FindNearestEnemy (192);
				
				If (!InCover || !Target || NearestEnemy && NearestEnemy != Target || GetStrongestHazard(Hazards) && GetStrongestHazard(Hazards).Level >= HazardInfo.HAZARD_MEDIUM)
					Return FindState ("Idle.Cover.End",True);
				
				Return State(Null);
			}
			Goto Idle.Cover+4;
		Idle.Cover.End:
			PNS1 VU 4 A_StartSound ("Vehicle/Drone/Turret",CHAN_WEAPON);
			PNS1 U 0
			{
				A_StopSound (CHAN_WEAPON);
				InCover = False;
			}
			Goto See;
		Fire: //Pick a random ranged attack type and begin blasting.
			TNT1 A 0
			{
				AttackType = Random (ATTACK_MACHINEGUN,ATTACK_GRENADE);
				
				If (AttackType == ATTACK_MACHINEGUN)
				{
					Shots = Random (10,30);
					AttackType = ATTACK_MACHINEGUN;
				}
				Else If (AttackType == ATTACK_MINIGUN)
				{
					Shots = Random (192,255);
					AttackType = ATTACK_MINIGUN;
				}
				Else
					Shots = 3;
				
				//Return FindStateByString (Attack,True);
			}
		Fire.Start:
			PNS1 U 0
			{
				If (AttackType == ATTACK_GRENADE) //Skip straight to firing grenades.
					Return FindState ("Fire.Grenade",True);
				If (AttackType == ATTACK_NONE) //Womp womp.
					Return SeeState;
				
				//Set nose gun accuracy before firing.
				If (AttackType == ATTACK_MACHINEGUN)
				{
					Switch (MGMode)
					{
						Case MODE_AUTO:
							Inaccuracy = (32,32,32);
							Break;
						Case MODE_SEMI:
							Inaccuracy = (16,16,16);
							Break;
						Case MODE_SINGLE:
							Inaccuracy = (8,8,8);
							Break;
					}
					
					console.printf ("set nose gun accuracy to %d %d %d",inaccuracy);
				}
				Else If (AttackType == ATTACK_MINIGUN)
					Inaccuracy = (48,48,48); //Bad accuracy, but it does help with a wide AOE due to the fire volume.
				Else If (AttackType == ATTACK_ROCKETS)
				{
					RetargetVehicleHull(); //Target the hull of a vehicle if it makes sense.
					Inaccuracy = (16,16,16);
				}
				
				If (InCover) //Skip the preperation if we're already behind cover.
					Return A_Jump (256,4);
				Return State (Null);
			}
			PNS1 UVW 4 Fast
			{
				If (Crouching) //No prepare animation for the crouch firing.
					Frame = FRAME_BRACKETOPEN;
				Else
					A_StartSound ("Vehicle/Drone/Turret",CHAN_WEAPON);
				
				If (AttackType == ATTACK_MACHINEGUN) //Open faster for the machine gun.
					Tics = 2;
			}
			PNS1 W 0
			{
				A_StopSound (CHAN_WEAPON);
				Switch (AttackType)
				{
					Case ATTACK_MACHINEGUN:
						Return FindState ("Fire.MG",True);
					Case ATTACK_MINIGUN:
						Return FindState ("Fire.Minigun",True);
					Case ATTACK_ROCKETS:
						Return FindState ("Fire.Rocket",True);
				}

				Return State (Null);
			}
		Fire.MG:
			PNS1 X 2 Light ("StriderFiringLight")
			{
				A_StartSound ("Vehicle/APC/SmallMGFire",CHAN_WEAPON,CHANF_OVERLAP,1.0,0.5);
				Vector3 FireOfs = MVP_StriderAttackPos (ATTACK_MACHINEGUN);
				Bool B; Actor Proj = A_SpawnProjectile ("MVP_RifleBullet",FireOfs.Z,flags:CMF_AIMDIRECTION,Pitch); //pew pew
				AddProjectileSpread (Proj,(0.75,-0.75),(0.75,-0.75));
				[B, Proj] = A_SpawnItemEx ("MVP_BulletCasing",0,0,FireOfs.Z,FRandom(4,-4),FRandom(4,8),FRandom(3,8));
				Proj.Scale.X = 0.125; Proj.Scale.Y = 0.104166;
				
				If (!Crouching)
				{
					Frame = UpdateStriderElevation(FRAME_S,FRAME_X,FRAME_P);
					If (Frame != FRAME_X)
						Sprite = GetSpriteIndex ('PNS2');
				}
				Else
				{
					Frame = UpdateStriderElevation(FRAME_BRACKETOPEN,FRAME_BRACKETOPEN,FRAME_U);
					If (Frame == FRAME_U)
						Sprite = GetSpriteIndex ('PNS2');
				}
			}
			PNS1 W 3
			{
				If (MVP_StriderDodge (True))
				{
					MVP_StriderEndFire();
					Return State (Null);
				}
				
				//MAYDO: Make this check into a function so the minigun loop can use it too.
				
				//Dodge very dangerous hazard in range.
				HazardInfo Haz;
				If (bAvoidHazards && Random (0,255) < 128 && (Haz = GetStrongestHazard(Hazards)) && Haz.Level >= HazardInfo.HAZARD_LARGE)
				{
					If (MVP_StriderJump (MVP_StriderJumpFromPos (GetHazardOriginPos(Haz),32,384),flags:SJUMP_STRAFE,enemy:Target))
					{
						MVP_StriderEndFire();
						FireDelay = 0;
						Return State(Null);
					}
				}
				
				//Jump away from nearby enemies when we can.
				Actor Near;
				If (!bNoFear && !(bChaseGoal && Goal) && Random (0,255) < 32 && (Near = FindNearestEnemy (Radius+128)))
				{
					If (MVP_StriderJump (MVP_StriderJumpFromPos (Near.Pos,32,384),flags:SJUMP_STRAFE,enemy:Near))
					{
						MVP_StriderEndFire();
						FireDelay = 0;
						Return State(Null);
					}
				}
				
				//Out of ammo.
				If (Shots-- <= 1)
				{
					Shots = 0;
					FireDelay = Clamp (GameTicRate*Random(1,6),0,UInt8.MAX);
					If (MVP_DroneSwitchTargets(KAI_Actor(Master),2048) && Random (0,255) < 16 && MVP_Strider(Master) && MVP_Strider(Master).Yapper)
						KAI_Actor(Master).SayVoiceLine (VOICE_SEE,MVP_Strider(Master).Yapper);
					Return FindState ("Fire.End",True);
				}
				
				//If (FireMode == MODE_AUTO)
				{
					//If you have no target, or it's dead.
					If (!Target || IsDead (Target))
					{
						A_ClearTarget();
						LookForPlayers (True); //Look for a new target.
					}
					
					Vector3 FireOfs = MVP_StriderAttackPos (ATTACK_MACHINEGUN);
					If (KAI_NPCRefire (16,"Fire.End",True,16) || !KAI_CheckLOF (Target,60,0,FireOfs,0,"MVP_RifleBullet",GetFAFAimPos(Target,FireOfs)))
					{
						A_ClearTarget();
						Return FindState ("Fire.End",True);
					}
				}
				
				HandleChaseTimer();
				
				If (!Crouching)
				{
					Frame = UpdateStriderElevation (FRAME_R,FRAME_W,FRAME_O);
					If (Frame != FRAME_W)
						Sprite = GetSpriteIndex ('PNS2');
				}
				Else
				{
					Frame = UpdateStriderElevation (FRAME_Y,FRAME_Y,FRAME_V);
					If (Frame == FRAME_V)
						Sprite = GetSpriteIndex ('PNS2');
				}
				Return State (Null);
			}
			Loop;
		Fire.Minigun: //Fire the left and right miniguns.
			PNS2 A 1 Light ("StriderFiringLight")
			{
				A_StartSound ("Vehicle/APC/SmallMGFire",CHAN_WEAPON,CHANF_OVERLAP,1.0,0.5);
				A_StartSound ("Vehicle/APC/SmallMGFire",CHAN_WEAPON,CHANF_OVERLAP,1.0,0.5);
				Vector3 FireOfs = MVP_StriderAttackPos (ATTACK_MINIGUN);
				Bool B; Actor Proj;
				
				Proj = A_SpawnProjectile ("MVP_SmallRifleBullet",FireOfs.Z,FireOfs.Y,flags:CMF_AIMDIRECTION,Pitch);
				AddProjectileSpread (Proj,(0.75,-0.75),(0.75,-0.75));
				Proj = A_SpawnProjectile ("MVP_SmallRifleBullet",FireOfs.Z,Abs(FireOfs.Y),flags:CMF_AIMDIRECTION,Pitch);
				AddProjectileSpread (Proj,(0.75,-0.75),(0.75,-0.75));
				
				//Casings fall straight down
				[B, Proj] = A_SpawnItemEx ("MVP_BulletCasing",0,FireOfs.Y,FireOfs.Z,FRandom(1,-1),FRandom(1,-1),0);
				Proj.Scale.X = 0.125; Proj.Scale.Y = 0.104166;
				[B, Proj] = A_SpawnItemEx ("MVP_BulletCasing",0,Abs(FireOfs.Y),FireOfs.Z,FRandom(1,-1),FRandom(1,-1),0);
				Proj.Scale.X = 0.125; Proj.Scale.Y = 0.104166;
				
				If (!Crouching)
					Frame = UpdateStriderElevation (FRAME_T,FRAME_A,FRAME_Q);
				Else
				{
					Frame = UpdateStriderElevation(FRAME_BRACKETOPEN,FRAME_BRACKETOPEN,FRAME_U);
					If (Frame == FRAME_BRACKETOPEN)
						Sprite = GetSpriteIndex ('PNS1');
				}
			}
			PNS2 B 1
			{
				If (MVP_StriderDodge (True))
				{
					MVP_StriderEndFire();
					Return State (Null);
				}
				
				//Stop trying to fire when totally surrounded by melee fuckers.
				If (Random (0,255) < 32 && MVP_IsSurrounded (256,15,True) && FindNearestEnemy (88))
				{
					MVP_StriderEndFire();
					FireDelay = 35;
					Return FindState ("Fire.End",True);
				}
				
				//Dodge very dangerous hazard in range.
				HazardInfo Haz;
				If (bAvoidHazards && Random (0,255) < 128 && (Haz = GetStrongestHazard(Hazards)) && Haz.Level >= HazardInfo.HAZARD_HUGE)
				{
					If (MVP_StriderJump (MVP_StriderJumpFromPos (GetHazardOriginPos(Haz),32,384),flags:SJUMP_STRAFE,enemy:Target))
					{
						MVP_StriderEndFire();
						FireDelay = 0;
						Return State(Null);
					}
				}
				
				//Rarely jump away from the target when we can.
				If (!bNoFear && !(bChaseGoal && Goal) && Random (0,255) < 2 && Target && Distance3D(Target) <= 128+Radius)
				{
					If (MVP_StriderJump (MVP_StriderJumpFromPos (Target.Pos,32,384),flags:SJUMP_STRAFE,enemy:Target))
					{
						MVP_StriderEndFire();
						FireDelay = 0;
						Return State(Null);
					}
				}
				
				//Out of ammo.
				Shots -= 2;
				If (Shots <= 0)
				{
					Shots = 0;
					FireDelay = Clamp (GameTicRate*Random(1,6),0,UInt8.MAX);
					If (MVP_DroneSwitchTargets(KAI_Actor(Master),2048) && Random (0,255) < 16 && MVP_Strider(Master) && MVP_Strider(Master).Yapper)
						KAI_Actor(Master).SayVoiceLine (VOICE_SEE,MVP_Strider(Master).Yapper);
					Return FindState ("Fire.End",True);
				}
				
				//If (FireMode == MODE_AUTO)
				{
					//If you have no target, or it's dead.
					If (!Target || IsDead (Target))
					{
						A_ClearTarget();
						LookForPlayers (True); //Look for a new target.
					}
					
					Vector3 FireOfs = MVP_StriderAttackPos (ATTACK_MINIGUN);
					If (KAI_NPCRefire (88,"Fire.End",True,16) || !KAI_CheckLOF (Target,600,128,FireOfs,0,"MVP_SmallRifleBullet",GetFAFAimPos(Target,FireOfs)))
					{
						A_ClearTarget();
						Return FindState ("Fire.End",True);
					}
				}
				
				HandleChaseTimer();
				
				If (!Crouching)
					Frame = UpdateStriderElevation (FRAME_R,FRAME_B,FRAME_O);
				Else
				{
					Frame = UpdateStriderElevation(FRAME_Z,FRAME_Z,FRAME_W);
					If (Frame == FRAME_Z)
						Sprite = GetSpriteIndex ('PNS1');
				}
				
				Return State (Null);
			}
			Loop;
		Fire.Rocket: //6 rocket barrage
			PNS2 B 3;
			PNS2 B 6 MVP_StriderRocketBarrage();
			PNS2 B 6 MVP_StriderRocketBarrage();
			PNS2 B 6 MVP_StriderRocketBarrage();
			PNS2 B 8
			{
				If (Health > WoundHealth)
					ExplosiveDelay = Clamp (GameTicRate*Random(5,10),0,UInt8.MAX);
				Else
					ExplosiveDelay = Clamp (GameTicRate*Random(3,8),0,UInt8.MAX);
			}
			Goto Fire.End;
		Fire.End:
			PNS1 VU 4 Fast
			{
				If (Crouching) //No prepare animation for the crouch firing.
					Frame = FRAME_BRACKETOPEN;
				Else
					A_StartSound ("Vehicle/Drone/Turret",CHAN_WEAPON);
				If (AttackType == ATTACK_MACHINEGUN) //CLOSE faster for the machine gun.
					Tics = 2;
			}
			PNS1 U 0 MVP_StriderEndFire();
			Goto See;
		Melee:
			TNT1 A 0
			{
				If (Random (False, True) == True)
					Return FindState ("Melee.Stomp");
				Return State (Null); //Fall into kick state.
			}
		Melee.Kick:
			PNS2 I 4 Fast Slow
			{
				A_StartSound ("Vehicle/Strider/Motor",flags:CHANF_OVERLAP); 
				A_Face(MeleeTarget);
				If (AttackType != ATTACK_ALTPUNT) AttackType = ATTACK_PUNT;
			}
			PNS2 J 2 Fast A_Face(MeleeTarget);
			PNS2 K 2 Fast
			{
				If (KAI_CheckMeleeRange (MeleeTarget,flags:CMR_3DDISTANCE))
				{
					A_Face (MeleeTarget);
					
					Int Dmg = MeleeTarget.DamageMobj (Self,Self,10*Random (4,8),'Melee');
					If (Random (False, True))
						TraceBleed (Dmg,MeleeTarget);
					
					If (AttackType != ATTACK_ALTPUNT) //Old punt
					{
						MeleeTarget.Thrust (FRandom (16.0f,24.0f),AngleTo (MeleeTarget));
						MeleeTarget.Vel.Z += FRandom (4.0f,8.0f);
						MeleeTarget.bBlasted = True;
					}
					Else //NEW punt!
										{
						MeleeTarget.Thrust (FRandom (4.0f,8.0f),AngleTo (MeleeTarget));
						MeleeTarget.Vel.Z += FRandom (16.0f,24.0f);
					}
					
					If (MeleeTarget.bNoBlood) //Clank
						A_StartSound ("SFX/MetalHit",flags:CHANF_OVERLAP);
					Else //Plap
						A_StartSound ("SFX/FleshHit",flags:CHANF_OVERLAP);
				}
				Else
					A_StartSound ("Vehicle/Strider/KickFail",flags:CHANF_OVERLAP);
			}
			TNT1 A 0 A_JumpIf (AttackType == ATTACK_ALTPUNT,2);
			PNS2 K 6 Fast Slow;
			Goto Melee.End;
			//Extra frame of kicking straight up.
			PNS2 L 8 Fast Slow;
			PNS2 K 6 Fast Slow;
			Goto Melee.End;
		Melee.Stomp:
			PNS1 S 5 Fast Slow
			{
				A_StartSound ("Vehicle/Strider/Motor",flags:CHANF_OVERLAP); 
				A_Face(MeleeTarget);
				AttackType = ATTACK_STOMP;
			}
			PNS2 LM 4 Fast A_Face(MeleeTarget);
			PNS2 N 2 Fast
			{
				If (MeleeTarget && KAI_CheckMeleeRange (MeleeTarget,flags:CMR_3DDISTANCE))
				{
					A_Face (MeleeTarget);
					
					Int Dmg = MeleeTarget.DamageMobj (Self,Self,10*Random (15,25),'Crush');
					TraceBleed (Dmg,MeleeTarget);
					If (!MeleeTarget.bNoBlood) //Plap
						A_StartSound ("SFX/FleshHit",flags:CHANF_OVERLAP);
					A_StartSound ("Vehicle/Strider/Stomp",flags:CHANF_OVERLAP,0.7);
				}
			}
			PNS2 N 4 Fast Slow;
			Goto Melee.End;
		/*FIXME: I swear the strider sometimes decides to come here from ShouldAttack(), then SOMEHOW aborts without using ANY of the defined exit conditions.
		Which produces the effect of it randomly teleporting forward a bit when in ramming range of the target.*/
		Melee.Ram:
			PNS0 STUVWX 2
			{
				RamPower += 0.01f; //More damage as you run more.
				RamPower = Clamp (RamPower,0.0,1.0);
				If (SmokeCounter++ >= 250) //Stop running after some time.
					Return FindState ("Melee.End",True);
				
				If (IsDead (Target)) //Look for new thing to ram on the fly.
				{
					LookForPlayers (False);
					If (!Target)
						Return FindState ("Melee.End",True);
				}
				
				If ((Health <= WoundHealth || Distance3DSquared (Target) >= 512*512) && MVP_StriderDodge(True)) //Dodge when injured or too far anyway.
				{
					SmokeCounter = 0;
					AttackType = ATTACK_NONE;
					MeleeTarget = Null;
					Return State (Null);
				}
				
				If (Rammed) //Smash up actor.
				{
					Int Dmg = Rammed.DamageMobj (Self,Self,10*Random (25,50)*RamPower,'Melee');
					//If (Random (False, True))
						TraceBleed (Dmg,Rammed);
					
					Double Powah = KAI_Math.LinearMap (Rammed.Mass,0,6000,FRandom (16.0f,24.0f),0); //Scale thrust with mass.
					Rammed.Thrust (Powah,AngleTo (Rammed));
					Rammed.Vel.Z += FRandom (4.0f,8.0f);
					Rammed.bBlasted = True;
					
					If (Rammed.bNoBlood) //Clank
						A_StartSound ("SFX/MetalHit",flags:CHANF_OVERLAP);
					Else //Plap
						A_StartSound ("SFX/FleshHit",flags:CHANF_OVERLAP);
					
					//Very special exit condition, we rammed an enemy at insufficient power to launch them away, so jump away!
					//MAYDO: Make it able to sometimes jump back just to immediately ram again? Particularly against melee only enemies.
					If (RamPower <= 0.5)
					{
						RamPower = 0;
						SmokeCounter = 0;
						AttackType = ATTACK_NONE;
						MeleeTarget = Null;
						MVP_StriderJump (MVP_StriderJumpFromPos (Rammed.Pos,32,256),flags:SJUMP_STRAFE,enemy:Target);
						Rammed = Null;
						Return State(Null);
					}
					Rammed = Null;
					Return FindState ("Melee.End",True);
				}
				
				If (MovementBlockingLine) //Smash up line.
				{
					Destructible.DamageLinedef (MovementBlockingLine,Self,10*Random (25,50)*RamPower,'Melee',Level.ActorOnLineSide(Self,MovementBlockingLine),Self.Pos,False);
					A_QuakeEx (.5,.5,.5,35,0,256,flags:QF_GROUNDONLY|QF_3D,rollintensity:0.5);
					Return FindState ("Melee.End",True);
				}
				
				//NOTE: The walk needs to run afterwards so the blocking line and mobj variables aren't cleared by the next step.
				//RunSteps = 1;
				Speed *= STRIDER_RUNFACTOR;
				KAI_MoveTowards (Target.Pos.PlusZ(Target.Height/2),StriderMove.DetourFactor,StriderMove.AngleLimit);
				Speed /= STRIDER_RUNFACTOR;
				MVP_StriderFootsteps(False);
				
				Return State(Null);
			}
			Loop;
			tnt1 a 0 a_log ("is there some kinda fall through what the fuck is happening here");
		Melee.End:
			TNT1 A 0
			{
				RamPower = 0;
				SmokeCounter = 0;
				AttackType = ATTACK_NONE;
				MeleeTarget = Null;
			}
			Goto See;
		Climb:
			PNS1 R 6 Fast Slow
			{
				Crouching = False;
				A_Stop();
				bNoGravity = True;
			}
			PNS1 S 6 Fast Slow A_StartSound ("Vehicle/Strider/Motor",flags:CHANF_OVERLAP);
			PNS1 T 5 Fast Slow
			{
				bNoGravity = Default.bNoGravity;
				A_SetAngle (GetAngleToPos(Vec3Angle (Speed,Angle),0)); //Face in front of where you climbed to.
				SetOrigin (ClimbPos,False);
				ClimbPos = (Double.NaN,Double.NaN,Double.NaN);
				GiveInventory ("MVP_DropoffToken",1); //HACK: Zandronum Moment
			}
			PNS1 T 0 A_JumpIf (!Target,"Idle");
			Goto See;
		//JUMP STATES
		//You can check if the strider is jumping by seeing if they are in any Jump.##### state.
		Jump:
			Jump.Start:
				#### # Random(5,12) Fast
				{
					If (JumpFlags & SJUMP_FAST)
						Tics = Random (2,6);
					
					If (JumpFlags & SJUMP_STRAFE)
					{
						AttackStates.Push(FindState("Jump.Loop",True));
						AttackStates.Push(FindState("Jump.Loop.Down",True));
					}
					
					[Frame, JumpDir] = MVP_StriderLean (FRAME_Y, FRAME_H, FRAME_G, FRAME_A, True,running: FRAME_Q); //Y, H, G, A
					Sprite = MVP_StriderLeanIndex (JumpDir);

					A_StartSound ("Vehicle/Strider/Motor",flags:CHANF_OVERLAP);
				}
				#### Y 0
				{
					If (!(JumpFlags & SJUMP_CLIMB))
						KAI_JumpTo (JumpPos,JumpSpeed,MVP_GetStriderVal(STRIDER_JUMPRANGE));
					Else
						Vel.Z += JumpSpeed; //Jump straight up to climb.
				}
			Jump.Loop:
				#### # 1
				{
					[Frame, JumpDir] = MVP_StriderLean (FRAME_Z, FRAME_K, FRAME_I, FRAME_B,running: FRAME_O); //Z, K, I, B
					Sprite = MVP_StriderLeanIndex(JumpDir);
				}
				#### # 1
				{
					[Frame, JumpDir] = MVP_StriderLean (FRAME_Z, FRAME_K, FRAME_I, FRAME_B,running: FRAME_O); //Z, K, I, B
					Sprite = MVP_StriderLeanIndex(JumpDir);
					
					If (JumpFlags & SJUMP_FACEDIRECTION && !KAI_Math.IsEmptyVector3 (JumpPos))
						Angle = GetAngleToPos (JumpPos,StriderMove.AngleLimit/5);
					
					MVP_StriderStrafeAttack ();
					
					bNoGravity = Default.bNoGravity; //Always come back down.
					
					//Going down, or maybe we already landed.
					If (Vel.Z <= -2 || bOnMobj || Pos.Z <= FloorZ || Pos.Z <= GetZAt ())
						Return FindState ("Jump.Loop.Down",True);
					
					Return State (Null);
				}
				Goto Jump.Loop+1;
			Jump.Loop.Down:
				//Coming down frame.
				#### # 1
				{
					If (JumpFlags & SJUMP_FACEDIRECTION && !KAI_Math.IsEmptyVector3 (JumpPos))
						Angle = GetAngleToPos (JumpPos,StriderMove.AngleLimit/5);
					If (JumpFlags & SJUMP_STEER && !KAI_Math.IsEmptyVector3 (JumpPos))
						Vel.XY += AngleToVector (GetAngleToPos(JumpPos,0),1);
					[Frame, JumpDir] = MVP_StriderLean (FRAME_BRACKETOPEN,FRAME_I, FRAME_K, FRAME_D,running: FRAME_P); //[, I, K, D
					Sprite = MVP_StriderLeanIndex (JumpDir);
					
					MVP_StriderStrafeAttack (True);
					
					If (bOnMobj || Pos.Z <= FloorZ || Pos.Z <= GetZAt ()) //The eagle has landed.
					{
						//We are leaping towards our JumpPos, so do that until the RunSteps run out. Or the target is now in range or out of sight.
						If (JumpFlags & SJUMP_RUNNING && RunSteps > 0 && !IsDead(Target) &&
						!(Target && (Distance3D(Target) <= 768 || !CheckSight(Target,SF_IGNOREWATERBOUNDARY))))
						{
							If (RunSteps >= 5)
								RunSteps -= 5;
							Else
								RunSteps = 0;
							Angle = GetAngleToPos (Target.Pos,StriderMove.AngleLimit*2);
							console.printf ("leapfrogging to %.2f %.2f %.2f, angle is %.2f, run steps %u",jumppos,angle,runsteps);
							JumpPos.XY = AngleToVector (Angle, MVP_GetStriderVal(STRIDER_JUMPRANGE));
							JumpPos.XY = Level.Vec2Offset (Pos.XY,JumpPos.XY);
							JumpPos.Z = GetZAt(JumpPos.X,JumpPos.Y);
							Return FindState ("Jump");
						}
						Else
							Return FindState ("Jump.End",True);
					}
					
					//Emit a hazard in front of where we're falling towards.
					FLineTraceData Data;
					LineTrace (VectorAngle(Vel.X,Vel.Y),384,-VectorAngle(Vel.XY.Length(),Vel.Z),TRF_BLOCKSELF,Height/2,data:Data);
					
					//Warn NPCs of Strider coming down.
					Array <String> Fall;
					Fall.Push("Vehicle");
					Fall.Push("Crush");
					Fall.Push("VehicleCrush");
					HazardInfo.EmitHazard (Self,Radius*4,HazardInfo.HAZARD_ACTOR,HazardInfo.HAZARD_MEDIUM,tags:Fall,Data.HitLocation,usepos:True);
					
					Return State (Null);
				}
				Loop;
			//MAYDO: Make it lose momentum or have a massive friction penalty once landed so it doesn't slide off thin surface?
			Jump.End: //All comes back here.
				#### # 8
				{
					If (JumpFlags & SJUMP_FAST)
						Tics = 4;
					
					If (JumpFlags & SJUMP_STRAFE)
					{
						AttackStates.Delete (AttackStates.Find(FindState("Jump.Loop",True)));
						AttackStates.Delete (AttackStates.Find(FindState("Jump.Loop.Down",True)));
					}
					
					bNoFriction = Default.bNoFriction; //Do friction again.
					If (JumpFlags & SJUMP_CLIMB) //Do Zandronum moment
						GiveInventory ("MVP_DropoffToken",1);
					
					Sprite = MVP_StriderLeanIndex (JumpDir);
					Frame = MVP_StriderLean (FRAME_BRACKETCLOSE, FRAME_N, FRAME_M, FRAME_F, flipsides: True,running: FRAME_Q); //], N, M, F
					
					JumpFlags = 0;
					JumpDir = 0;
					JumpPos = (Double.NaN,Double.NaN,Double.NaN);
					NextMovePos = (Double.NaN,Double.NaN,Double.NaN);
					JumpTarget = Null;
					//CoverPos = (Double.NaN,Double.NaN,Double.NaN);
				}
				Goto See;
			//Special state for climbing by jumping up. The JumpPos is pre-set for the climb handling during MVP_StriderParkour().
			Jump.Up:
				PNS0 Y 0
				{
					//Double JumpVel = Sqrt(2 * (GetGravity()*GameTicRate) * Abs(JumpPos.Z - Pos.Z));
					Double JumpHeight = Abs(JumpPos.Z - Pos.Z+Height)+64; //Includes dramatic padding.
					//CREDIT: RaveYard for the formula for launching an actor to an exact target height using gravity.
					Double JumpVel = 0.5 * (sqrt(GetGravity()) * sqrt(GetGravity() + 8 * JumpHeight) + GetGravity());
					console.printf ("height diff %2.f, vel %.2f",Abs(JumpPos.Z - Pos.Z+Height),jumpvel);
					MVP_StriderJump (JumpPos,JumpVel,SJUMP_CLIMB|SJUMP_STEER);
				}
				Goto Jump;
		Death:
			PNS9 A 8
			{
				Tics = Random (4,10);
				If (Random (1,4) == 2)
					DeathFlames = Random (80,150)*10;
				
				A_StopSound (CHAN_BODY);
				A_StartSound ("SFX/Fire",CHAN_VOICE,CHANF_LOOPING,0.5,1.1);
				Actor Boom = Spawn ("MVP_Explosion",Pos.PlusZ(48));
				Boom.Scale *= FRandom (1.8f,2.2f);
				Boom.SetDamage (192);
				Boom.MaxTargetRange = 256;
				Boom.MeleeRange = Radius+64;
				Boom.bNoGravity = True;
				Boom.bGetOwner = True;
				Boom.Target = Self; //Does it even matter if we're gone? Very philosophical.
				
				SmokeCounter = Random (8,16);
				Bool B; Actor Debris;
				For (Int I; I <= SmokeCounter; I++)
				{
					[B, Debris] = A_SpawnItemEx ("MVP_DiCokkaDebris",FRandom (Radius,-Radius),FRandom(Radius,-Radius),FRandom (Height-24,Height+24),FRandom (-6,6),FRandom (-6,6),FRandom (2,8));
					If (Debris)
					{
						Debris.Scale *= FRandom (0.1,0.8);
						Debris.bXFlip = Random (False,True);
					}
				}
				
				If (RunSteps)
				{
					Vel.XY += AngleToVector (Angle,Speed*STRIDER_RUNFACTOR*2);
					RunSteps = 0;
					Return FindState ("RunDeath");
				}
				
				If (Random (True, False) == True)
					Return FindState ("AltDeath");
				Return State (Null);
			}
			PNS9 B 4;
			PNS9 C 3;
			PNS9 D -1
			{
				If (GetZAt() <= Pos.Z)
				{
					A_StartSound ("SFX/MetalHit");
					Actor Duster = Spawn ("MVP_GroundDustSpawner",Pos);
					//Pass parameters to spawner.
					Duster.RadiusDamageFactor = 0;
					Duster.ReactionTime = 32;
					Duster.Threshold = Radius*2.25;
					Duster.Scale *= 0.25;
				}
			}
			Stop;
		RunDeath:
			PNS9 HI 4;
			PNS9 J -1
			{
				If (GetZAt() <= Pos.Z)
				{
					A_StartSound ("SFX/MetalHit");
					Actor Duster = Spawn ("MVP_GroundDustSpawner",Pos);
					//Pass parameters to spawner.
					Duster.RadiusDamageFactor = 0;
					Duster.ReactionTime = 32;
					Duster.Threshold = Radius*2.25;
					Duster.Scale *= 0.25;
				}
			}
			Stop;
		//URGENT: TODO: Fix the fucking cropping. Fucking great, can't wait for my entire system to break a THIRD time because of the Strider sprites!!!!!
		AltDeath:
			PNS9 EF 4;
			PNS9 G -1
			{
				If (GetZAt() <= Pos.Z)
				{
					A_StartSound ("SFX/MetalHit");
					Actor Duster = Spawn ("MVP_GroundDustSpawner",(Vec2Angle(24,Angle),Pos.Z));
					//Pass parameters to spawner.
					Duster.RadiusDamageFactor = 0;
					Duster.ReactionTime = 32;
					Duster.Threshold = Radius*2.25;
					Duster.Scale *= 0.5;
				}
			}
			Stop;
		XDeath:
			PNS9 K 8
			{
				Tics = Random (4,10);
				
				A_StopSound (CHAN_BODY);
				Actor Boom = Spawn ("MVP_Explosion",Pos.PlusZ(48));
				Boom.Scale *= FRandom (2.75f,3.5f);
				Boom.SetDamage (256);
				Boom.MaxTargetRange = 384;
				Boom.MeleeRange = Radius+64;
				Boom.bNoGravity = True;
				Boom.bGetOwner = True;
				Boom.Target = Self; //Does it even matter if we're gone? Very philosophical.
				
				Bool Alt = Random (True, False);
				Bool B; Actor Debris;
				//No gibs.
				If (Random (True,False) == True)
				{
					SmokeCounter = Random (48,64);
					
					For (Int I; I <= SmokeCounter; I++)
					{
						[B, Debris] = A_SpawnItemEx ("MVP_DiCokkaDebris",FRandom (Radius,-Radius),FRandom(Radius,-Radius),FRandom (Height-24,Height+24),FRandom (-6,6),FRandom (-6,6),FRandom (2,8));
						If (Debris)
						{
							Debris.Scale *= FRandom (0.1,0.8);
							Debris.bXFlip = Random (False,True);
						}
					}
				}
				Else
				{
					If (!Alt) //No head gib if we are going the XDeath where the whole body is destroyed.
					{
						[B, Debris] =  A_SpawnItemEx ("MVP_StriderHeadGib",zofs:64,FRandom (4,-4),FRandom (-4,-8),FRandom (6,16));
						If (Debris)
						{
							Debris.SmokeCounter = Random (2,6);
							Debris.Master = Self;
						}
					}
					[B, Debris] =  A_SpawnItemEx ("MVP_StriderArmGib",zofs:64,FRandom (-6,-16),FRandom (-6,-12),FRandom (2,8));
					If (Debris)
					{
						Debris.SmokeCounter = Random (2,6);
						Debris.Master = Self;
					}
				}
				
				If (Alt)
					Return FindState ("AltXDeath");
				Return State (Null);
			}
			PNS9 LM 4;
			PNS9 N -1
			{
				A_StartSound ("SFX/MetalHit");
				Actor Duster = Spawn ("MVP_GroundDustSpawner",(Vec2Angle(-24,Angle),Pos.Z));
				//Pass parameters to spawner.
				Duster.RadiusDamageFactor = 0;
				Duster.ReactionTime = 32;
				Duster.Threshold = Radius*2.25;
				Duster.Scale *= 0.5;
			}
			Stop;
		AltXDeath:
			PNS9 OPQ 3;
			PNS9 R -1;
			Stop;
	}
}

//Strider jump hint node, used for example to make it jump up a rooftop if one is nearby, and closer in height to the target than the striders' current position.
Class MVP_StriderJumpSpot : SpecialSpot
{
	Default
	{
		//$Title Strider Jump Spot
		//$Category ZDoom
		//$Sprite MVPEG0
		//IDEA: Maybe use the height and radius fields for something? Like "if the area around this spot isn't clear of obstacles, don't jump here"?
		XScale 0.5;
		YScale 0.416666; //0.5 / 1.2
	}
}

Class MVP_StriderHeadGib : Actor
{
	Default
	{
		Radius 24;
		Height 32;
		XScale 0.8;
		YScale 0.666666; //0.8 / 1.2
		Mass 250;
		+Solid;
		+Shootable;
		//+NoBlockmap;
		+BloodlessImpact;
		+Blasted;
	}
	
	Override Bool CanCollideWith (Actor Other, Bool Passive)
	{
		If (Other && (Other Is GetClassName() || Other == Master))
			Return False;
		Return Super.CanCollideWith (Other, Passive);
	}
	
	States
	{
		Spawn:
			PNS9 STU 4
			{
				Tics = SmokeCounter;
				If (!TestMobjZ(True) || GetZAt ()+1 >= Pos.Z)
					Return FindState("Death");
				
				Return State(Null);
			}
			Loop;
		Death:
			PNS9 V -1
			{
				A_StartSound ("SFX/MetalHit");
				Actor Duster = Spawn ("MVP_GroundDustSpawner",pOS);
				//Pass parameters to spawner.
				Duster.RadiusDamageFactor = 0;
				Duster.ReactionTime = 32;
				Duster.Threshold = Radius*2.25;
				Duster.Scale *= 0.5;
			}
			Stop;
	}
}

Class MVP_StriderArmGib : MVP_StriderHeadGib
{
	Default
	{
		Radius 12;
		Height 16;
		Mass 50;
	}
	States
	{
		Spawn:
			PNS9 XYY 4
			{
				Tics = SmokeCounter;
				If (!TestMobjZ(True) || GetZAt ()+1 >= Pos.Z)
					Return FindState("Death");
				
				Return State(Null);
			}
			Loop;
		Death:
			PNS9 Z -1
			{
				SpriteOffset.Y -= 3;
				A_StartSound ("SFX/MetalHit");
				Actor Duster = Spawn ("MVP_GroundDustSpawner",pOS);
				//Pass parameters to spawner.
				Duster.RadiusDamageFactor = 0;
				Duster.ReactionTime = 32;
				Duster.Threshold = Radius*1.5;
				Duster.Scale *= 0.5;
			}
			Stop;
	}
}

Class MVP_DropoffToken : Inventory
{
	Default {ReactionTime 35;}
	Bool PrevDropoff;
	Override Void AttachToOwner (Actor Other)
	{
		Super.AttachToOwner(Other);
		If (Other && !Other.bDropoff)
		{
			PrevDropoff = Other.bDropoff;
			Other.bDropoff = True;
		}
		Else
			GoAwayAndDie();
	}
	Override Void DoEffect ()
	{
		Super.DoEffect();
		
		If (GetAge() >= ReactionTime)
		{
			If (Owner) Owner.bDropoff = PrevDropoff;
			GoAwayAndDie();
		}
	}
}
//FIXME:
//The climb preperation frame (PNS1R1-8) has the foot spikes appearing over the top of the Striders' feet.
//IIRC one of the grenade frames is missing brightmaps.
//The AltDeath frame of the Strider fully fallen is cropped wrong.
//BUG:
//Seems like the strider sometimes stops attacking and just walks around despite having a target.
//Dodges around too much. UPDATE: Looking at this a month later, gee, real fucking descriptive past me.

//TODO:
//Add kicking (Generic) and stomping (Smol victims) attacks before adding the rest of the ranged attacks. Don't forget to make old punt victims +BLASTED.
	//On this note, also add a random straight up kick variant, and make it a lot less random if the thing it's punting can actually take fall damage :>
//Add hazard zone tagged as crushing when the strider is jumping, that is positioned to where it's going with a short trace.
//Generally add hazard zones for attacks.

//MAYDO:
//Make it so after each ram, the strider always or is very likely to (Try to) jump away from the thing it just rammed.

//IDEA:
//Make it optionally crouch walk when targeting a player for as long as the player can't see them and they're out of their FOV. Yes, literally sneaking up on them.
//For the plain machine gun, add fire modes like on the marines and tracked drone, but maybe based on just distance instead.
//Add jumping SpecialSpots. This requires a proper ballistic function so not happening until then.
//Add an action restrictor for the strider. Such as for stopping it from running in certain parkour-heavy areas.

//HACK: Fucking christ shut up about overriding Tick() you bastard.
Class MVP_Humanoid : KAI_Humanoid
{
	Mixin MVP_DamageSmokeHandling;
	//Mixin MVP_SharedFunctions;
	//Mixin MVP_MarineFunctions;
	Mixin MVP_GenericShit;
	Int SearchTime;
	Int ChaseTimer;
	
	Void HandleChaseTimer()
	{
		//Stop chasing your target after it's out of sight for long enough.
		If (SearchTime > 0)
		{
			If (ChaseTimer >= SearchTime)
			{
				A_ClearTarget();
				ChaseTimer = 0;
				//Vehicles ordered to stay also go back to standing still once the timer runs out.
				If (CurrentOrder == ORDER_STAY)
				{
					SetStateLabel ("Spawn");
					Return;
				}
			}
			
			If (!IsPatrolling(Self))
			{
				If (!Target || Target && !CheckSight (Target,SF_SEEPASTBLOCKEVERYTHING))
					ChaseTimer++;
				//Target is visible again, reset the timer.
				Else
					ChaseTimer = 0;
			}
		}
	}
}

Class MVP_Strider : MVP_Humanoid
{
	Default
	{
		//$Title Strider
		//$Category Vehicles/Panopticon
		//$Sprite PNS3A1
		Mass 1000;
		Health 600;
		WoundHealth 200;
		XScale 0.8;
		YScale 0.666666; //0.8 / 1.2
		Radius 24;
		Height 88;
		DeathHeight 32;
		RipLevelMin 3;
		Speed 10;
		FastSpeed 14;
		FriendlySeeBlocks 64;
		MeleeRange 64;
		MaxStepHeight 32;
		MaxDropoffHeight 32; //This is different from the striders' ability to climb down to areas it has the range to jump back up from.
		Tag "R-11-B Pa≈ùegulo";
		SeeSound "Vehicle/Strider/Alert";
		
		+NoBlood;
		+DontCorpse;
		
		MVP_Humanoid.SmokeDelay 4;
		KAI_Actor.ThreatLevel THREAT_DANGEROUS;
		KAI_Actor.ThreatLevelThreshold THREAT_VERYDANGEROUS;
		KAI_Actor.ActorFollowDist 192;
		KAI_Actor.Inaccuracy (12,12,12);
		KAI_Actor.InaccuracyFrequency 0.6;
		
		//Damage factors that act as the vehicles "armor".
		DamageFactor 0.75; //Generic damage factor for all damage.
		DamageFactor "Melee", 0.3;
		DamageFactor "Electric", 0.4;
		DamageFactor "ExplosiveImpact", 0.7;
		DamageFactor "Explosion", 0.7;
		DamageFactor "Explosive", 0.7;
		DamageFactor "Grenade", 0.7;
		DamageFactor "HitScan", 0.7; //The generic damage type of hitscan attacks.
		DamageFactor "Shrapnel", 0.4;
		DamageFactor "Fire", 0.6;
		DamageFactor "Crush", 1.3;
		DamageFactor "Disintegrate", 1.5;
		DamageFactor "Railgun", 2.0;
		DamageFactor "Falling", 0.0; //No
		
		//Vehicle damage factors
		DamageFactor "Autocannon", 0.8;
		DamageFactor "LargeRifleBullet", 0.9;
		DamageFactor "RifleBullet", 0.8;
		DamageFactor "SmallRifleBullet", 0.6;
	}
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		SearchTime = User_ChaseTime;
		//FireDelay = Random (1,2)*GameTicRate;
		
		StriderMove.DetourFactor = 0.6;
		StriderMove.Attempts = 32;
		StriderMove.MaxSteps = 72;
		StriderMove.RunRad = 394;
		StriderMove.AngleLimit = 25;
		StriderMove.CornerDiv = 8;
		StriderMove.CornerDist = 192;
		
		JumpPos = (Double.NaN,Double.NaN,Double.NaN);
		CoverPos = (Double.NaN,Double.NaN,Double.NaN);
		ClimbPos = (Double.NaN,Double.NaN,Double.NaN);
		
		A_StartSound ("Vehicle/Drone/Motor",CHAN_BODY,CHANF_LOOPING,1,ATTN_STATIC);
		If (KAIHandler) Yapper = KAIHandler.GetNPCVoice ("Panopticon");
		
		MissileState = FindState ("Fire",True); //Fallback state, picks a random attack and amount.
		AttackStates.Push (FindState("Fire.Start",True));
		AttackStates.Push (FindState("Fire.MG",True));
		AttackStates.Push (FindState("Fire.Minigun",True));
		AttackStates.Push (FindState("Fire.Rocket",True));
		AttackStates.Push (FindState("Fire.Grenade",True));
		
		//Melee state is just called "Melee", no need to custom set it, and it functions like Fire:.
		AttackStates.Push (FindState("Melee.Kick",True));
		AttackStates.Push (FindState("Melee.Stomp",True));
		AttackStates.Push (FindState("Melee.Ram",True)); //Special attack where the strider runs up to the target to ram it.
	}
	
	Override Void UserVariableDefaults()
	{
		Super.UserVariableDefaults();
		
		If (User_JumpMode == 0)
			User_JumpMode = 1; //Default jump ranges.
		If (User_DodgeRange == 0)
			User_DodgeRange = 512;
		If (User_RetreatDistance == 0)
			User_RetreatDistance = 512;
		If (User_ChaseTime == 0)
			User_ChaseTime = User_ChaseTime = (35/4)*30;
	}
	
	Protected Double LastTickFallVel;
	
	Override Void Tick()
	{
		If (Vel.Z <= 0) LastTickFallVel = Abs(Vel.Z);
		Else LastTickFallVel = 0;
		
		Super.Tick();
		
		If (IsFrozen()) Return;
		
		If (FireDelay >= 1)
			FireDelay--;
		
		Bool IsDead = IsDead(Self);
		Bool IsAttacking = IsInAttackState();
		
		//Target prediction during attack states.
		If (!IsDead && IsAttacking)
		{
			Vector3 AttackPos = MVP_StriderAttackPos (AttackType);
			FLineTraceData Proj;
			bMissile = True; //HACK: Become missile for TRF_BLOCKSELF.
			LineTrace (Angle,MaxTargetRange,Pitch,TRF_SOLIDACTORS|TRF_BLOCKSELF,AttackPos.Z,AttackPos.X,AttackPos.Y,Proj);
			bMissile = False;
			
			Double ProjSpeed, FastProjSpeed;
			Switch (AttackType) //Change speed generically based on attack. And also emit hazards.
			{
				Case ATTACK_MACHINEGUN:
					ProjSpeed = GetDefaultByType("MVP_RifleBullet").Speed;
					FastProjSpeed = GetDefaultByType("MVP_RifleBullet").FastSpeed;
					
					//Warn actor in LOF.
					HazardInfo MG = New ('HazardInfo');
					MG.Origin = Self;
					MG.Position = Proj.HitLocation;
					MG.Type = HazardInfo.HAZARD_ATTACK;
					MG.Level = HazardInfo.HAZARD_MEDIUM;
					MG.Range = 128;
					Array <String> MGTags; MGTags.Push ("Vehicle"); MGTags.Push ("Bullet");
					MG.CustomTags = MGTags;
					HazardInfo.GiveHazard (Proj.HitActor,MG);
					Break;
				Case ATTACK_MINIGUN:
					ProjSpeed = GetDefaultByType("MVP_SmallRifleBullet").Speed;
					FastProjSpeed = GetDefaultByType("MVP_SmallRifleBullet").FastSpeed;
					
					//Ditto but AOE.
					Array <String> MTags; MTags.Push ("Vehicle"); MTags.Push ("Bullet"); MTags.Push ("Minigun");
					HazardInfo.EmitHazard (Self,256,HazardInfo.HAZARD_ATTACK,HazardInfo.HAZARD_LARGE,tags:MTags,Proj.HitLocation);
					Break;
				Case ATTACK_ROCKETS:
					ProjSpeed = GetDefaultByType("MVP_70mmRocket").Speed;
					FastProjSpeed = GetDefaultByType("MVP_70mmRocket").FastSpeed;
					
					//Explosive hazard.
					//TODO:Add it.
					Break;
				/*Case ATTACK_GRENADE:
					ProjSpeed = GetDefaultByType("MVP_40mmGrenade").Speed;
					FastProjSpeed = GetDefaultByType("MVP_40mmGrenade").FastSpeed;
					Break;*/
			}
			Actor RealTarg = Target;
			Int Turn = 6;
			If (JumpFlags & SJUMP_STRAFE) //Currently strafing.
			{
				Target = JumpTarget;
				//Turn = StriderMove.AngleLimit;
			}
			//HACK: Bizzare hack to account for the striders firing way off their origin, fun part is that this happens in ALL actors I'm pretty sure!
			Int FAF = GetFAFAimPos(Target,AttackPos);
			Double AimOfs = GetFAFPosOffset(Target,FAF);
			SetZ (Pos.Z+AimOfs);
			AimAtTarget (Turn,Turn,flags:FAF,attackspeed:ProjSpeed,fastattackspeed:FastProjSpeed);
			SetZ (Pos.Z-AimOfs);
			if (target)
				kai_lofraycast.visualizetracepath (Pos,level.vec3offset(pos,kai_math.angletovector3d(angle,-pitch,distance3d(target))),distance3d(target));
			Target = RealTarg;
		}
		
		If (LastTickFallVel >= STRIDER_FALLTHRESHOLD*2 && !IsDead && !IsAttacking && !IsInState(Self,"Jump.Loop.Down")){console.printf ("jeronimo");
			SetStateLabel ("Jump.Loop.Down");}
		
		//Run fall impact code.
		//HACK: Yes this is a copy from KAI_BaseVehicle because it's like, the only feature 
		If (Vel.Z ~== 0 && LastTickFallVel && LastTickFallVel >= STRIDER_FALLTHRESHOLD && !IsDead)
		{
			//Get victims under the vehicle.
			Array <Actor> IMFALLINGOVERHERE;
			Vector3 RealPos = Pos;
			SetOrigin (Pos.PlusZ(-LastTickFallVel),False); //Move down the vehicle as if it never stopped, to check for blocking actors in the way.
			BlockThingsIterator Blockers = BlockThingsIterator.Create(Self);
			While (Blockers.Next())
			{
				//Blocking actor found.
				If (Blockers.Thing && Blockers.Thing != Self && IsCollidable(Blockers.Thing,Self) && CheckHitboxIntersection(Self,Blockers.Thing))
					IMFALLINGOVERHERE.Push(Blockers.Thing);
			}
			SetOrigin (RealPos,False);
			
			//COPIED FROM THE MVP STOCK ONGROUNDIMPACT().
			//No actors that we were stopped by, so we probably hit level geometry.
			If (!IMFALLINGOVERHERE.Size())
			{
				Double Force = Mass * LastTickFallVel;
				//Impact sound
				A_StartSound ("Vehicle/Strider/Stomp",CHAN_AUTO,CHANF_OVERLAP,KAI_Math.LinearMap(Force,1000,2500,0.25,1.0),0.65);
				//Impact quake
				Double QuakeForce = KAI_Math.LinearMap(Force,50000,2500000,0.1,4.0);
				Double QuakeRange = KAI_Math.LinearMap(Force,50000,2500000,256,1024);
				Double QuakeThrust = KAI_Math.LinearMap(Force,50000,2500000,0.01,0.5);
				A_QuakeEx (QuakeForce/4,QuakeForce/4,QuakeForce/1,50,QuakeRange,QuakeRange,"",QF_SCALEDOWN|QF_GROUNDONLY|QF_AFFECTACTORS|QF_SHAKEONLY,
				rollintensity:QuakeForce,thrustmultiplier:QuakeThrust);
				//Impact dust
				Actor Duster = Spawn ("MVP_GroundDustSpawner",Pos);
				//Pass parameters to spawner.
				Duster.RadiusDamageFactor = 4;
				Duster.ReactionTime = KAI_Math.LinearMap(Force,100,25000,1,256);
				Duster.Threshold = Radius*1.55;
				Duster.Scale *= 0.5;
			}
			//We hit some actors, crush them and lose some fall speed in exchange (Very realistic and sophisticated physics simulation).
			Else
			{
				Double PostCrushVel = LastTickFallVel;
				//Squish
				Double VelReduction = KAI_Math.LinearMap (Mass,10,2500,10,0.25);
				VelReduction = Clamp (VelReduction,0.25,INT.MAX);
				ForEach (Bug : IMFALLINGOVERHERE)
				{
					Double Force = Mass * PostCrushVel;
					Int ImpactDamage = Force/25;
					Bug.DamageMobj (Self,Self,ImpactDamage,'Crush');
					PostCrushVel -= VelReduction*(Bug.Mass/100); //Reduce fall speed for every bug squashed before applying it back in.
					PostCrushVel = Clamp (PostCrushVel,0,INT.MAX);
					//Play impact sound on each victim based on impact velocity.
					Bug.A_StartSound (Bug.bNoBlood ? "SFX/MetalHit" : "SFX/FleshHit",CHAN_AUTO,CHANF_OVERLAP,KAI_Math.LinearMap(Force,100,2500000,0.075,1.0),0.65);
				}
				
				Vel.Z = -PostCrushVel;
			}
			
			LastTickFallVel = 0;
		}
	}
	
	Override Bool SpawnDamageSmoke()
	{
		Bool Dead = IsDead(Self);
		If (!DeathFlames && Dead) A_StopSound (CHAN_VOICE); //Flames stopped.
		If (!DeathFlames && Dead|| !Super.SpawnDamageSmoke() && !Dead || bIceCorpse) Return False;
		
		If (DeathFlames)
			DeathFlames--;
		
		If (Random (0,255) < 3)
			Spawn ("MVP_Spark",Level.Vec3Offset(Pos,(FRandom (Radius,Radius),FRandom (Radius,-Radius),FRandom (0,Height))));
		
		Int CardAng = GetNearestCardinalAngle(False);
		Vector3 SpawnPos = !Dead ? Vec3Angle (32,CardAng) : Vec3Angle (32,CardAng+135);
		If (IsInState (Self,"AltDeath"))
			SpawnPos = Vec3Angle (48,CardAng-45);
		
		If (!Dead) //Spawn smoke behind engine
			SpawnPos.XY = KAI_Math.RotateAround (Pos.XY,SpawnPos.XY,SpriteRotation);
		Let FX = Dead ? "MVP_BrightFireParticle" : "MVP_DamageSmoke";
		Int Times = !Dead ? 1 : 3;
		For (Int I; I < Times; I++)
		{
			If (!Dead)
				SpawnPos = Level.Vec3Offset (SpawnPos,(FRandom(-16,16),FRandom(-16,16),72));
			Else
				SpawnPos = Level.Vec3Offset (SpawnPos,(FRandom(-16,16),FRandom(-16,16),24));
			
			For (Int I; I < 4; I++)
			{
				If (!Level.IsPointInLevel (SpawnPos))
					Continue;
				Actor Smoke = Spawn (FX,SpawnPos);
				Smoke.Roll = FRandom(-180,180);
				If (!Dead) Smoke.A_SetScale (FRandom(0.25,0.8));
				Else Smoke.A_SetScale (FRandom(0.25,0.5));
				Smoke.Vel.Z = !Dead ? FRandom (1,4) : FRandom (4,8);
			}
		}
		
		Return True;
	}
	
	Override Void Die (Actor Source, Actor Inflictor, Int DMGFlags, Name MeansOfDeath)
	{
		Super.Die (Source, Inflictor, DMGFlags, MeansOfDeath);
		
		A_RemoveLight ('StrafeLight');
		If (JumpFlags & SJUMP_STRAFE)
		{
			AttackStates.Delete (AttackStates.Find(FindState("Jump.Loop",True)));
			AttackStates.Delete (AttackStates.Find(FindState("Jump.Loop.Down",True)));
		}
		bNoFriction = Default.bNoFriction; //Do friction again.
		bNoGravity = Default.bNoGravity; //Do gravity again.
		InCover = False;
	}
	
	Override Bool OnWander()
	{
		KAI_Look(LOF_NOJUMP,FOV: (CurrentOrder == ORDER_STAY && !Crouching) ? 360 : 0,extraflags:KAIL_CHASETARGET);
		If (Target)
		{
			SetState(SeeState);
			Return False;
		}
		
		If (MVP_StriderDodge())
			Return False;
		
		If (MVP_StriderParkour ()) //General handling of climbing, crouching, jumping down, yadda yadda.
			Return False;
		
		//Hazard handling.
		If (Health > WoundHealth) //Ignore weak hazards if not weak yourself, and also projectile attack hazards. We try to dodge those instead.
		{
			For (Int I = Hazards.Size()-1; I >= 0; I--)
			{
				If (Hazards[I] && Hazards[I].Level <= HazardInfo.HAZARD_LOW)
					Hazards.Delete(I);
				
				ForEach (CurTag : Hazards[I].CustomTags)
				{
					If (CurTag ~== "Bullet" || CurTag ~== "Projectile")
						Hazards.Delete(I);
				}
			}
		}
		
		HazardInfo Haz = GetStrongestHazard(Hazards);
		If (Haz)
		{
			If (MVP_StriderJump (MVP_StriderJumpFromPos (GetHazardOriginPos(Haz),32,384)))
				Return False;
			Else If (!RunSteps && !Crouching) //Jumping away from the hazard failed, just try running off.
			{
				MVP_StartRun (Random(16,32));
				Return False;
			}
		}
		
		//Idle around, with 360 vision and looking all around.
		If (CurrentOrder == ORDER_STAY)
		{
			If (Crouching) //No 360 turning for crouching, just sit around.
			{
				Frame = FRAME_O;
				Return False;
			}
			Tics = 8;
			Sprite = GetSpriteIndex ('PNS3');
			A_StartSound ("Vehicle/Drone/Turret",CHAN_AUTO,volume:0.5,ATTN_STATIC);
			Return False;
		}
		
		MVP_UseCrouchAnim();
		
		Vector3 FolPos = (Double.NaN, Double.NaN, Double.NaN); Actor Followee;
		If (CurrentOrder == ORDER_FOLLOW)
			[FolPos, Followee] = HandleFollowingActor (FolPos,True); //NOTE: We turn bDontFollowPlayers on between KAI_Wander calls so lonely drones in a swarm don't do that.
		
		//If (Random(0,2048) == Random (0,2048) && Yapper)
		//	MVP_QuadcopterSpeak();
		
		//Follow something instead.
		If (CurrentOrder == ORDER_FOLLOW)
		{
			If (!KAI_Math.IsEmptyVector3(FolPos))
			{
				Double Dist = Distance3D(Followee);
				//Don't dogpile.
				If (Followee && Dist >= (FollowDist+Followee.Radius))
				{
					If (Dist >= (FollowDist*2) && !Crouching)
						MVP_StartRun (6);
					
					If (Followee) FolPos.Z = Followee.Pos.Z+(Followee.Height/2);
					KAI_MoveTowards (FolPos,StriderMove.DetourFactor,StriderMove.AngleLimit);
					MVP_StriderFootsteps(RunSteps);
					Return False;
				}
				Else If (Followee)
				{
					If (Crouching) //No 360 turning for crouching, just sit around.
					{
						Frame = FRAME_O;
						Return False;
					}
					Tics = 8;
					Sprite = GetSpriteIndex ('PNS3');
					A_StartSound ("Vehicle/Drone/Turret",CHAN_AUTO,volume:0.5,ATTN_STATIC);
					KAI_Look(0,FOV: 360,extraflags:KAIL_CHASETARGET); //NOTE: Look all around, yes, twice, whatever.
					Return False;
				}
			}
		}
		
		MVP_StriderFootsteps(RunSteps);
		
		Return True;
	}
	
	Override Bool ShouldAttack (Bool NoStateJump)
	{
		If (!Target || Target == Goal || FireDelay != 0) Return False; //Don't attack if you have no target or just following a goal.
		If (!CanAttack() || !CanBeTargeted(Self,Target) || IsInanimateObject (Target)) Return False;
		
		Int Threat = AssessThreatLevel (Target);
		Double Dist = Distance3D (Target);
		Bool InSight = CheckSight (Target,SF_IGNOREWATERBOUNDARY); //IDEA: Try to make the grenade launcher fire at out of sight target?
		Vector3 FirePos = MVP_StriderAttackPos (ATTACK_MINIGUN); //The position we're firing from.
		
		//Fire miniguns if close enough. Especially for very dangerous enemies.
		Int MinigunChance = (Threat >= ThreatLevelThreshold) ? 192 : 128;
		If (InSight && Random (0,255) < MinigunChance && KAI_CheckLOF (Target,1000,0,FirePos,TLOF_OnlyAhead,"MVP_SmallRifleBullet",GetFAFAimPos(Target,FirePos)) &&
		DetermineHitChance (Target,True,Dist,shots:100,FirePos,(10,-10,10,-10),MaxTargetRange,GetFAFAimPos(Target,FirePos),DHC_THRUHOSTILES) >= 30)
		{
			Inaccuracy = (32,32,32);
			AttackType = ATTACK_MINIGUN;
			Shots = Random (192,255);
			console.printf ("firing miniguns");
			If (!NoStateJump) SetStateLabel ("Fire.Start");
			Return True;
		}
		FirePos = MVP_StriderAttackPos (ATTACK_MACHINEGUN);
		//Fire more accurate machine gun otherwise.
		If (InSight && KAI_CheckLOF (Target,150,0,FirePos,TLOF_OnlyAhead,"MVP_RifleBullet",GetFAFAimPos(Target,FirePos)))
		{
			AttackType = ATTACK_MACHINEGUN;
			Shots = Random (15,30);
			console.printf ("firing machine gun");
			If (!NoStateJump) SetStateLabel ("Fire.Start");
			Return True;
		}
		
		Return False;
	}
	
	Void MVP_StriderChase()
	{
		KAI_Chase_PreChecks();
		If (IsDead (Target)) Target = Null;
		KAI_Chase_Retarget(0,True);
		
		Bool MovedAlready; Bool B;
		Int KMTFlags = 0;
		
		//DETERMINE IF WE SHOULD BE MOVING AWAY FROM THE TARGET.
		Bool RunAway = (!bNoFear && (IsFrightening (Target) || bFrightened)); //Run away from spooky actors, or maybe we're just a little bitch.
		//If we're set to run away from targets over our threat threshold that get too close, do so.
		Double RunRange = User_RetreatDistance;
		Int TargetLevel;
		Double DistToTarget;
		Bool TargetInSight;
		If (Target)
		{
			RunRange += Target.Radius;
			TargetLevel = AssessThreatLevel(Target, True);
			DistToTarget = Distance3D(Target);
			TargetInSight = CheckSight (Target,SF_IGNOREWATERBOUNDARY);
		}
		
		If (ReverseSteps > 0) RunAway = True;
		Bool LockedIn = bChaseGoal && Goal; //Don't run away if you have a target but are also patrolling in bChaseGoal mode. Since you do that by just flying around.
		Bool BigThreat = (ThreatLevelThreshold != THREAT_ASSESS && TargetLevel >= ThreatLevelThreshold); //Target's threat level is over the threshold.
		If (RunRange > 0 && !bNoFear && Target && Target != Goal && !LockedIn && BigThreat && DistToTarget <= RunRange && TargetInSight)
		{
			If (MVP_StriderJump (MVP_StriderJumpFromPos (Target.Pos,32,384),flags:SJUMP_STEER))
					Return;
			Else If (!RunSteps && !Crouching) //Jumping away from the threat failed, just try running off.
			{
				MVP_StartRun (Random(16,32));
				Return;
			}
			Else If (RunSteps)
				RunAway = True;
		}
		
		//Avoid melee attackers.
		If (!LockedIn && !RunAway && Target && (bAvoidMelee || Level.Info.Flags3 & LEVEL3_AVOIDMELEE))
		{
			Bool IsMeleeAttacker;
			If (!Target.Player && Target.MeleeState) //Melee NPC
			{
				Double Dist = (Target.MeleeRange + Target.Radius)*2;
				IsMeleeAttacker = DistToTarget < Dist;
			}
			Else If (Target.Player && Target.Player.ReadyWeapon && Target.Player.ReadyWeapon.bMeleeWeapon) //Melee player
				IsMeleeAttacker = DistToTarget <= 192;
			
			RunAway = IsMeleeAttacker;
		}
		
		If (Health > WoundHealth) //Ignore weak hazards if not weak yourself, and also projectile attack hazards. We try to dodge those instead.
		{
			For (Int I = Hazards.Size()-1; I >= 0; I--)
			{
				If (Hazards[I] && Hazards[I].Level <= HazardInfo.HAZARD_LOW)
					Hazards.Delete(I);
				
				If (Hazards[I].CustomTags.Size())
				{
					ForEach (CurTag : Hazards[I].CustomTags)
					{
						If (CurTag ~== "Bullet" || CurTag ~== "Projectile")
							Hazards.Delete(I);
					}
				}
			}
		}
		
		If (MVP_StriderDodge())
			Return;
		
		If (MVP_StriderParkour ()) //General handling of climbing, crouching, jumping down, yadda yadda.
			MovedAlready = True;
		
		//If surrounded by melee-only enemies and you have enough space, jump up sometimes to crush them.
		//TODO: Make it also keep jumping up and down if it's standing on top of an enemy.
		If (Random (0,255) < 4 && (GetZAt (flags:GZF_CEILING) - Pos.Z+Height) >= 128 && MVP_IsSurrounded())
		{
			//CREDIT: RaveYard for the formula.
			Double JumpHeight = Abs(Pos.Z - Pos.Z+Height)+128;
			Double JumpVel = 0.5 * (sqrt(GetGravity()) * sqrt(GetGravity() + 8 * JumpHeight) + GetGravity());
			console.printf ("jumping up with a velocity of %.2f",jumpvel);
			MVP_StriderJump (Pos.PlusZ(128),JumpVel,SJUMP_CLIMB);
			Return;
		}
		
		//Cover located, go there, unless an enemy that can see us (Covered by FindNearestEnemy()) is there.
		If (!KAI_Math.IsEmptyVector3(CoverPos) && !User_NoCover && !MovedAlready)
		{
			Vector3 Real = Pos;
			SetOrigin (CoverPos,True);
			Bool EnemyAtSpot = FindNearestEnemy (192);
			SetOrigin (Real,True);
			If (!KAI_Math.IsEmptyVector3 (CoverPos) && NewPosStepCount <= 128 && Level.Vec3Diff (Pos,CoverPos).Length() >= 24 && !EnemyAtSpot)
			{
				If (BigThreat && !RunSteps && !Crouching)
				{
					MVP_StartRun (Random (16,32));
					Return;
				}
				
				//MAYDO: Make the strider able to attack when heading to cover as long as it's not running there?
				
				KAI_MoveTowards (CoverPos,StriderMove.DetourFactor/2,StriderMove.AngleLimit); //No zigzag.
				
				KAI_DebugPointDelay.KAI_TempPointSpawn(coverpos,8);
				NewPosStepCount++;
				Return;
			}
			Else
			{
				CoverPos = (Double.NaN,Double.NaN,Double.NaN);
				If (NewPosStepCount > 128)
					NewPosStepCount = 0;
				Else
				{
					NewPosStepCount = 0;
					A_FaceTarget();
					A_StopSound (CHAN_BODY);
					InCover = True;
					SetStateLabel ("Idle.Cover");
					Return;
				}
			}
		}
		//Find nearby cover.
		Else If (!User_NoCover)
		{
			CoverPos = KAI_FindNearbyCover(384,Radius*2,Target,False,256,(72,192),(64,40),(Radius,30,100),Self);
		}
		
		HazardInfo Haz;
		If (!RunAway) Haz = GetStrongestHazard(Hazards); //Avoid strongest hazard around if not already busy with backing off from a nearby enemy.
		
		//Keep different distances for targets, by reversing
		If (!LockedIn && !RunAway && TargetInSight && Target && Target != Goal)
		{
			Double Dist = 0;
			Switch (TargetLevel)
			{
				Case THREAT_UNSTOPPABLE:
					Dist = 1024;
					Break;
				Case THREAT_SUPERDANGER:
					Dist = 896;
					Break;
				Case THREAT_VERYDANGEROUS:
					Dist = 640;
					Break;
				Case THREAT_DANGEROUS:
					Dist = 448;
					Break;
				//Just in case the threshold is changed ^^^^^
				Case THREAT_ABOVENORMAL:
					Dist = 256;
					Break;
				Case THREAT_NORMAL:
					Dist = 192;
					Break;
				Case THREAT_MILD:
				Case THREAT_LOW:
					Dist = 72;
					Break;
				Case THREAT_VERYLOW:
				Default:
					Break;
			}
			If (Dist > 0) Dist += Target.Radius;
			If (Health <= WoundHealth) //Keep double distance when hurt.
				Dist *= 2;
			
			//MAYDO: Make it ignore this if it can melee the target.
			If (ReverseSteps == 0 && DistToTarget <= Dist+Radius) //Too close to target, reverse.
			{
				RunAway = True; //In case we otherwise wouldn't run away, like if retreatrange is turned off.
				ReverseSteps = Random (8,16);
			}
			
			//Run from target if hazard isn't closer.
			If (Dist && DistToTarget <= Dist && !(Haz && Distance3D (Target) <= GetHazardDistance (Haz)))
			{
				RunAway = True;
				Haz = Null; //Signify that we shouldn't run from a hazard later in the function.
			}
		}
		//Also check for scary hazards.
		If (Haz)
		{
			RunAway = True;
			ReverseSteps = 0; //Just run away.
		}
		
		//Run away from threat, be it the target itself, a hazard.
		If (!LockedIn && RunAway)
		{
			Vector3 RunPos = (!Haz && Target) ? Target.Pos : GetHazardOriginPos(Haz);
			If (Haz)
			{
				If (MVP_StriderJump (MVP_StriderJumpFromPos (GetHazardOriginPos(Haz),32,384),flags:SJUMP_STEER))
					Return;
				Else If (!RunSteps && !Crouching) //Jumping away from the hazard failed, just try running off.
				{
					MVP_StartRun (Random(16,32));
					Return;
				}
			}
			
			If (Target && RunPos == Target.Pos && BigThreat) //Just run away from very dangerous enemies if you haven't jumped.
				ReverseSteps = 0;
			
			If (ReverseSteps <= 0)
				KAI_MoveAway (Null,StriderMove.Attempts,StriderMove.RunRad,StriderMove.MaxSteps,StriderMove.DetourFactor,StriderMove.AngleLimit,flags:KMTFlags,targpos:RunPos,StriderMove);
			Else //Reverse away from threat.
			{
				RunSteps = 0;
				KMTFlags &= ~(KMT_ZIGZAG); //Don't zigzag when backing off.
				Frame = RevFrame;
				//Int Offset = !Crouching ? 0 : STRIDER_CROUCHFRAMEOFFSET;
				//If (Rev++ >= 3) //Every 4 tics, switch frame.
				{
					//Rev = 0;
					If (RevFrame == FRAME_A)
						RevFrame = FRAME_F;
					Else
						RevFrame--;
				}
				console.printf ("showing sprite %s",texman.getname(curstate.getspritetexture (0,spritenum:sprite,frame)));
				//Tics--; //Reduce tics twice as fast to make it reverse faster.
				Angle -= 180;
				Speed *= 1.2;
				If (!MVP_StriderParkour()) //General handling of climbing, crouching, jumping down, yadda yadda. But for reversing!
					KAI_MoveAway (Null,0,StriderMove.RunRad,6,StriderMove.DetourFactor,StriderMove.AngleLimit,flags:KMTFlags,KMA_STRAIGHT,RunPos,StriderMove);
				Speed /= 1.2;
				Angle += 180;
			}
			
			If (ReverseSteps > 0)
				ReverseSteps--;
			
			Console.Printf ("reversesteps %u",reversesteps);
			
			MovedAlready = True;
		}
		
		//Move to target.
		If (!MovedAlready && Target && Target != Goal && !LockedIn)
		{
			If (DistToTarget >= 768 && !Crouching && !RunSteps && CheckSight(Target,SF_IGNOREWATERBOUNDARY)) //Target too far, run to them.
			{
				MVP_StartRun (Random(32,64));
				Int Chance = DistToTarget >= 3072 ? 8 : 2;
				If (Random (0,512) < Chance) //May leapfrog towards enemy. Especially when really far but still in sight.
				{
					console.printf ("jumping to my enemy, angle to target is %.2f",angle);
					Angle = GetAngleToPos (Target.Pos,StriderMove.AngleLimit*2);
					JumpPos.XY = AngleToVector (Angle, MVP_GetStriderVal(STRIDER_JUMPRANGE));
					JumpPos.XY = Level.Vec2Offset (Pos.XY,JumpPos.XY);
					JumpPos.Z = GetZAt(JumpPos.X,JumpPos.Y);
					MVP_StriderJump (Target.Pos,flags:SJUMP_RUNNING|SJUMP_FAST,True);
				}
				Return;
			}
			KAI_MoveTowards (Target.Pos.PlusZ(Target.Height/2),StriderMove.DetourFactor,StriderMove.AngleLimit,flags:KMTFlags);
			MovedAlready = True;
		}
		
		//Patrol handling.
		If (!MovedAlready)
		{
			[B, MovedAlready] = KAI_Chase_PatrolHandling ("Spawn",StriderMove.DetourFactor,StriderMove.AngleLimit,flags:KMTFlags);
			If (bChaseGoal && Goal && Target != Goal) //Manually go to goal when it "don't chase target" mode.
				KAI_MoveTowards (Goal.Pos,StriderMove.DetourFactor,StriderMove.AngleLimit,flags:KMTFlags);
			If (b && goal) spawn ("kai_debugpoint",goal.pos);
			if (goal)console.printf ("patrolling, goal is at %d %d %d, moved already %d, reached point %d, reactiontime %d",goal.pos,movedalready,b,reactiontime);
		}
		
		If (ShouldAttack ())
			Return;
		HandleChaseTimer();
	}
	
	//Strider is currently surrounded by melee-only enemies, and is also trying to traverse away. AKA, almost certainly overwhelmed by melee enemies.
	Bool MVP_IsSurrounded (Double Range = 128, Int TheThreshold = 6)
	{
		If (MoveCount <= 0)
			Return False;
		
		Array <Actor> Enemies;
		Int MeleeShits;
		LookForEnemiesEx (Enemies,Range,False,True);
		
		ForEach (Mobj : Enemies)
		{
			If (IsDead (Mobj) || Distance2DSquared(Mobj) > Range*Range || Mobj.Pos.Z > Pos.Z+Height|| !(Mobj.MeleeState && !Mobj.MissileState)) Continue;
			
			MeleeShits++;
		}
		
		Return MeleeShits >= TheThreshold;
	}
	
	Bool MVP_StartRun (Int Steps)
	{
		If (Crouching)
			Return False;
		RunSteps = Steps;
		If (IsInState (Self,"See"))
			SetStateLabel ("See.Run");
		Else If (IsInState (Self,"Idle"))
			SetStatelabel ("Idle.Run");
		Return True;
	}
	
	Bool MVP_StriderDodge (Bool AlwaysStrafe = False)
	{
		//Dodge projectiles by jumping out of the way.
		Actor Proj;
		Bool B;
		If (!IsIndestructible (Self) && (Proj = MVP_DroneDodge(User_DodgeRange,LastProj)))
		{
			LastProj = Proj;
			Double Delta = DeltaAngle (Proj.Angle,AngleTo(Proj));
			
			Vector3 Block;
			
			Vector3 Left = (Vec2Angle(256,AngleTo(Proj)+90),0);
			Left.Z = GetZAt (Left.X,Left.Y,flags:GZF_ABSOLUTEPOS);
			[B, Block] = IsPosReachable (Left);
			//We can't really go to the left.
			If (!B && Level.Vec3Diff(Pos,Block).Length() <= (Radius*2)+MeleeRange)
				Left = (Double.NaN,Double.NaN,Double.NaN);
			
			Vector3 Right = (Vec2Angle(256,AngleTo(Proj)-90),0);
			Right.Z = GetZAt (Right.X,Right.Y,flags:GZF_ABSOLUTEPOS);
			[B, Block] = IsPosReachable (Right);
			//We can't really go to the left.
			If (!B && Level.Vec3Diff(Pos,Block).Length() <= (Radius*2)+MeleeRange)
				Right = (Double.NaN,Double.NaN,Double.NaN);
			
			//Only dodge if both positions aren't blocked.
			If (!KAI_Math.IsEmptyVector3(Left) || !KAI_Math.IsEmptyVector3(Right))
			{
				Vector3 DodgePos = Delta >= -2 ? Left : Right;
				If (KAI_Math.IsEmptyVector3(Left))
					DodgePos = Right;
				If (KAI_Math.IsEmptyVector3(Right))
					DodgePos = Left;
				
				Int Chance = Health > WoundHealth ? 24 : 48; //More likely to strafe fire when close to dying.
				Int Strafe = (Random (0,255) < Chance) ? SJUMP_STRAFE : 0;
				If (AlwaysStrafe)
					Strafe = SJUMP_STRAFE;
				MVP_StriderJump (DodgePos,flags:SJUMP_FAST|Strafe,enemy:Target);
				Return True;
			}
		}
		Return False;
	}
	
	Bool MVP_StriderParkour()
	{
		//Crouching comes first.
		Crouching = KAI_HandleCrouching(Default.Height,STRIDER_CROUCHHEIGHT);
		If (ReverseSteps == 0 && Crouching && Sprite == GetSpriteIndex ('PNS0')) //Offset into the crouching animation.
			Frame += STRIDER_CROUCHFRAMEOFFSET;
		
		Double JumpFac = (MVP_GetStriderVal(STRIDER_JUMPHEIGHT)/Height)+0.1; //The multiplier of the striders' to use for jumping up and down ledges, should be basically exactly the striders' jump height.
		
		If (!Crouching &&
		//DO NOT CLIMB OVER YOUR COVER
		//BUG: Probably prevents  Ã∂mÃ∂aÃ∂rÃ∂iÃ∂nÃ∂eÃ∂sÃ∂ striders from climbing at all when running to cover.
		//BUG: Fix Strider getting stuck spazzing up on solid actors.
		(!KAI_Math.IsEmptyVector3 (CoverPos) || Level.Vec3Diff (Pos,CoverPos).Length() > Radius*1.2))
		{
			If (KAI_HandleClimbing(ClimbPos,JumpPos,"Climb","Jump.Up",0.8,JumpFac))
				Return True;
		}
		
		//Jump over gaps.
		Vector2 JumpPosition = (Double.NaN,Double.NaN);
		Double ZAt = Double.NaN;
		Double JumpVel =  MVP_GetStriderVal(STRIDER_VELOCITY);
		If (!Crouching)
		{
			Double Range = MVP_GetStriderVal(STRIDER_JUMPRANGE);
			
			//KLUDGE: Oh right! We can't make this work simply because the nodes can be in arbitrary positions and KAI_JumpTo() can't solve for ANY component of a ballistic formula!
			/*If (Target && Distance3D (Target) > Range && !IsPosReachable (Target.Pos)) //Parkour to an enemy by jumping to the node closest to them in range (But ONLY on the Z axis).
			{
				Array <Actor> Nodes;
				ForEach (Node : BlockThingsIterator.Create(Target,Distance2D(Target)))
				{
					Node = MVP_StriderJumpSpot(Node);
					//Node is too far away or too high up (Or, down?) to jump to. Or it's lower
					If (!Node || Distance3D(Node) > Range || Abs(Node.Z - Pos.Z) > MVP_GetStriderVal(STRIDER_JUMPHEIGHT))
						Continue;
					
					//This node is useless, it's already in the same vertical plane as us.
					If (Abs (Node.Pos.Z - Pos.Z) <= MaxStepHeight)
						Continue;
					
					Nodes.Push(Node);
					Break;
				}
				If (Nodes.Size())
				{
					
					Double NearestDistance = INT.MAX;
					
					Actor ClosestNode;
					For (Int I = Nodes.Size()-1; I >= 0; I--)
					{
						Double CurrentDistance = Abs (Target.Pos.Z - Nodes[I].Pos.Z);//Level.Vec3Diff(Pos,TempList[I].Pos).LengthSquared();
						If (NearestDistance > CurrentDistance && CurrentDistance <= Range)
						{
							NearestDistance = CurrentDistance;
							ClosestNode = Nodes[I];
						}
					}
		
					If (ClosestNode)
					{
						JumpPosition = ClosestNode.Pos.XY;
						ZAt = ClosestNode.Pos.Z;
						JumpVel *= 2;
					}
				}
			}*/
			
			//Didn't find jump node, so just look for a gap.
			If (JumpPosition != JumpPosition)
				JumpPosition = KAI_GetJumpPosition (Range,Angle);
		}
		If (JumpPosition == JumpPosition && Level.Vec2Diff (Pos.XY,JumpPosition).Length() > 8 && !IsInState (Self,"Idle.Cover")) //We have a valid position we must jump to, AKA the returned vector isn't null.
		{
			If (ZAt != ZAt) ZAt = GetZAt(JumpPosition.X,JumpPosition.Y,flags:GZF_ABSOLUTEPOS);
			If (MVP_StriderJump ((JumpPosition,ZAt),JumpVel,SJUMP_STEER|SJUMP_FACEDIRECTION))
				Return True;
		}
		
		//Climb down obstacles, jumping over gaps takes precedence though so it still jumps even over pits it can climb out of.
		Vector3 GoDown;
		Bool FuckOff;
		[FuckOff, GoDown] = MVP_StriderHandleClimbDown (Height*JumpFac);
		If (FuckOff)
		{
			MVP_StriderJump (GoDown,10);
			Return True;
		}
		
		Return False;
	}
	
	Bool, Vector3 MVP_StriderHandleClimbDown (Double DropoffHeight = 56)
	{
		If (Pos.Z > FloorZ) //In the air.
			Return False, (Double.NaN,Double.NaN,Double.NaN);
		
		Vector2 Ahead = Vec2Angle(Radius*2.2,Angle);
		Double ZAt = GetZAt (Ahead.X,Ahead.Y,0,GZF_ABSOLUTEPOS);
		If (!Level.IsPointInLevel((Ahead,ZAt))) //Welcome to boundary break.
			Return False, (Double.NaN,Double.NaN,Double.NaN);
		If (DropoffHeight > Pos.Z - ZAt && MaxDropoffHeight < Pos.Z - ZAt) //The dropoff height is as tall or shorter than the specified MaxDropoff.
			Return True, (Vec2Angle (104,Angle),ZAt);
		
		Return False, (Double.NaN,Double.NaN,Double.NaN);
	}
	
	Vector3 MVP_StriderJumpFromPos (Vector3 Avoid, Int Attempts, Double Dist)
	{
		Double RealStep = MaxStepHeight;
		MaxStepHeight = MVP_GetStriderVal(STRIDER_JUMPHEIGHT);
		Vector3 Away = FindRandomMovePos (Avoid,Attempts,Dist);
		If (Away.Z > Pos.Z+MaxStepHeight)
			Away = (Double.NaN,Double.NaN,Double.NaN);
		
		//Random move away failed, chart a path that's at most dist away instead.
		If (KAI_Math.IsEmptyVector3 (Away))
		{
			Vector2 Path = AngleToVector (GetAngleToPos(Avoid,0)-180,Dist);
			//Path = Level.Vec2Offset (Pos.XY,Path);
			Double Distance = Path.Length();
			Path /= Distance;
			
			Vector2 Cur;
			Double ZAt;
			//console.printf ("own pos is %d %d",pos.xy);
			//Go from the furthest point away from the Avoid pos in.
			For (Int I = Distance; I >= 0; I -= 16)
			{
				Cur = Level.Vec2Offset(Pos.XY, Path*I);
				console.printf ("curpos is %d %d",cur);
				ZAt = GetZAt(Cur.X,Cur.Y,flags:GZF_ABSOLUTEPOS);
				KAI_DebugPointDelay.KAI_TempPointSpawn((cur,zat),70*2);
				//If (IsPosReachable ((Cur,ZAt)))
				If (ZAt <= Pos.Z+MaxStepHeight)
				{
					Away = (Cur,ZAt);
					Break;
				}
			}
			
			If (Level.Vec3Diff (Pos,Away).Length() <= (Radius*2)+MeleeRange)
				Away = (Double.NaN,Double.NaN,Double.NaN);
		}
		
		MaxStepHeight = RealStep;
		Return Away;
	}
	
	Bool MVP_StriderJump (Vector3 Where, Double Velocity = 0, JFlags Flags = 0, Bool IgnoreDist = False, Actor Enemy = Null)
	{
		//Too far or crammed to jump.
		If (GetZAt(flags:GZF_CEILING)-(Pos.Z+Height) < Height/2 || 
		!IgnoreDist && (Level.Vec2Diff (Pos.XY,Where.XY).Length() > MVP_GetStriderVal(STRIDER_JUMPRANGE) || Where.Z > Pos.Z+MVP_GetStriderVal(STRIDER_JUMPHEIGHT))) 
		{
			console.printf ("can't jump to %.2f %.2f %.2f",where);
			console.printf ("too far, distance is %.2f, limit %.2f",Level.Vec2Diff (Pos.XY,Where.XY).Length(),MVP_GetStriderVal(STRIDER_JUMPRANGE));
			double high = MVP_GetStriderVal(STRIDER_JUMPheight);
			console.printf ("too high?, %d, where.z is %.2f with a total height of %.2f, limit %.2f",(Where.Z > Pos.Z+high),where.z,pos.z+high,high);
			actor fail = KAI_DebugPointDelay.KAI_TempPointSpawn(where,70*2);
			fail.a_settranslation ('kai_debugred');
			Return False;
		}
		
		If (Flags & SJUMP_STRAFE) //If strafe firing while jumping, don't leapfrog or face your jumping direction to not mess that up.
		{
			Flags &= ~ (SJUMP_FACEDIRECTION|SJUMP_RUNNING);
			JumpTarget = Enemy;
		}
		JumpFlags = Flags;
		JumpPos = Where;
		If (Velocity == 0)
			JumpSpeed = MVP_GetStriderVal(STRIDER_VELOCITY);
		Else
			JumpSpeed = Velocity;
		bNoFriction = True; //Go exactly where you're supposed to.
		KAI_DebugPointDelay.KAI_TempPointSpawn(where,70*2);
		SetStateLabel ("Jump");
		Return True;
	}
	
	//Strider loves lean(ing)
	//Returns one of the sprite frames passed, and also a JumpDir
	Int, Int MVP_StriderLean (Int Forward, Int Left, Int Right, Int Back, Bool IgnoreVel = False, Bool FlipSides = False, Int Running = 0)
	{
		If (JumpFlags & SJUMP_RUNNING) //Running jump.
			Return Running, JDIR_NORMAL;
		Double Dir = Vel.XY.Unit() Dot AngleToVector (Angle);
		If (IgnoreVel)
			Dir = AngleToVector (GetAngleToPos(JumpPos,0)) Dot AngleToVector (Angle);
		
		If (Dir <= -0.5) //Facing back
			Return Back, JDIR_BACK;
		Else If (Dir >= 0.5) //Facing forward
			Return Forward, JDIR_NORMAL;
		Else If (Dir <= 0.5 && Dir >= -0.5) //Facing orthogonally, or in actual english, to the side
		{
			Int Diff = FlipSides ? -20 : 20;
			If (DeltaAngle (Angle,GetAngleToPos(JumpPos,0)) < Diff)
				Return Left, JDIR_LEFT;
			Else
				Return Right, JDIR_RIGHT;
		}
		
		Return Forward, JDIR_NORMAL;
	}
	
	Protected Int MVP_StriderLeanIndex (Int Dir)
	{
		If (JumpFlags & SJUMP_RUNNING) //Doing running jump.
			Return GetSpriteIndex ('PNS1');
		
		Switch (Dir)
		{
			Case JDIR_LEFT:
			Case JDIR_RIGHT:
			Case JDIR_BACK:
				Return GetSpriteIndex ('PNS1');
		}
		Return GetSpriteIndex ('PNS0');
	}
	
	Int UpdateStriderElevation (Int FaceDown, Int FaceStraight, Int FaceUp)
	{
		If (Pitch >= 6 && Pitch >= 0)
			Return FaceDown;
		Else If (Pitch < 6 && Pitch >= -15)
			Return FaceStraight;
		Else If (Pitch < -14)
			Return FaceUp;
		
		Return FaceStraight;
	}
	
	Void MVP_UseCrouchAnim()
	{
		//HACK: Because, of course, we can't do a simple offset on the reverse walk animator OR ELSE IT READS OTHER LOADED FRAMES IN MEMORY!!!!!!!!!!!!!!
		If (Crouching)
		{
			Switch (Frame)
			{
				Case FRAME_F:
					Frame = FRAME_R;
					Break;
				Case FRAME_E:
					Frame = FRAME_Q;
					Break;
				Case FRAME_D:
					Frame = FRAME_P;
					Break;
				Case FRAME_C:
					Frame = FRAME_O;
					Break;
				Case FRAME_B:
					Frame = FRAME_N;
					Break;
				Case FRAME_A:
					Frame = FRAME_M;
					Break;
			}
		}
	}
	
	Protected Void MVP_StriderFootsteps (Bool Running)
	{
		If (Running)
		{
			If (Frame == FRAME_H || Frame == FRAME_K) //Play stomp sound on frames where it steps on the ground.
				A_StartSound ("Vehicle/Strider/Stomp",flags:CHANF_OVERLAP,volume:FRandom(0.1,0.3));
			Return;
		}
		
		If (Crouching)
		{
			If (Frame == FRAME_M || Frame == FRAME_O)
				A_StartSound ("Vehicle/Strider/Stomp",flags:CHANF_OVERLAP,volume:FRandom(0.05,0.1),1.25);
			Return;
		}
		
		If (Frame == FRAME_B || Frame == FRAME_D) //Play stomp sound on frames where it steps on the ground.
			A_StartSound ("Vehicle/Strider/Stomp",flags:CHANF_OVERLAP,volume:FRandom(0.075,0.2));
	}
	
	//Get the hardcoded jump values of the strider. HACK: This only exists because KAI_JumpTo() sucks.
	Double MVP_GetStriderVal (JumpVals What)
	{
		If (User_JumpMode == -1) //Nope
			Return -1;
		//MAYDO: Change the jump range to 640MU (20 meters), and accordingly change the height too of course.
		If (User_JumpMode == 1) //Normal params
		{
			Switch (What)
			{
				Case STRIDER_JUMPRANGE:
					Return 512;
				Case STRIDER_JUMPHEIGHT:
					Return 256;
				Case STRIDER_VELOCITY:
					Return -17.5;
				Default:
					Return -1;
			}
		}
		If (User_JumpMode == 2) //Extreme params
		{
			Switch (What)
			{
				Case STRIDER_JUMPRANGE:
					Return 1024;
				Case STRIDER_JUMPHEIGHT:
					Return 512;
				Case STRIDER_VELOCITY:
					Return -35;
				Default:
					Return -1;
			}
		}
		
		Return -1;
	}
	
	//Get the relative coordinates from where an attack on the strider comes out of.
	//PLAYTEST: Test the firing offsets (Crouched and uncrouched) for the rocket and grenade launchers.
	Vector3 MVP_StriderAttackPos (StriderAttacks Type)
	{
		Switch (Type)
		{
			Case ATTACK_NONE:
				Return (Double.NaN,Double.NaN,Double.NaN);
			Case ATTACK_MACHINEGUN:
				Return !Crouching ? (0,0,64) : (0,0,48);
			Case ATTACK_MINIGUN: //Just flip this after each shot by doing Abs(X), same with the rockets.
				Return !Crouching ? (0,-12,80) : (0,-12,64);
			Case ATTACK_ROCKETS:
				Return !Crouching ? (0,-12,72) : (0,-12,56);
			Case ATTACK_GRENADE:
				Return !Crouching ? (0,0,88) : (0,0,72);
			Default:
				Return (Double.NaN,Double.NaN,Double.NaN);
		}
	}
	
	Void MVP_StriderStrafeAttack (Bool GoingDown = False)
	{
		//Strafe fire as long as you aren't facing forward. Aiming at the JumpTarget is automatic.
		If (JumpFlags & SJUMP_STRAFE && FireDelay <= 0 && (JumpDir == JDIR_BACK || JumpDir == JDIR_LEFT || JumpDir == JDIR_RIGHT))
		{
			//No jump target, look for another one.
			If (IsDead(JumpTarget))
			{console.printf ("current jumptarget %p died",jumptarget);
				Vector3 Real = Pos;
				If (JumpTarget) SetOrigin (JumpTarget.Pos,True);
				Else If (Target) SetOrigin (Target.Pos,True);
				JumpTarget = FindNearestEnemy (512);
				SetOrigin (Real,True);console.printf ("attacking %p instead",jumptarget);
			}
			Vector3 FirePos = MVP_StriderAttackPos (ATTACK_MACHINEGUN);
			If (KAI_CheckLOF (JumpTarget,150,0,FirePos,TLOF_OnlyAhead,"MVP_RifleBullet",GetFAFAimPos(JumpTarget,FirePos)))
			{
				Tics = 2;
				A_AttachLightDef ('StrafeLight',"StriderFiringLight");
				//A_RemoveLight ('StrafeLight');
				A_StartSound ("Vehicle/APC/SmallMGFire",CHAN_WEAPON,CHANF_OVERLAP,1.0,0.5);
				Bool B; Actor Proj = A_SpawnProjectile ("MVP_RifleBullet",FirePos.Z,flags:CMF_AIMDIRECTION,Pitch); //pew pew
				AddProjectileSpread (Proj,(1.25,-1.25),(1.25,-1.25));
				[B, Proj] = A_SpawnItemEx ("MVP_BulletCasing",0,0,FirePos.Z,FRandom(4,-4),FRandom(4,8),FRandom(3,8));
				Proj.Scale.X = 0.125; Proj.Scale.Y = 0.104166;
				
				Switch (JumpDir)
				{
					Case JDIR_BACK:
						Frame = !GoingDown ? FRAME_C : FRAME_E;
						Break;
					Case JDIR_LEFT:
						Frame = !GoingDown ? FRAME_J : FRAME_L;
						Break;
					Case JDIR_LEFT:
						Frame = !GoingDown ? FRAME_L : FRAME_J;
						Break;
				}
				
				FireDelay = 4; //This is automatically reduced every tick.
			}
		}
		If (FireDelay > 0)
			A_RemoveLight ('StrafeLight');
	}
	
	Void MVP_StriderEndFire()
	{
		A_StopSound (CHAN_WEAPON);
		AttackType = ATTACK_NONE;
		Inaccuracy = Default.Inaccuracy;
		InaccuracyFrequency = Default.InaccuracyFrequency;
	}
	
	KAIMoveParams StriderMove;
	KAI_Voice Yapper;
	Int DeathFlames;
	Vector3 CoverPos;
	Vector3 ClimbPos;
	UInt8 RevFrame, Rev;
	UInt8 ReverseSteps; //How many steps to walk backwards for.
	UInt8 RunSteps; //How many steps to stay in one of the Run substates for.
	Bool Crouching;
	Actor LastProj; //Last projectile dodged.
	
	UInt8 AttackType; //What do we attack with currently?
	Int Shots; //How many times to use our attack before stopping?
	UInt8 FireDelay; //Time before we can fire again. Used by SJUMP_STRAFE as a delay in the jump loop between shots instead.
	
	Enum StriderAttacks //All strider attacks. The MG, minigun, and rockets visually update the strider to aim and down to the target.
	{
		ATTACK_NONE,
		ATTACK_MACHINEGUN, //TODO: Add separate fire modes for single shots, bursts, and full auto, like the marines and large gun drone do.
		ATTACK_MINIGUN,
		ATTACK_ROCKETS,
		ATTACK_GRENADE,
		ATTACK_PUNT, //Old punt
		ATTACK_STOMP,
		ATTACK_RAMMING,
	}
	
	//Cover variables
	Const COVER_WAIT = 350;
	Const COVER_DUCKTIME = 70;
	Bool InCover;
	Int OuttaSightTime; //How long has the target been out of sight while behind cover?
	Int DuckTime; //Dodging by ducking down.
	
	Mixin MVP_DroneVirtuals;
	Mixin MVP_DroneFunctions;
	
	//Jumping variables.
	Vector3 JumpPos;
	Double JumpSpeed; //Passed to KAI_JumpTo()/
	Int JumpFlags; //Flags used for every jump in progress. Then cleared once the jump's done.
	Int JumpDir; //The direction the strider is jumping at.
	Actor JumpTarget; //Who to fire at while mid-jump.
	Const STRIDER_FALLTHRESHOLD = 8; //Minimum negative Z vel need to produce impact effects.
	
	Enum JumpDirs //The direction it starts off jumping to, determined by the angle difference between where it wants to go and its' angle at the time of jumping.
	{
		JDIR_NORMAL, //Standard nondescript jump
		JDIR_LEFT,
		JDIR_RIGHT,
		JDIR_RUN, //Running jump //MAYDO: Since the jump direction is determined dynamically, make this a flag instead?
		JDIR_BACK, //Jump backwards
	}
	
	Enum JFlags
	{
		SJUMP_FACEDIRECTION = 1 << 0, //Change angle over time while in the air to face where you're jumping to.
		SJUMP_FAST			= 1 << 1, //Jump faster. Used for running jumps and dodges.
		SJUMP_STEER			= 1 << 2, //Steer yourself to the JumpPos on descent.
		SJUMP_CLIMB			= 1 << 3, //Jump straight up to the climb position. And also only use the generic jump sprites. Used in conjunction with SJUMP_STEER.
		SJUMP_RUNNING		= 1 << 4, //We are leaping to a position on loop.
		SJUMP_STRAFE		= 1 << 5, //The strider can also fire while leaping sideways or backwards.
	}
	
	//Used by the different jump modes.
	Enum JumpVals
	{
		STRIDER_JUMPRANGE,
		STRIDER_JUMPHEIGHT,
		STRIDER_VELOCITY,
	}
	
	UInt8 User_JumpMode; //-1 None, 0 Pick default, 1 Standard (Default), 2 High
	Double User_DodgeRange;
	Double User_RetreatDistance;
	Int User_ChaseTime;
	Bool User_NoCover;
	
	Const STRIDER_CROUCHHEIGHT = 64;
	Const STRIDER_RUNFACTOR = 2.25;
	Const STRIDER_CROUCHFRAMEOFFSET = 12; //Offset the PNS0 sprite name by 12 frames (From PNS0A) to map to the crouch animation instead.
	
	States
	{
		StriderSprites: //Do I even need to do this still? Not in the mood to find out.
			PNS1 ABCDEFGHIJKLMNOPQRSTUVWXYZ[] 0;
		Spawn:
			PNS3 A 1
			{
				KAI_Look (LOF_NOJUMP);
				If (Target)
				{
					Int Chance = (Distance3D(Target) <= 1024) ? 64 : 8;
					If (Target.CurSector.LightLevel <= 104)
						Chance += 32;
					If (Random (0,255) < Chance)
						A_StartSound (SeeSound,CHAN_VOICE,attenuation: 0.6);
					Return SeeState;
				}
				
				Return State (Null);
			}
			Loop;
		See:
			PNS0 ABCDEF 4
			{
				RunSteps = 0;
				MVP_StriderChase();
				MVP_StriderFootsteps(False);
				MVP_UseCrouchAnim();
				
				//Debug wandering and random jumping.
				/*KAI_Wander (32,384,anglelimit:25);
				if (random (0,255) < 8)
				{
					vector3 where = FindRandomMovePos (self.pos,8,checkrad:384);
					//where = vec3angle (randompick(256,-256),RandomPick(90,-90,0,0));
					KAI_DebugPointDelay.KAI_TempPointSpawn(where,70*2);
					MVP_StriderJump (where);
				}*/
			}
			Loop;
		See.Run: //Originally I had made a system that essentially converts See: into this state, but jumping between states is easier so.
			PNS0 GHIJKL 2
			{
				Speed *= STRIDER_RUNFACTOR;
				MVP_StriderChase();
				Speed /= STRIDER_RUNFACTOR;
				MVP_StriderFootsteps(True);
				If (RunSteps > 0)
					RunSteps--;
				If (RunSteps <= 0 || Crouching)
				{
					RunSteps = 0;
					Return SeeState; //Back to walking.
				}
				
				Return State (Null);
			}
			Loop;
		Idle:
			PNS0 ABCDEF 4
			{
				//If (CurrentOrder != ORDER_STAY) MVP_StriderFootsteps(False);
				KAI_Wander (StriderMove.Attempts,StriderMove.RunRad,StriderMove.MaxSteps,StriderMove.DetourFactor,StriderMove.AngleLimit);
			}
			Loop;
		Idle.Run:
			PNS0 GHIJKL 2
			{
				//If (CurrentOrder != ORDER_STAY) MVP_StriderFootsteps(True);
				Speed *= STRIDER_RUNFACTOR;
				KAI_Wander (StriderMove.Attempts,StriderMove.RunRad,StriderMove.MaxSteps,StriderMove.DetourFactor,StriderMove.AngleLimit);
				Speed /= STRIDER_RUNFACTOR;
				
				If (RunSteps > 0)
					RunSteps--;
				If (RunSteps <= 0 || Crouching)
				{
					RunSteps = 0;
					Return FindState ("Idle",True); //Back to walking.
				}
				
				Return State (Null);
			}
			Loop;
		//Idle.Stand: //Spinny 360 head state.
		Idle.Cover:
			PNS1 UVW 4 A_StartSound ("Vehicle/Drone/Turret",CHAN_WEAPON);
			PNS1 W 0 A_StopSound (CHAN_WEAPON);
			//IDEA: This is copied from the tracked drone hull. Maybe replace it with a dedicated chase method for when behind cover?
			PNS1 W 1 //NOTE: We need this delay or otherwise the cover loop quits regardless.
			{
				Actor Proj;
				
				If (--DuckTime <= 0 && (Proj = MVP_DroneDodge(User_DodgeRange)))
				{
					DuckTime = COVER_DUCKTIME;
					A_SetSize (newheight:STRIDER_CROUCHHEIGHT);
					Return State (Null);
				}
				
				If (DuckTime > 0)
					Frame = 26;
				Else
					A_SetSize (newheight:Default.Height);

				If (IsDead (Target))
				{
					Target = Null;
					LookForPlayers (True);
				}
				
				If (!CheckSight (Target, SF_IGNOREWATERBOUNDARY) && OuttaSightTime++ > COVER_WAIT)
				{
					OuttaSightTime = 0;
					Return FindState ("Idle.Cover.End",True);
				}
				
				If (User_NoCover)
					Return FindState ("Idle.Cover.End",True);
				
				Return State (Null);
			}
			PNS1 W 0
			{
				//Stop hiding if the target is behind the cover, another enemy is too close, or if there's no target left.
				Bool InCover = KAI_HasCoverHere(Target,True,64,(72,192),(64,40),(Radius,30,100),Self);
				Actor NearestEnemy = FindNearestEnemy (192);
				
				If (!InCover || !Target || NearestEnemy && NearestEnemy != Target || GetStrongestHazard(Hazards) && GetStrongestHazard(Hazards).Level >= HazardInfo.HAZARD_MEDIUM)
					Return FindState ("Idle.Cover.End",True);
				
				Return State(Null);
			}
			Goto Idle.Cover+4;
		Idle.Cover.End:
			PNS1 VU 4 A_StartSound ("Vehicle/Drone/Turret",CHAN_WEAPON);
			PNS1 U 0
			{
				A_StopSound (CHAN_WEAPON);
				InCover = False;
			}
			Goto See;
		Fire: //Pick a random ranged attack type and begin blasting.
			TNT1 A 0
			{
				AttackType = Random (ATTACK_MACHINEGUN,ATTACK_GRENADE);
				
				If (AttackType == ATTACK_MACHINEGUN)
				{
					Shots = Random (10,30);
					AttackType = ATTACK_MACHINEGUN;
				}
				Else If (AttackType == ATTACK_MINIGUN)
				{
					Shots = Random (192,255);
					AttackType = ATTACK_MINIGUN;
				}
				Else
					Shots = 3;
				
				//Return FindStateByString (Attack,True);
			}
		Fire.Start:
			PNS1 U 0
			{
				If (AttackType == ATTACK_GRENADE) //Skip straight to firing grenades.
					Return FindState ("Fire.Grenade",True);
				If (AttackType == ATTACK_NONE) //Womp womp.
					Return SeeState;
				
				If (InCover) //Skip the preperation if we're already behind cover.
					Return A_Jump (256,4);
				Return State (Null);
			}
			PNS1 UVW 4 Fast
			{
				If (Crouching) //No prepare animation for the crouch firing.
					Frame = FRAME_BRACKETOPEN;
				Else
					A_StartSound ("Vehicle/Drone/Turret",CHAN_WEAPON);
				If (AttackType == ATTACK_MACHINEGUN) //Open faster for the machine gun.
					Tics = 2;
			}
			PNS1 W 0
			{
				A_StopSound (CHAN_WEAPON);
				Switch (AttackType)
				{
					Case ATTACK_MACHINEGUN:
						Return FindState ("Fire.MG",True);
					Case ATTACK_MINIGUN:
						Return FindState ("Fire.Minigun",True);
					Case ATTACK_ROCKETS:
						Return FindState ("Fire.Rocket",True);
				}

				Return State (Null);
			}
		Fire.MG:
			PNS1 X 2 Light ("StriderFiringLight")
			{
				A_StartSound ("Vehicle/APC/SmallMGFire",CHAN_WEAPON,CHANF_OVERLAP,1.0,0.5);
				Vector3 FireOfs = MVP_StriderAttackPos (ATTACK_MACHINEGUN);
				Bool B; Actor Proj = A_SpawnProjectile ("MVP_RifleBullet",FireOfs.Z,flags:CMF_AIMDIRECTION,Pitch); //pew pew
				AddProjectileSpread (Proj,(0.75,-0.75),(0.75,-0.75));
				[B, Proj] = A_SpawnItemEx ("MVP_BulletCasing",0,0,FireOfs.Z,FRandom(4,-4),FRandom(4,8),FRandom(3,8));
				Proj.Scale.X = 0.125; Proj.Scale.Y = 0.104166;
				
				If (!Crouching)
				{
					Frame = UpdateStriderElevation(FRAME_S,FRAME_X,FRAME_P);
					If (Frame != FRAME_X)
						Sprite = GetSpriteIndex ('PNS2');
				}
				Else
				{
					Frame = UpdateStriderElevation(FRAME_BRACKETOPEN,FRAME_BRACKETOPEN,FRAME_U);
					If (Frame == FRAME_U)
						Sprite = GetSpriteIndex ('PNS2');
				}
			}
			PNS1 W 3
			{
				If (MVP_StriderDodge (True))
				{
					MVP_StriderEndFire();
					Return State (Null);
				}
				
				//MAYDO: Make this check into a function so the minigun loop can use it too.
				
				//Jump away from nearby enemies when we can.
				Actor Near;
				If (!bNoFear && Random (0,255) < 32 && (Near = FindNearestEnemy (Radius+128)))
				{
					If (MVP_StriderJump (MVP_StriderJumpFromPos (Near.Pos,32,384),flags:SJUMP_STRAFE,enemy:Near))
					{
						MVP_StriderEndFire();
						FireDelay = 0;
						Return State(Null);
					}
				}
				
				//Out of ammo.
				If (Shots-- <= 1)
				{
					Shots = 0;
					FireDelay = Clamp (GameTicRate*Random(1,6),0,UInt8.MAX);
					If (MVP_DroneSwitchTargets(KAI_Actor(Master),2048) && Random (0,255) < 16 && MVP_GunDrone(Master) && MVP_GunDrone(Master).Yapper)
						KAI_Actor(Master).SayVoiceLine (VOICE_SEE,MVP_GunDrone(Master).Yapper);
					Return FindState ("Fire.End",True);
				}
				
				//If (FireMode == MODE_AUTO)
				{
					//If you have no target, or it's dead.
					If (!Target || IsDead (Target))
					{
						A_ClearTarget();
						LookForPlayers (True); //Look for a new target.
					}
					
					Vector3 FireOfs = MVP_StriderAttackPos (ATTACK_MACHINEGUN);
					If (KAI_NPCRefire (16,"Fire.End",True,16) || !KAI_CheckLOF (Target,60,0,FireOfs,0,"MVP_RifleBullet",GetFAFAimPos(Target,FireOfs)))
					{
						A_ClearTarget();
						Return FindState ("Fire.End",True);
					}
				}
				
				HandleChaseTimer();
				
				If (!Crouching)
				{
					Frame = UpdateStriderElevation (FRAME_R,FRAME_W,FRAME_O);
					If (Frame != FRAME_W)
						Sprite = GetSpriteIndex ('PNS2');
				}
				Else
				{
					Frame = UpdateStriderElevation (FRAME_Y,FRAME_Y,FRAME_V);
					If (Frame == FRAME_V)
						Sprite = GetSpriteIndex ('PNS2');
				}
				Return State (Null);
			}
			Loop;
		Fire.Minigun:
			PNS2 A 1 Light ("StriderFiringLight")
			{
				A_StartSound ("Vehicle/APC/SmallMGFire",CHAN_WEAPON,CHANF_OVERLAP,1.0,0.5);
				A_StartSound ("Vehicle/APC/SmallMGFire",CHAN_WEAPON,CHANF_OVERLAP,1.0,0.5);
				Vector3 FireOfs = MVP_StriderAttackPos (ATTACK_MINIGUN);
				Bool B; Actor Proj;
				
				Proj = A_SpawnProjectile ("MVP_SmallRifleBullet",FireOfs.Z,FireOfs.Y,flags:CMF_AIMDIRECTION,Pitch);
				AddProjectileSpread (Proj,(0.75,-0.75),(0.75,-0.75));
				Proj = A_SpawnProjectile ("MVP_SmallRifleBullet",FireOfs.Z,Abs(FireOfs.Y),flags:CMF_AIMDIRECTION,Pitch);
				AddProjectileSpread (Proj,(0.75,-0.75),(0.75,-0.75));
				
				//Casings fall straight down
				[B, Proj] = A_SpawnItemEx ("MVP_BulletCasing",0,FireOfs.Y,FireOfs.Z,FRandom(1,-1),FRandom(1,-1),0);
				Proj.Scale.X = 0.125; Proj.Scale.Y = 0.104166;
				[B, Proj] = A_SpawnItemEx ("MVP_BulletCasing",0,Abs(FireOfs.Y),FireOfs.Z,FRandom(1,-1),FRandom(1,-1),0);
				Proj.Scale.X = 0.125; Proj.Scale.Y = 0.104166;
				
				If (!Crouching)
					Frame = UpdateStriderElevation (FRAME_T,FRAME_A,FRAME_Q);
				Else
				{
					Frame = UpdateStriderElevation(FRAME_BRACKETOPEN,FRAME_BRACKETOPEN,FRAME_U);
					If (Frame == FRAME_BRACKETOPEN)
						Sprite = GetSpriteIndex ('PNS1');
				}
			}
			PNS2 B 1
			{
				If (MVP_StriderDodge (True))
				{
					MVP_StriderEndFire();
					Return State (Null);
				}
				
				//Rarely jump away from the target when we can.
				Actor Near;
				If (!bNoFear && Random (0,255) < 2 && Target && Distance3D(Target) <= 128+Radius)
				{
					If (MVP_StriderJump (MVP_StriderJumpFromPos (Target.Pos,32,384),flags:SJUMP_STRAFE,enemy:Target))
					{
						MVP_StriderEndFire();
						FireDelay = 0;
						Return State(Null);
					}
				}
				
				//Out of ammo.
				Shots -= 2;
				If (Shots <= 0)
				{
					Shots = 0;
					FireDelay = Clamp (GameTicRate*Random(1,6),0,UInt8.MAX);
					If (MVP_DroneSwitchTargets(KAI_Actor(Master),2048) && Random (0,255) < 16 && MVP_GunDrone(Master) && MVP_GunDrone(Master).Yapper)
						KAI_Actor(Master).SayVoiceLine (VOICE_SEE,MVP_GunDrone(Master).Yapper);
					Return FindState ("Fire.End",True);
				}
				
				//If (FireMode == MODE_AUTO)
				{
					//If you have no target, or it's dead.
					If (!Target || IsDead (Target))
					{
						A_ClearTarget();
						LookForPlayers (True); //Look for a new target.
					}
					
					Vector3 FireOfs = MVP_StriderAttackPos (ATTACK_MINIGUN);
					If (KAI_NPCRefire (88,"Fire.End",True,16) || !KAI_CheckLOF (Target,600,128,FireOfs,0,"MVP_SmallRifleBullet",GetFAFAimPos(Target,FireOfs)))
					{
						A_ClearTarget();
						Return FindState ("Fire.End",True);
					}
				}
				
				HandleChaseTimer();
				
				If (!Crouching)
					Frame = UpdateStriderElevation (FRAME_R,FRAME_B,FRAME_O);
				Else
				{
					Frame = UpdateStriderElevation(FRAME_Z,FRAME_Z,FRAME_W);
					If (Frame == FRAME_Z)
						Sprite = GetSpriteIndex ('PNS1');
				}
				
				Return State (Null);
			}
			Loop;
		Fire.End:
			PNS1 VU 4 Fast
			{
				If (Crouching) //No prepare animation for the crouch firing.
					Frame = FRAME_BRACKETOPEN;
				Else
					A_StartSound ("Vehicle/Drone/Turret",CHAN_WEAPON);
				If (AttackType == ATTACK_MACHINEGUN) //CLOSE faster for the machine gun.
					Tics = 2;
			}
			PNS1 U 0 MVP_StriderEndFire();
			Goto See;
		Melee:
			TNT1 A 0
			{
				If (Random (False, True) == True)
					Return FindState ("Melee.Stomp");
				Return State (Null); //Fall into kick state.
			}
		Melee.Kick:
			Goto See;
		Climb:
			PNS1 R 6 Fast Slow
			{
				Crouching = False;
				A_Stop();
				bNoGravity = True;
			}
			PNS1 S 6 Fast Slow A_StartSound ("Vehicle/Strider/Motor",flags:CHANF_OVERLAP);
			PNS1 T 5 Fast Slow
			{
				bNoGravity = Default.bNoGravity;
				A_SetAngle (GetAngleToPos(Vec3Angle (Speed,Angle),0)); //Face in front of where you climbed to.
				SetOrigin (ClimbPos,False);
				ClimbPos = (Double.NaN,Double.NaN,Double.NaN);
				GiveInventory ("MVP_DropoffToken",1); //HACK: Zandronum Moment
			}
			PNS1 T 0 A_JumpIf (!Target,"Idle");
			Goto See;
		//JUMP STATES
		//You can check if the strider is jumping by seeing if they are in any Jump.##### state.
		Jump:
			Jump.Start:
				#### # Random(5,12) Fast
				{
					If (JumpFlags & SJUMP_FAST)
						Tics = Random (2,6);
					
					If (JumpFlags & SJUMP_STRAFE)
					{
						AttackStates.Push(FindState("Jump.Loop",True));
						AttackStates.Push(FindState("Jump.Loop.Down",True));
					}
					
					[Frame, JumpDir] = MVP_StriderLean (FRAME_Y, FRAME_H, FRAME_G, FRAME_A, True,running: FRAME_Q); //Y, H, G, A
					Sprite = MVP_StriderLeanIndex (JumpDir);

					A_StartSound ("Vehicle/Strider/Motor",flags:CHANF_OVERLAP);
				}
				#### Y 0
				{
					If (!(JumpFlags & SJUMP_CLIMB))
						KAI_JumpTo (JumpPos,JumpSpeed,MVP_GetStriderVal(STRIDER_JUMPRANGE));
					Else
						Vel.Z += JumpSpeed; //Jump straight up to climb.
				}
			Jump.Loop:
				#### # 1
				{
					[Frame, JumpDir] = MVP_StriderLean (FRAME_Z, FRAME_K, FRAME_I, FRAME_B,running: FRAME_O); //Z, K, I, B
					Sprite = MVP_StriderLeanIndex(JumpDir);
				}
				#### # 1
				{
					[Frame, JumpDir] = MVP_StriderLean (FRAME_Z, FRAME_K, FRAME_I, FRAME_B,running: FRAME_O); //Z, K, I, B
					Sprite = MVP_StriderLeanIndex(JumpDir);
					
					If (JumpFlags & SJUMP_FACEDIRECTION && !KAI_Math.IsEmptyVector3 (JumpPos))
						Angle = GetAngleToPos (JumpPos,StriderMove.AngleLimit/5);
					
					MVP_StriderStrafeAttack ();
					
					//Going down, or maybe we already landed.
					If (Vel.Z <= -2 || bOnMobj || Pos.Z <= FloorZ || Pos.Z <= GetZAt ())
						Return FindState ("Jump.Loop.Down",True);
					
					Return State (Null);
				}
				Goto Jump.Loop+1;
			Jump.Loop.Down:
				//Coming down frame.
				#### # 1
				{
					If (JumpFlags & SJUMP_FACEDIRECTION && !KAI_Math.IsEmptyVector3 (JumpPos))
						Angle = GetAngleToPos (JumpPos,StriderMove.AngleLimit/5);
					If (JumpFlags & SJUMP_STEER && !KAI_Math.IsEmptyVector3 (JumpPos))
						Vel.XY += AngleToVector (GetAngleToPos(JumpPos,0),1);
					[Frame, JumpDir] = MVP_StriderLean (FRAME_BRACKETOPEN,FRAME_I, FRAME_K, FRAME_D,running: FRAME_P); //[, I, K, D
					Sprite = MVP_StriderLeanIndex (JumpDir);
					
					MVP_StriderStrafeAttack (True);
					
					If (bOnMobj || Pos.Z <= FloorZ || Pos.Z <= GetZAt ()) //The eagle has landed.
					{
						//We are leaping towards our JumpPos, so do that until the RunSteps run out. Or the target is now in range or out of sight.
						If (JumpFlags & SJUMP_RUNNING && RunSteps > 0 && !IsDead(Target) &&
						!(Target && (Distance3D(Target) <= 768 || !CheckSight(Target,SF_IGNOREWATERBOUNDARY))))
						{
							If (RunSteps >= 5)
								RunSteps -= 5;
							Else
								RunSteps = 0;
							Angle = GetAngleToPos (Target.Pos,StriderMove.AngleLimit*2);
							console.printf ("leapfrogging to %.2f %.2f %.2f, angle is %.2f, run steps %u",jumppos,angle,runsteps);
							JumpPos.XY = AngleToVector (Angle, MVP_GetStriderVal(STRIDER_JUMPRANGE));
							JumpPos.XY = Level.Vec2Offset (Pos.XY,JumpPos.XY);
							JumpPos.Z = GetZAt(JumpPos.X,JumpPos.Y);
							Return FindState ("Jump");
						}
						Else
							Return FindState ("Jump.End",True);
					}
					
					//Emit a hazard in front of where we're falling towards.
					//TODO: Use the angle and pitch the Strider is moving towards.
					FLineTraceData Data;
					LineTrace (VectorAngle(Vel.X,Vel.Y),384,VectorAngle(Vel.XY.Length(),Vel.Z),TRF_BLOCKSELF,Height/2,data:Data);
					
					//Warn NPCs of hazard.
					Array <String> Fall;
					Fall.Push("Vehicle");
					Fall.Push("Crush");
					Fall.Push("VehicleCrush");
					HazardInfo.EmitHazard (Self,Radius*4,HazardInfo.HAZARD_ACTOR,HazardInfo.HAZARD_MEDIUM,tags:Fall);
					
					Return State (Null);
				}
				Loop;
			//MAYDO: Make it lose momentum or have a massive friction penalty once landed so it doesn't slide off thin surface?
			Jump.End: //All comes back here.
				#### # 8
				{
					If (JumpFlags & SJUMP_FAST)
						Tics = 4;
					
					If (JumpFlags & SJUMP_STRAFE)
					{
						AttackStates.Delete (AttackStates.Find(FindState("Jump.Loop",True)));
						AttackStates.Delete (AttackStates.Find(FindState("Jump.Loop.Down",True)));
					}
					
					bNoFriction = Default.bNoFriction; //Do friction again.
					If (JumpFlags & SJUMP_CLIMB) //Do Zandronum moment
						GiveInventory ("MVP_DropoffToken",1);
					
					Sprite = MVP_StriderLeanIndex (JumpDir);
					Frame = MVP_StriderLean (FRAME_BRACKETCLOSE, FRAME_N, FRAME_M, FRAME_F, flipsides: True,running: FRAME_Q); //], N, M, F
					
					JumpFlags = 0;
					JumpDir = 0;
					JumpPos = (Double.NaN,Double.NaN,Double.NaN);
					NextMovePos = (Double.NaN,Double.NaN,Double.NaN);
					JumpTarget = Null;
					//CoverPos = (Double.NaN,Double.NaN,Double.NaN);
				}
				Goto See;
			//Special state for climbing by jumping up. The JumpPos is pre-set for the climb handling during MVP_StriderParkour().
			Jump.Up:
				PNS0 Y 0
				{
					//Double JumpVel = Sqrt(2 * (GetGravity()*GameTicRate) * Abs(JumpPos.Z - Pos.Z));
					Double JumpHeight = Abs(JumpPos.Z - Pos.Z+Height)+64; //Includes dramatic padding.
					//CREDIT: RaveYard for the formula for launching an actor to an exact target height using gravity.
					Double JumpVel = 0.5 * (sqrt(GetGravity()) * sqrt(GetGravity() + 8 * JumpHeight) + GetGravity());
					console.printf ("height diff %2.f, vel %.2f",Abs(JumpPos.Z - Pos.Z+Height),jumpvel);
					MVP_StriderJump (JumpPos,JumpVel,SJUMP_CLIMB|SJUMP_STEER);
				}
				Goto Jump;
		Death:
			PNS9 A 8
			{
				Tics = Random (4,10);
				If (Random (1,4) == 2)
					DeathFlames = Random (80,150)*10;
				
				A_StopSound (CHAN_BODY);
				A_StartSound ("SFX/Fire",CHAN_VOICE,CHANF_LOOPING,0.5,1.1);
				Actor Boom = Spawn ("MVP_Explosion",Pos.PlusZ(48));
				Boom.Scale *= FRandom (1.8f,2.2f);
				Boom.SetDamage (192);
				Boom.MaxTargetRange = 256;
				Boom.MeleeRange = Radius+64;
				Boom.bNoGravity = True;
				Boom.bGetOwner = True;
				Boom.Target = Self; //Does it even matter if we're gone? Very philosophical.
				
				SmokeCounter = Random (8,16);
				Bool B; Actor Debris;
				For (Int I; I <= SmokeCounter; I++)
				{
					[B, Debris] = A_SpawnItemEx ("MVP_DiCokkaDebris",FRandom (Radius,-Radius),FRandom(Radius,-Radius),FRandom (Height-24,Height+24),FRandom (-6,6),FRandom (-6,6),FRandom (2,8));
					If (Debris)
					{
						Debris.Scale *= FRandom (0.1,0.8);
						Debris.bXFlip = Random (False,True);
					}
				}
				
				If (RunSteps)
				{
					Vel.XY += AngleToVector (Angle,Speed*STRIDER_RUNFACTOR*2);
					RunSteps = 0;
					Return FindState ("RunDeath");
				}
				
				If (Random (True, False) == True)
					Return FindState ("AltDeath");
				Return State (Null);
			}
			PNS9 B 4;
			PNS9 C 3;
			PNS9 D -1
			{
				If (GetZAt() <= Pos.Z)
				{
					A_StartSound ("SFX/MetalHit");
					Actor Duster = Spawn ("MVP_GroundDustSpawner",Pos);
					//Pass parameters to spawner.
					Duster.RadiusDamageFactor = 0;
					Duster.ReactionTime = 32;
					Duster.Threshold = Radius*2.25;
					Duster.Scale *= 0.25;
				}
			}
			Stop;
		RunDeath:
			PNS9 HI 4;
			PNS9 J -1
			{
				If (GetZAt() <= Pos.Z)
				{
					A_StartSound ("SFX/MetalHit");
					Actor Duster = Spawn ("MVP_GroundDustSpawner",Pos);
					//Pass parameters to spawner.
					Duster.RadiusDamageFactor = 0;
					Duster.ReactionTime = 32;
					Duster.Threshold = Radius*2.25;
					Duster.Scale *= 0.25;
				}
			}
			Stop;
		//URGENT: TODO: Fix the fucking cropping. Fucking great, can't wait for my entire system to break a THIRD time because of the Strider sprites!!!!!
		AltDeath:
			PNS9 EF 4;
			PNS9 G -1
			{
				If (GetZAt() <= Pos.Z)
				{
					A_StartSound ("SFX/MetalHit");
					Actor Duster = Spawn ("MVP_GroundDustSpawner",(Vec2Angle(24,Angle),Pos.Z));
					//Pass parameters to spawner.
					Duster.RadiusDamageFactor = 0;
					Duster.ReactionTime = 32;
					Duster.Threshold = Radius*2.25;
					Duster.Scale *= 0.5;
				}
			}
			Stop;
		XDeath:
			PNS9 K 8
			{
				Tics = Random (4,10);
				
				A_StopSound (CHAN_BODY);
				Actor Boom = Spawn ("MVP_Explosion",Pos.PlusZ(48));
				Boom.Scale *= FRandom (2.75f,3.5f);
				Boom.SetDamage (256);
				Boom.MaxTargetRange = 384;
				Boom.MeleeRange = Radius+64;
				Boom.bNoGravity = True;
				Boom.bGetOwner = True;
				Boom.Target = Self; //Does it even matter if we're gone? Very philosophical.
				
				Bool Alt = Random (True, False);
				Bool B; Actor Debris;
				//No gibs.
				If (Random (True,False) == True)
				{
					SmokeCounter = Random (48,64);
					
					For (Int I; I <= SmokeCounter; I++)
					{
						[B, Debris] = A_SpawnItemEx ("MVP_DiCokkaDebris",FRandom (Radius,-Radius),FRandom(Radius,-Radius),FRandom (Height-24,Height+24),FRandom (-6,6),FRandom (-6,6),FRandom (2,8));
						If (Debris)
						{
							Debris.Scale *= FRandom (0.1,0.8);
							Debris.bXFlip = Random (False,True);
						}
					}
				}
				Else
				{
					If (!Alt) //No head gib if we are going the XDeath where the whole body is destroyed.
					{
						[B, Debris] =  A_SpawnItemEx ("MVP_StriderHeadGib",zofs:64,FRandom (4,-4),FRandom (-4,-8),FRandom (6,16));
						If (Debris)
						{
							Debris.SmokeCounter = Random (2,6);
							Debris.Master = Self;
						}
					}
					[B, Debris] =  A_SpawnItemEx ("MVP_StriderArmGib",zofs:64,FRandom (-6,-16),FRandom (-6,-12),FRandom (2,8));
					If (Debris)
					{
						Debris.SmokeCounter = Random (2,6);
						Debris.Master = Self;
					}
				}
				
				If (Alt)
					Return FindState ("AltXDeath");
				Return State (Null);
			}
			PNS9 LM 4;
			PNS9 N -1
			{
				A_StartSound ("SFX/MetalHit");
				Actor Duster = Spawn ("MVP_GroundDustSpawner",(Vec2Angle(-24,Angle),Pos.Z));
				//Pass parameters to spawner.
				Duster.RadiusDamageFactor = 0;
				Duster.ReactionTime = 32;
				Duster.Threshold = Radius*2.25;
				Duster.Scale *= 0.5;
			}
			Stop;
		AltXDeath:
			PNS9 OPQ 3;
			PNS9 R -1;
			Stop;
	}
}

//Strider jump hint node, used for example to make it jump up a rooftop if one is nearby, and closer in height to the target than the striders' current position.
Class MVP_StriderJumpSpot : SpecialSpot
{
	Default
	{
		//$Title Strider Jump Spot
		//$Category ZDoom
		//$Sprite MVPEG0
		//IDEA: Maybe use the height and radius fields for something? Like "if the area around this spot isn't clear of obstacles, don't jump here"?
		XScale 0.5;
		YScale 0.416666; //0.5 / 1.2
	}
}

Class MVP_StriderHeadGib : Actor
{
	Default
	{
		Radius 24;
		Height 32;
		XScale 0.8;
		YScale 0.666666; //0.8 / 1.2
		Mass 250;
		+Solid;
		+Shootable;
		//+NoBlockmap;
		+BloodlessImpact;
		+Blasted;
	}
	
	Override Bool CanCollideWith (Actor Other, Bool Passive)
	{
		If (Other && (Other Is GetClassName() || Other == Master))
			Return False;
		Return Super.CanCollideWith (Other, Passive);
	}
	
	States
	{
		Spawn:
			PNS9 STU 4
			{
				Tics = SmokeCounter;
				If (!TestMobjZ(True) || GetZAt ()+1 >= Pos.Z)
					Return FindState("Death");
				
				Return State(Null);
			}
			Loop;
		Death:
			PNS9 V -1
			{
				A_StartSound ("SFX/MetalHit");
				Actor Duster = Spawn ("MVP_GroundDustSpawner",pOS);
				//Pass parameters to spawner.
				Duster.RadiusDamageFactor = 0;
				Duster.ReactionTime = 32;
				Duster.Threshold = Radius*2.25;
				Duster.Scale *= 0.5;
			}
			Stop;
	}
}

Class MVP_StriderArmGib : MVP_StriderHeadGib
{
	Default
	{
		Radius 12;
		Height 16;
		Mass 50;
	}
	States
	{
		Spawn:
			PNS9 XYY 4
			{
				Tics = SmokeCounter;
				If (!TestMobjZ(True) || GetZAt ()+1 >= Pos.Z)
					Return FindState("Death");
				
				Return State(Null);
			}
			Loop;
		Death:
			PNS9 Z -1
			{
				SpriteOffset.Y -= 3;
				A_StartSound ("SFX/MetalHit");
				Actor Duster = Spawn ("MVP_GroundDustSpawner",pOS);
				//Pass parameters to spawner.
				Duster.RadiusDamageFactor = 0;
				Duster.ReactionTime = 32;
				Duster.Threshold = Radius*1.5;
				Duster.Scale *= 0.5;
			}
			Stop;
	}
}

Class MVP_DropoffToken : Inventory
{
	Default {ReactionTime 35;}
	Bool PrevDropoff;
	Override Void AttachToOwner (Actor Other)
	{
		Super.AttachToOwner(Other);
		If (Other && !Other.bDropoff)
		{
			PrevDropoff = Other.bDropoff;
			Other.bDropoff = True;
		}
		Else
			GoAwayAndDie();
	}
	Override Void DoEffect ()
	{
		Super.DoEffect();
		
		If (GetAge() >= ReactionTime)
		{
			If (Owner) Owner.bDropoff = PrevDropoff;
			GoAwayAndDie();
		}
	}
}
Class MVP_BaseVehicle : KAI_BaseVehicle
{
}

Class MVP_BaseTurret : KAI_BaseTurret
{
}

Class MVP_BaseProp : KAI_BaseProp
{
}

Class MVP_BaseTurretProp : KAI_BaseTurretProp
{
}

Class MVP_BaseProjectile : KAI_BaseProjectile
{
	Mixin MVP_UniversalFunctions;
	//Allows to quickly set up a spawned liquid splash, and then returns a pointer the splash to allow for further modifications, like making it visually larger or calling A_QuakeEx from it.
	Actor SpawnLiquidSplash (Int LiquidType = LIQUID_WATER, Sound SplashSound = "SFX/LiquidExplosion", Double Volume = 1.0, Double Attenuation = 0.5,
	Int ExplosionDamage = 0, Double ExplosionRadius = 0, Double FullDamageRadius = 0, Name DamageType = "", Bool DontHarmSource = False)
	{
		Actor Splash = Spawn ("MVP_LiquidSplash",Pos);
		
		If (Splash)
		{
			//Set the shooter of the projectile for DontHarmSource to work.
			If (bMissile)
				Splash.Target = Target; //Projectiles store their shooter in the target pointer, so transfer the shooter to the splash.
			Else
				Splash.Target = Self; //Otherwise set the shooter to the actor calling the function, if it's not a projectile somehow.
			
			MVP_LiquidSplash(Splash).LiquidType = LiquidType;
			MVP_LiquidSplash(Splash).SplashSound = SplashSound;
			MVP_LiquidSplash(Splash).Volume = Volume;
			MVP_LiquidSplash(Splash).Attenuation = Attenuation;
			MVP_LiquidSplash(Splash).RadiusDamage = ExplosionDamage;
			MVP_LiquidSplash(Splash).MaxTargetRange = ExplosionRadius;
			MVP_LiquidSplash(Splash).MeleeRange = FullDamageRadius;
			MVP_LiquidSplash(Splash).ExplosionDamageType = DamageType;
			MVP_LiquidSplash(Splash).DontHarmSource = DontHarmSource;
			Return Splash;
		}
		
		Return Null;
	}
}

//The actor that warns marines around a specified area to run away from the zone in question, it uses the following properties and flags:
//MaxTargetRange: Determines the exact size of the warning zone.
//FIXME: Fix the really fucking stupid bug where when the zone alerts a marine, it will sometimes also alert other friendly NPCs and also make them target said zone.
Class SmartMarineWarningZone : KAI_MixinActor
{
	Default
	{
		Radius 0.1; Height 0;
		MaxTargetRange 256;
		//+Friendly; //To get your grenade-type warning to work with the marines the Friendly flag is NEEDED, because otherwise friendly marines will sometimes end up running in place for some ungodly reason.
		+Shootable; //This will hopefully stop marines running from these warnings from ever getting stuck and running in place.
		+NoBlockmap; //Let's hope this doesn't somehow fuck something up on the marines :)
		+NotAutoaimed
		+NoBlood;
		+NoDamage;
		+NoGravity;
		+NoTarget; //Praying this stops marines from EVER having these zones as their target after they are done running from them.
	}
	
	Enum KAIMarineWarnFlags
	{
		MWRN_ALLIESTOO = 1 << 0, //Gives the warning to marines that are on the same side as the warning zone too, for stuff like indiscriminate AOE attacks. Use CopyFriendliness to make the zone share the allegience of its' creator.
		MWRN_WARP = 1 << 1, //Does nothing here, look at WarnMarines() instead.
		MWRN_PAINONLY = 1 << 2, //Specifies to marines that the AOE attack just causes pain, so they won't run away if on a turret, where they don't feel pain to begin with. This is basically only here because of the Army Car's pain ray.
		MWRN_VEHICLEDEATH = 1 << 3, //Makes it so if the zone is attached to a vehicle, then it will destroy itself once the vehicle has no flames left from it being destroyed.
	}
	
	Inventory Token;
	Vector3 Offset;
	Int Flags;
	
	//Cool copy and paste courtesy of the god forsaken scope system.
	//Is the marine on a turret ? Literally just a convoluted way to return if the OnTurret bool is true or false for the marine.
	Bool MarineIsOnTurret (Actor Other)
	{
		If (!Other) Return False;
		
		Name MGMarine = "TurretMarine";
		Let IsOnTurret = ServiceIterator.Find ("SM_SmartMarines").Next();
		
		If (Other.GetClassName() == MGMarine)
			Return True;
		
		If (IsOnTurret.GetInt ("IsOnTurret",ObjectArg:Other))
			Return True;
		
		Return False;
	}
	
	Override Void BeginPlay ()
	{
		Super.BeginPlay ();
		
		String NoMarineAlert = "SM_DontWarnOthers";
		If (CheckActorExists(NoMarineAlert))
			GiveInventory (NoMarineAlert,1);
	}
	
	Override Void Tick ()
	{
		Name TheMarine = "SmartMarine";
		Name TheOtherMarine = "TurretMarine";
		Name WarningToken = "SM_ImInDanger";
		
		If (IsFrozen()) Return;
		
		//Can be used to attach the zone to an actor.
		If (Master)
			//SetOrigin (Master.Pos,True);
			//SetOrigin (Master.Vec3Offset (Offset.X * Cos(Angle) + Offset.Y * Sin (Angle),Offset.X * Sin (Angle) - Offset.Y * Cos (Angle),Offset.Z),True); //Copied from SpawnMarine().
			SetOrigin (Vec3OffsetRelative (Master,Offset),True);
		
		If ((Flags & MWRN_VEHICLEDEATH) && Master && Master Is "MVP_BaseVehicle") //If you are set to disappear when the vehicle has no death flames left. 
			If (!MVP_BaseVehicle(Master).DeathFlames.Size())
				Destroy();
		
		If (!CheckActorExists(WarningToken)) Return;
		BlockThingsIterator MarineFinder = BlockThingsIterator.Create (Self,MaxTargetRange);
		
		Actor Mobj;
		
		While (MarineFinder.Next())
		{
			Mobj = MarineFinder.Thing;
			
			If (!(Mobj.GetClassName() == TheMarine || Mobj.GetClassName() == TheOtherMarine)) Continue;
			
			//Don't warn marines on the same side as the warning zone.
			If (!(Flags && MWRN_ALLIESTOO))
			{
				If (Mobj.Health > 0 && !Mobj.bDormant && IsHostile (Mobj) && Distance3DSquared(Mobj) <= MaxTargetRange*MaxTargetRange)
				{
					If (!(Flags & MWRN_PAINONLY) || (Flags & MWRN_PAINONLY) && !MarineIsOnTurret(Mobj))
					{
						Token = Mobj.GiveInventoryType (WarningToken);
						If (Token) Token.Master = Self;
					}
				}
			}
			//Warn all marines in the vicinity.
			Else
			{
				If (Mobj.Health > 0 && !Mobj.bDormant && Distance3DSquared(Mobj) <= MaxTargetRange*MaxTargetRange)
				{
					If (!(Flags & MWRN_PAINONLY) || (Flags & MWRN_PAINONLY) && !MarineIsOnTurret(Mobj))
					{
						Token = Mobj.GiveInventoryType (WarningToken);
						If (Token) Token.Master = Self;
					}
				}
			}
		}
	}
	//DEBUG: Uncomment this to be able to see where the warning zones are at.
	/*States
	{
		Spawn:
			PLSS A 4 Bright;
			Loop;
	}*/
}
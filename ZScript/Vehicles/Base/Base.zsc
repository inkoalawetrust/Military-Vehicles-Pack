Class MVP_BaseVehicle : Actor Abstract
{
	Default
	{
		//Properties, in essense most of these are just the properties for the army car, which is the weakest vehicle.
		YScale 0.833334; //Negate the effect of aspect ratio correction on the sprites.
		Radius 32;
		Height 54;
		DeathHeight 54;
		CameraHeight 48;
		Mass 4500;
		RipLevelMin 3;
		Speed 8;
		FastSpeed 16;
		FriendlySeeBlocks 32;
		MaxStepHeight 32;
		Species "Military";
		Obituary "%o managed to be killed by an abstract class, congratulations %o, we are all very proud of you. Or maybe a modder forgot to define a custom obituary.";
		Tag "Military Vehicle Base (You really shouldn't be seeing this in-game)";
		
		//Flags
		Monster;
		+NoForwardFall; //Doesn't make sense for a tank or some shit to slide forward after dying.
		+AvoidMelee;
		+AvoidHazards;
		+SeeFriendlyMonsters; //Of course this is on for enemy vehicles.
		+Telestomp;
		+NoInfightSpecies;
		//+DontSquash; Not on for all vehicles by default, but will be useful for more powerful vehicles like the tank.
		//+DontBlast; Also reserved for the tank.
		+DontMorph; //This is just here because ZDoom's morphing code is a mess internally, and having any of the vehicles morph would definitely break something.
		+DontDrain; //How would you suck the life out of an inanimate object ?
		+DontCorpse; //Keeps the vehicles normal collision even after they are destroyed.
		+NoBlood; //https://www.youtube.com/watch?v=K63AVSCPcSI
		+NoPain;
		+FloorClip;
		+AddLightLevel;
		
		//Damage factors that act as the vehicles "armor".
		DamageFactor 0.9; //Generic damage factor for all damage.
		DamageFactor "Drowning", 0.0;
		DamageFactor "Poison", 0.0;
		DamageFactor "PoisonCloud", 0.0;
		DamageFactor "Melee", 0.2; //May change this to have melee damage do nothing to the vehicles, unless it exceeds a certain ammount.
		DamageFactor "Electric", 0.2;
		DamageFactor "ExplosiveImpact", 0.75;
		DamageFactor "Explosion", 0.75;
		DamageFactor "HitScan", 0.5; //The generic damage type of hitscan attacks.
		DamageFactor "Fire", 0.8;
		DamageFactor "Crush", 1.5;
		DamageFactor "Disintegrate", 1.5;
		DamageFactor "Railgun", 2.0;
		DamageFactor "Falling", 1.25;
		//Damage factors specific to the Smart Marines.
		DamageFactor "MarineHMG", 0.8;
		DamageFactor "MarineGrenade", 0.7;
		DamageFactor "MarineRifle", 0.65;
	}
	
	/*Allows each vehicle to define the defaults for its' own user variables. This is better than the //$UserDefaultValue editor key,
	because it allows default user variable values to be set for actors that are spawned in-game as well, not just ones placed in UDB*/
	Virtual Void UserVariableDefaults () {}
	
	//Handles spawning each vehicles turret, if they have any.
	Virtual Void SpawnVehicleTurret ()
	{
		If (VehicleTurret)
		{
			Turret = MVP_BaseTurret(Spawn (VehicleTurret,Pos+TurretOffsets));
			If (Turret)
			{
				Turret.CopyFriendliness (Self,False);
				Turret.Angle = Angle;
				Turret.Pitch = Pitch;
				Turret.Master = Self;
				Turret.TurretOffsets = TurretOffsets;
			}
		}
	}
	
	Override Void BeginPlay()
	{
		Super.BeginPlay();
		
		If (GetClassName() == "MVP_BaseVehicle" || GetClassName() == "MVP_BaseTurret")
		{
			Console.Printf ("How the fuck did you spawn this in ?");
			Destroy();
		}
	}
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		UserVariableDefaults();
		SpawnVehicleTurret();
		
		If (!bFriendly) Species = 'MilitaryHostile';
	}
	
	Override Void Tick()
	{
		Super.Tick();
		
		If (!User_NoHeadlights)
			HeadLightsOn = (CurSector && CurSector.LightLevel <= 104);
	}
	
	Override Void Die (Actor Source, Actor Inflictor, Int DmgFlags, Name MeansOfDeath)
	{
		Super.Die (Source, Inflictor, DmgFlags, MeansOfDeath);
		If (Turret) Turret.DamageMobj (Inflictor, Source, Turret.Health, MeansOfDeath, DMG_FORCED); //When dead, kill the turret the same way as the vehicle died.
		
		bShootable = bNotAutoaimed = True; //Destroyed vehicles stay shootable and non-autoaimable unless specified otherwise.
		RemoveHeadlights(); //The vehicles aren't resurrectable, so the headlights aren't needed.
		HeadlightsOn = False;
		A_StopSound (CHAN_IDLING);
		A_StopSound (CHAN_MOVING);
	}
	
	Override Void OnDestroy()
	{
		Super.OnDestroy();
		RemoveHeadlights();
		If (Turret) Turret.Destroy();
	}
	
	Enum VehicleSoundChannels
	{
		CHAN_IDLING = 23500,
		CHAN_MOVING = 23501
	}
	
	//Internal variables
	Array <MVP_Headlight> Headlights;
	Bool HeadlightsOn;
	MVP_BaseTurret Turret;
	Vector3 TurretOffsets;
	
	//Flag variables
	Private Int VehicleFlags;
	FlagDef Transport : VehicleFlags, 0; //The vehicle is marked as being able to transport soldiers.
	Class<MVP_BaseTurret> VehicleTurret;
	Property VehicleTurret : VehicleTurret;
	
	//Generic user variables
	Bool User_NoHeadLights;
}

Class MVP_BaseTurret : MVP_BaseVehicle Abstract
{
	Default
	{
		Speed 0;
		FastSpeed 0;
		RipLevelMin 2;
		MaxStepHeight 0;
		Mass 500;
		Tag "Military Vehicle Turret Base (You really shouldn't be seeing this in-game)";
		DamageFactor "MarineGrenade", 0.9;
		DamageFactor "MarineRifle", 0.75;
		+DontThrust;
		+StandStill;
		+DontFollowPlayers;
		-AvoidHazards;
		-AvoidMelee;
		-CanBlast; //Turrets are attached to their vehicle.
		-CountKill; //And because of that, they don't count as kills either.
	}
	
	Private Int TurretFlags;
	FlagDef FallOnDeath : TurretFlags, 0; //Turret stops being attached to its' vehicle after dying.
	
	Override Void PostBeginPlay ()
	{
		Actor.PostBeginPlay ();
		If (!bFriendly) Species = 'MilitaryHostile';
	}
	
	Override Void Tick()
	{
		Actor.Tick();
		
		If (!Master || IsFrozen() || IsDead(Self) && bFallOnDeath) Return;
		
		SetOrigin (Master.Vec3Offset(TurretOffsets.X,TurretOffsets.Y,Master.Height+TurretOffsets.Z),True);
	}
	
	Override Void Die (Actor Source, Actor Inflictor, Int DmgFlags, Name MeansOfDeath)
	{
		Actor.Die (Source, Inflictor, DmgFlags, MeansOfDeath);
		bShootable = bNotAutoaimed = True;
	}
	
	Override Void OnDestroy()
	{
		Actor.OnDestroy();
	}
}

Class MVP_Headlight : DynamicLight
{
	Default
	{
		DynamicLight.Type "Point";
		//+DynamicLight.Attenuate;
		+DynamicLight.Spot;
	}
	
	Bool Active; //The actual internal m_active variable that reports if a dynamic light is on, isn't exposed to ZScript.
	Vector3 Offset; //X = Side to side, Y = Back and front, Z = Up and down
	Bool IsBacklight;
	
	Override Void Tick()
	{
		If (Master && MVP_BaseVehicle(Master).HeadlightsOn)
		{
			If (!IsBacklight)
				Warp (Master,Offset.Y,Offset.X,Offset.Z);
			Else
				Warp (Master,Offset.Y,Offset.X,Offset.Z,180);
		}
	}
	
	Override Void BeginPlay()
	{
		Super.BeginPlay();
		
		Args[LIGHT_RED] = 255;
		Args[LIGHT_GREEN] = 255;
		Args[LIGHT_BLUE] = 255;
		Args[LIGHT_INTENSITY] = 256;
	}
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		Deactivate(Self); //Off by default.
	}
}

//The actor that warns marines around a specified area to run away from the zone in question, it uses the following properties and flags:
//MaxTargetRange: Determines the exact size of the warning zone.
//HarmFriends: Gives the warning to marines that are on the same side as the warning zone too, for stuff like indiscriminate AOE attacks. Use CopyFriendliness to make the zone share the allegience of its' creator.
//Also, figure out why the marines keep fucking running in place when warned by this zone.
Class SmartMarineWarningZone : Actor
{
	Default
	{
		MaxTargetRange 256;
		+Friendly; //To get your grenade-type warning to work with the marines the Friendly flag is NEEDED, because otherwise friendly marines will sometimes end up running in place for some ungodly reason.
	}
	
	Const TheMarine = "SmartMarine";
	Const WarningToken = "SM_ImInDanger";
	Inventory Token;
	
	Override Void Tick ()
	{
		//Can be used to attach the zone to an actor.
		If (Master)
			SetOrigin (Master.Pos,True);
		
		BlockThingsIterator MarineFinder = BlockThingsIterator.Create (Self,MaxTargetRange);
		
		Actor Mobj;
		
		While (MarineFinder.Next())
		{
			Mobj = MarineFinder.Thing;
			
			//Don't warn marines on the same side as the warning zone.
			If (!bHarmFriends)
			{
				If (Mobj.GetClassName() == TheMarine && Mobj.Health > 0 && !Mobj.bDormant && !IsFriend (Mobj) && Distance3DSquared(Mobj) <= MaxTargetRange*MaxTargetRange)
				{
					Token = Mobj.GiveInventoryType (WarningToken);
					If (Token) Token.Master = Self;
				}
			}
			//Warn all marines in the vicinity.
			Else
			{
				If (Mobj.GetClassName() == TheMarine && Mobj.Health > 0 && !Mobj.bDormant && Distance3DSquared(Mobj) <= Speed*Speed)
				{
					Token = Mobj.GiveInventoryType (WarningToken);
					If (Token) Token.Master = Self;
				}
			}
		}
	}
}
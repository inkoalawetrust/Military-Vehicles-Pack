//To do:
/*Maybe also genericize the code that spawns flames on the vehicles' gib deaths, it could also allow me to put the flames in an array.
So that I can also spawn warning zones to make the marines avoid the flaming wrecks, only removing the warning zone once every flame
is gone.*/
Class MVP_BaseVehicle : Actor Abstract
{
	Default
	{
		//Properties, in essense most of these are just the properties for the army car, which is the weakest vehicle.
		XScale 0.65;
		YScale 0.541666; //0.65 / 1.2
		Radius 40;
		Height 54;
		DeathHeight 54;
		CameraHeight 48;
		Mass 4500;
		RipLevelMin 3;
		Speed 8;
		FastSpeed 16;
		FriendlySeeBlocks 48;
		MaxStepHeight 32;
		MaxTargetRange 25000;//8192; //REPLACE THIS VALUE WITH 8192 AGAIN, THIS IS JUST HERE TO TEST THE MOVEMENT PREDICTION.
		MVP_BaseVehicle.MaxCorpseRadius 64;
		MVP_BaseVehicle.MaxCorpseHeight 48;
		Species "Military";
		Obituary "%o managed to be killed by an abstract class, congratulations %o, we are all very proud of you. Or maybe a modder forgot to define a custom obituary.";
		Tag "Military Vehicle Base (You really shouldn't be seeing this in-game)";
		
		//Flags
		Monster;
		+NoForwardFall; //Doesn't make sense for a tank or some shit to slide forward after dying.
		//+AvoidMelee;
		+AvoidHazards;
		+SeeFriendlyMonsters; //Of course this is on for enemy vehicles.
		+Telestomp;
		+NoInfightSpecies;
		//+DontSquash; Not on for all vehicles by default, but will be useful for more powerful vehicles like the tank.
		//+DontBlast; Also reserved for the tank.
		+DontMorph; //This is just here because ZDoom's morphing code is a mess internally, and having any of the vehicles morph would definitely break something.
		+DontDrain; //How would you suck the life out of an inanimate object ?
		+DontCorpse; //Keeps the vehicles normal collision even after they are destroyed.
		+NoBlood; //https://www.youtube.com/watch?v=K63AVSCPcSI
		+NoPain;
		+FloorClip;
		+AddLightLevel; //Used for the headlight system.
		-CanUseWalls; //Vehicles shouldn't be able to use walls, well, not the large ones anyway.
		
		//Damage factors that act as the vehicles "armor".
		DamageFactor 0.9; //Generic damage factor for all damage.
		DamageFactor "Drowning", 0.0;
		DamageFactor "Poison", 0.0;
		DamageFactor "PoisonCloud", 0.0;
		DamageFactor "Melee", 0.2; //May change this to have melee damage do nothing to the vehicles, unless it exceeds a certain ammount.
		DamageFactor "Electric", 0.2;
		DamageFactor "ExplosiveImpact", 0.75;
		DamageFactor "Explosion", 0.75;
		DamageFactor "HitScan", 0.8; //The generic damage type of hitscan attacks.
		DamageFactor "Fire", 0.8;
		DamageFactor "Crush", 1.5;
		DamageFactor "Disintegrate", 1.5;
		DamageFactor "Railgun", 2.0;
		DamageFactor "Falling", 1.25;
		//Damage factors specific to the Smart Marines.
		DamageFactor "MarineHMG", 0.8;
		DamageFactor "MarineGrenade", 0.7;
		DamageFactor "MarineRifle", 0.7;
		//Vehicle damage factors
		DamageFactor "Autocannon", 1.1;
	}
	
	/*Allows each vehicle to define the defaults for its' own user variables. This is better than the //$UserDefaultValue editor key,
	because it allows default user variable values to be set for actors that are spawned in-game as well, not just ones placed in UDB*/
	Virtual Void UserVariableDefaults ()
	{
		If (User_RetreatDistance == 0) User_RetreatDistance = 768;
		If (User_ChaseTime == 0) User_ChaseTime = (35/2)*30; //This is 35/2, because it assumes that the default see state on the vehicles has 2 tic long states.
	}
	
	//Handles spawning each vehicles' turret, if they have any.
	Virtual Void SpawnVehicleTurret ()
	{
		If (VehicleTurret)
		{
			Turret = MVP_BaseTurret(Spawn (VehicleTurret,Pos+TurretOffsets));
			If (Turret)
			{
				Turret.CopyFriendliness (Self,False);
				Turret.Angle = Angle;
				Turret.Pitch = Pitch;
				Turret.Master = Self;
				Turret.TurretOffsets = TurretOffsets;
			}
		}
	}
	
	//Used by MVP_Chase to check for all the different methods each vehicle has to attack.
	Virtual Bool CanAttack()
	{
		Return False; //Vehicles have no attacks by default, of course.
	}
	
	//Called in the middle of MVP_Chase to handle the unique attack decision code of each vehicle.
	Virtual Bool ShouldAttack()
	{
		Return False;
	}
	
	Override Void BeginPlay()
	{
		Super.BeginPlay();
		
		If (GetClassName() == "MVP_BaseVehicle" || GetClassName() == "MVP_BaseTurret" || GetClassName() == "MVP_BaseProp" || GetClassName() == "MVP_BaseTurretProp")
		{
			Console.Printf ("How the fuck did you spawn this in ?");
			Destroy();
		}
	}
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		UserVariableDefaults();
		SpawnVehicleTurret();
		
		If (!bFriendly) Species = 'MilitaryHostile';
		
		If (!User_DefaultOrder || User_DefaultOrder ~== "")
		{
			//This tries to pick a random visible player for the vehicle to follow, if no friendly players are in sight, the vehicle will wander instead.
			Array <PlayerPawn> VisibleFriends;
			//Find all visible players friendly to you.
			For (Int I = 0; I < MAXPLAYERS; I++)
			{
				If (!PlayerInGame[I]) Continue;
				
				If (IsFriend (Players[I].Mo) && CheckSight (Players[I].Mo, SF_IGNOREVISIBILITY|SF_IGNOREWATERBOUNDARY))
					VisibleFriends.Push (Players[I].Mo);
			}
			
			//Found at least one visible friendly player to follow.
			If (VisibleFriends.Size() - 1 >= 0)
			{
				SetFriendPlayer (VisibleFriends[Random (0, VisibleFriends.Size() - 1)].Player); //Randomly pick a visible friend to follow.
				CurrentOrder = ORDER_FOLLOW;
			}
			//No friendplayer, or they are out of sight
			Else If (!FriendPlayer || FriendPlayer && !CheckSight (Players[FriendPlayer].Mo, SF_IGNOREVISIBILITY|SF_IGNOREWATERBOUNDARY))
			{
				CurrentOrder = ORDER_WANDER;
				bDontFollowPlayers = True;
			}
		}
		Else If (User_DefaultOrder ~== "Follow")
		{
			CurrentOrder = ORDER_FOLLOW;
		}
		Else If (User_DefaultOrder ~== "Wander")
		{
			CurrentOrder = ORDER_WANDER;
			bDontFollowPlayers = True;
		}
		Else If (User_DefaultOrder ~== "Stay")
		{
			CurrentOrder = ORDER_STAY;
		}
	}
	
	Override Void Tick()
	{
		Super.Tick();
		
		If (!User_NoHeadlights)
			HeadLightsOn = (CurSector && CurSector.LightLevel <= 104);
		
		If (HeadLightsOn)
			TurnHeadlightsOn();
		Else
			TurnHeadlightsOff();
	}
	
	Override Bool CanCollideWith (Actor Other, Bool Passive)
	{
		//Stops the turret from preventing vehicles from going up slopes and steps due to the turret getting in the way.
		If (!Passive && Other && Other == Turret && ((MVP_BaseTurret(Turret).bFallOnDeath && !IsDead (Turret)) || !MVP_BaseTurret(Turret).bFallOnDeath))
			Return False;
		
		Return Super.CanCollideWith (Other, Passive);
	}
	
	Override Void Die (Actor Source, Actor Inflictor, Int DmgFlags, Name MeansOfDeath)
	{
		Super.Die (Source, Inflictor, DmgFlags, MeansOfDeath);
		If (Turret) //When dead, kill the turret the same way as the vehicle died.
		{
			If (Health < GetGibHealth()) //Same check Die() uses internally to check if an actor was gibbed. 
				{Turret.DamageMobj (Inflictor, Source, Turret.Health+(-Turret.GetGibHealth())+1, MeansOfDeath, DMG_FORCED);a_log ("gib");}
			Else
				Turret.DamageMobj (Inflictor, Source, Turret.Health, MeansOfDeath, DMG_FORCED);
		}
		bShootable = bNotAutoaimed = True; //Destroyed vehicles stay shootable and non-autoaimable unless specified otherwise.
		RemoveHeadlights(); //The vehicles aren't resurrectable, so the headlights aren't needed.
		HeadlightsOn = False;
		CorpseTarget = Null;
		A_StopSound (CHAN_IDLING);
		A_StopSound (CHAN_MOVING);
	}
	
	Override Void OnDestroy()
	{
		Super.OnDestroy();
		RemoveHeadlights();
		If (Turret) Turret.Destroy();
	}
	
	Enum VehicleSoundChannels
	{
		CHAN_IDLING = 23500,
		CHAN_MOVING = 23501
	}
	
	Enum VehicleCommands
	{
		ORDER_NONE = 0, //Null
		ORDER_FOLLOW = 1, //Follow the player when having no target.
		ORDER_WANDER = 2, //Wander around when having no target, instead of following the player.
		ORDER_STAY = 3, //Stay in place until a target appears or you are ordered to start moving again. Then stand around again once the chase timer is out.
		//ORDER_GOTOPOINT ? Perhaps, but maybe not, since I'm not sure how I could code the vehicles to head to a specified point.
	};
	
	Const MARINE_RECURSIONS = 32; //How many times marine dropping vehicles can try dropping in an invalid spot before giving up.
	Const DEFAULT_HEARDISTANCE = 3072; //Exactly what it says, the default hear distance the vehicles' and turrets' A_LookEx calls use.
	
	//AI variables
	Actor NearestEnemy; //The enemy closest to the vehicle, if any.
	Actor CorpseTarget; //The corpse that the vehicle is trying to crush.
	Bool AlreadyRetreating; //The vehicle is already running away from something that doesn't involve the enemy avoiding code, so don't both to run from nearby enemies.
	Int ChaseTimer; //Makes the vehicle only chase its' target for a certain amount of time after it goes out of sight. Is also used to determine how long turreted vehicles stay in one place.
	Int FearTimer; //Makes the vehicle keep running away from it's target for an additional random amount of time, so that it doesn't play peekaboo with enemies.
	Int CurrentOrder; //The current order the vehicle is following.

	//Internal variables
	Array <MVP_Headlight> Headlights; //Pointers to each headlight the vehicle has.
	Bool HeadlightsOn; //Should the headlights be on ?
	MVP_BaseTurret Turret; //The turret the vehicle has, used to actually spawn said turret.
	Vector3 TurretOffsets; //The offsets of the turret relative to the vehicle.
	
	Double MaxCorpseRadius, MaxCorpseHeight;
	Property MaxCorpseRadius : MaxCorpseRadius;
	Property MaxCorpseHeight : MaxCorpseHeight;
	
	//Flag variables
	Private Int VehicleFlags;
	FlagDef Transport : VehicleFlags, 0; //The vehicle is marked as being able to transport soldiers.
	FlagDef NoRadio : VehicleFlags, 1; //The vehicle ignores orders given to it by the radio item.
	Class<MVP_BaseTurret> VehicleTurret; //The pointer to the vehicles' turret, if any.
	Property VehicleTurret : VehicleTurret;
	
	//Generic user variables
	Bool User_NoHeadLights; //Vehicle doesn't use it's headlights, or if its' a prop, the headlights should be off.
	Double User_RetreatDistance; //The amount of distance the vehicle keeps from enemies.
	Int User_ChaseTime; //How much time the vehicle spends looking for it's out-of-sight target before giving up.
	String User_DefaultOrder; //The default order the vehicle follows upon spawning.
	
	States
	{
		StickAround: //Generic state shared by all vehicles, for when they are far enough from any enemies to be able to just sit and let their turrets do the work.
			#### # 0
			{
				//Face sideways from your target, if any.
				A_FaceTarget ();
				If (Target)
					Angle += RandomPick (75,80,85,90,95,10,105);
			}
			#### # 4 //If an enemy has gotten too close or enough time has passed, then stop standing around.
			{
				If (ChaseTimer <= 0 || FindNearestEnemy (User_RetreatDistance/1.4) || IsDead (Turret))
				{
					ChaseTimer = 0;
					Return ResolveState ("See");
				}
				
				ChaseTimer--;
				Return State (Null);
			}
			Goto StickAround+1;
	}
}

Class MVP_BaseTurret : MVP_BaseVehicle Abstract
{
	Default
	{
		Speed 0;
		FastSpeed 0;
		RipLevelMin 2;
		MaxStepHeight 0;
		Mass 500;
		Tag "Military Vehicle Turret Base (You really shouldn't be seeing this in-game)";
		DamageFactor "MarineGrenade", 0.9;
		DamageFactor "MarineRifle", 0.75;
		+NoFear;
		+DontThrust;
		+StandStill;
		+DontFollowPlayers;
		+NoSpriteShadow;
		+MVP_BaseVehicle.NoRadio;
		-AvoidHazards;
		-AvoidMelee;
		-CanBlast; //Turrets are attached to their vehicle.
		-CountKill; //And because of that, they don't count as kills either.
	}
	
	Private Int TurretFlags;
	FlagDef FallOnDeath : TurretFlags, 0; //Turret stops being attached to its' vehicle after dying.
	
	Double MaxPitch, MinPitch;
	Property MaximumPitch : MaxPitch;
	Property MinimumPitch : MinPitch;
	
	Int LastEnemyDelay; //Used for the turret rotating code, to make it so the turret snaps back to the vehicle after some time of not having a target.
	Double DeathAngleOffset; //Offsets the rotation of the turrets by this amount when they are killed.
	Vector3 LastEnemyPosition; //Used by the target prediction. If the turret has a target with no velocity, it grabs their last position every tick to compare it to the current position.
	Vector3 CurrentEnemyPosition;
	Int TicsSinceLastMove; //Keeps track of how many tics have elapsed since the enemy last changes it's position from the above coordinates, and- just fucking look at HandleTargetPrediction().
	
	Override Void PostBeginPlay ()
	{
		Actor.PostBeginPlay ();
		If (!bFriendly) Species = 'MilitaryHostile';
	}
	
	Override Void UserVariableDefaults ()
	{
		User_RetreatDistance = -1; //Turrets can't move or be scared anyway.
		User_ChaseTime = 30*4;
	}
	
	Override Bool CanAttack() {Return True;} //Yes.
	
	Override Void Tick()
	{
		Actor.Tick();
		
		/*If (Target && Target.Pos == LastEnemyPosition)
			TicsSinceLastMove++;
		Else
			TicsSinceLastMove = 0;
		*/
		If (Target && Target.Tics == Target.CurState.Tics)
		{
			LastEnemyPosition = CurrentEnemyPosition;
			CurrentEnemyPosition = Target.Pos;
			//CurrentEnemyPosition = ((1-(1./35)) * LastEnemyPosition) + ((1./35) * CurrentEnemyPosition);
		}
		Else If (!Target)
			LastEnemyPosition = CurrentEnemyPosition = (0,0,0);
		
		If (!(MaxPitch == 0 && MinPitch == 0)) Pitch = Clamp (Pitch,MaxPitch,MinPitch);
		
		If (!Master || IsFrozen() || IsDead(Self) && bFallOnDeath) Return;
		
		SetOrigin (Master.Vec3Offset(TurretOffsets.X,TurretOffsets.Y,Master.Height+TurretOffsets.Z),True);
	}
	
	Override Void Die (Actor Source, Actor Inflictor, Int DmgFlags, Name MeansOfDeath)
	{
		If (Master){
			DeathAngleOffset = DeltaAngle (Angle,Master.Angle);CONSOLE.PRINTF ("the offset relative to the vehicle is %d",deathangleoffset);}
		Actor.Die (Source, Inflictor, DmgFlags, MeansOfDeath);
		bShootable = bNotAutoaimed = True;
		If (bFallOnDeath) bNoSpriteShadow = False;
		LastEnemyDelay = 0;
	}
	
	Override Void OnDestroy()
	{
		Actor.OnDestroy();
	}
}

//Could be used to add generic per-texture liquid splashes for solid and swimmable liquid floors.
Class MVP_BaseProjectile : FastProjectile
{
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		If (Target) Species = Target.Species;
	}
	Int UpdateProjectileElevation (Int FaceDown, Int FaceDown2, Int FaceStraight, Int FaceUp, Int FaceUp2)
	{
		If (Pitch >= 70)
			Return FaceDown2;
		Else If (Pitch >= 30 && Pitch < 70)
			Return FaceDown;
		Else If (Pitch < 30 && Pitch > -30)
			Return FaceStraight;
		Else If (Pitch <= -30 && Pitch > -70)
			Return FaceUp;
		Else If (Pitch <= -70)
			Return FaceUp2;
		
		Return FaceStraight;
	}
}

Class MVP_Headlight : DynamicLight
{
	Default
	{
		DynamicLight.Type "Point";
		//+DynamicLight.Attenuate;
		+DynamicLight.Spot;
	}
	
	Bool Active; //The actual internal m_active variable that reports if a dynamic light is on, isn't exposed to ZScript.
	Vector3 Offset; //X = Side to side, Y = Back and front, Z = Up and down
	Bool IsBacklight;
	
	Override Void Tick()
	{
		If (Master && MVP_BaseVehicle(Master).HeadlightsOn)
			Warp (Master,Offset.X,Offset.Y,Offset.Z,IsBacklight ? 180 : 0);
	}
	
	Override Void BeginPlay()
	{
		Super.BeginPlay();
		
		Args[LIGHT_RED] = 255;
		Args[LIGHT_GREEN] = 255;
		Args[LIGHT_BLUE] = 255;
		Args[LIGHT_INTENSITY] = 256;
	}
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		Deactivate(Self); //Off by default.
	}
}

//The actor that warns marines around a specified area to run away from the zone in question, it uses the following properties and flags:
//MaxTargetRange: Determines the exact size of the warning zone.
//HarmFriends: Gives the warning to marines that are on the same side as the warning zone too, for stuff like indiscriminate AOE attacks. Use CopyFriendliness to make the zone share the allegience of its' creator.
//CausePain: Specifies to marines that the AOE attack just causes pain, so they won't run away if on a turret, where they don't feel pain to begin with. This is basically only here because of the Army Car's pain ray.
Class SmartMarineWarningZone : Actor
{
	Default
	{
		Radius 0.1; Height 0;
		MaxTargetRange 256;
		+Friendly; //To get your grenade-type warning to work with the marines the Friendly flag is NEEDED, because otherwise friendly marines will sometimes end up running in place for some ungodly reason.
		+Shootable; //This will hopefully stop marines running from these warnings from ever getting stuck and running in place.
		+NotAutoaimed
		+NoBlood;
		+NoDamage;
		+NoInteraction;
		+NoGravity;
	}
	Inventory Token;
	
	//Cool code duplication because the warning zone isn't a vehicle of any kind.
	Bool MarineIsOnTurret (Actor Other)
	{
		Let IsOnTurret = ServiceIterator.Find ("SM_SmartMarines").Next();
		
		If (!IsOnTurret)
			Return False;
		
		If (IsOnTurret.GetInt("",ObjectArg:Other))
			Return True;
		
		Return False;
	}
	
	Override Void Tick ()
	{
		String TheMarine = "SmartMarine";
		String TheOtherMarine = "TurretMarine";
		String WarningToken = "SM_ImInDanger";
		//Can be used to attach the zone to an actor.
		If (Master)
			SetOrigin (Master.Pos,True);
		
		BlockThingsIterator MarineFinder = BlockThingsIterator.Create (Self,MaxTargetRange);
		
		Actor Mobj;
		
		While (MarineFinder.Next())
		{
			Mobj = MarineFinder.Thing;
			
			If (!(Mobj.GetClassName() == TheMarine || Mobj.GetClassName() == TheOtherMarine)) Continue;
			
			//Don't warn marines on the same side as the warning zone.
			If (!bHarmFriends)
			{
				If (Mobj.Health > 0 && !Mobj.bDormant && IsHostile (Mobj) && Distance3DSquared(Mobj) <= MaxTargetRange*MaxTargetRange)
				{
					If (!bCausePain || bCausePain && !MarineIsOnTurret(Mobj))
					{
						Token = Mobj.GiveInventoryType (WarningToken);
						If (Token) Token.Master = Self;
					}
				}
			}
			//Warn all marines in the vicinity.
			Else
			{
				If (Mobj.Health > 0 && !Mobj.bDormant && Distance3DSquared(Mobj) <= MaxTargetRange*MaxTargetRange)
				{
					If (!bCausePain || bCausePain && !MarineIsOnTurret(Mobj))
					{
						Token = Mobj.GiveInventoryType (WarningToken);
						If (Token) Token.Master = Self;
					}
				}
			}
		}
	}
}
//$GZDB_SKIP
//Functions and code exclusive to the turret class.
Extend Class MVP_BaseTurret
{
	//Conditionally change the turrets' sprites based on pitch.
	Int UpdateElevation (Int FaceDown, Int FaceStraight, Int FaceUp, Int FaceUp2)
	{
		If (Pitch >= 6 && Pitch >= 0)
			Return FaceDown;
		Else If (Pitch < 6 && Pitch >= -15)
			Return FaceStraight;
		Else If (Pitch < -15 && Pitch >= -50)
			Return FaceUp;
		Else If (Pitch <= -50)
			Return FaceUp2;
		
		Return FaceStraight;
	}
	
	//Makes the turret rotate back over time to the direction that the vehicle is facing. Instead of snapping back instantly.
	Void RotateToVehicle (Bool NoTargetCheck = False)
	{
		If (Master && IsDead (Self))
		{
			Angle = Master.Angle+DeathAngleOffset;console.printf ("the angle is now %d",angle);
			Return;
		}
		
		If ((!Target || NoTargetCheck) && Master)
		{
			//If the angle and pitch difference are too small, just start snapping to the vehicles' direction.
			If (!LastEnemyDelay || Abs (Master.Pitch - Pitch) < 0.5)
				Pitch = Master.Pitch;
			Else
				Pitch += (Master.Pitch - Pitch) * 0.15;
			
			If (!LastEnemyDelay || AbsAngle (Master.Angle, Angle) < 0.5)
				Angle = Master.Angle;
			Else
			{
				A_StartSound ("Vehicle/APC/TurretTurn",attenuation:0.8);
				Angle += DeltaAngle (Angle, Master.Angle) * 0.15;
			}
		}
	}
	
	Void UpdateLastEnemyTimer (Int DefaultValue = 50)
	{
		If (!Target && LastEnemyDelay > 0)
			LastEnemyDelay--;
		Else If (Target)
			LastEnemyDelay = DefaultValue;
	}
	
	//Handles making the vehicles lead their shots based on their targets' movement, regardless of whether or not it's a player or monster.
	Void HandleTargetPrediction (Actor Projectile, Vector2 SpreadHorz, Vector2 SpreadVert)
	{
		Vector3 OldVel;
		If (!Projectile || !Target) Return;
		
		//Target has no velocity for VelIntercept to work with. This is almost always the case for normal NPCs, which move using small teleport steps, instead of actual movement.
		If ((Target.Vel.X == 0 && Target.Vel.Y == 0 && Target.Vel.Z == 0))
		{
			OldVel = Target.Vel;
			
			If (Target.CurState.Tics)
				Target.Vel = Level.Vec3Diff (LastEnemyPosition,CurrentEnemyPosition) / Target.CurState.Tics;
			Else //Fallback to prevent division by zero.
				Target.Vel = Level.Vec3Diff (LastEnemyPosition,CurrentEnemyPosition);
			
			If ((Target.Vel.X == 0 && Target.Vel.Y == 0 && Target.Vel.Z == 0)) //Still no velocity
			{a_log ("no velocity still, falling back to normal aiming");
				Projectile.A_FaceMovementDirection();
				Projectile.Angle += FRandom (SpreadHorz.X,SpreadHorz.Y);
				Projectile.Pitch += FRandom (SpreadVert.X,SpreadVert.Y);
				Projectile.Vel3DFromAngle (Projectile.Speed,Projectile.Angle,Projectile.Pitch);
				Console.Printf ("The pitch is %f",Pitch);
				Target.Vel = OldVel;
				Return; //Just add in the projectile spread and finish.
			}
			Projectile.VelIntercept (Target);
			Projectile.Angle += FRandom (SpreadHorz.X,SpreadHorz.Y);
			Projectile.Pitch += FRandom (SpreadVert.X,SpreadVert.Y);
			Projectile.Vel3DFromAngle (Projectile.Speed,Projectile.Angle,Projectile.Pitch);
			Console.Printf ("The pitch is %f",Pitch);
			Target.Vel = OldVel;
		}
		//Target has velocity, like if it's a player or a custom actor with velocity-based movement.
		Else
		{
			A_Log ("Target has velocity");
			Projectile.VelIntercept (Target);
			Projectile.Angle += FRandom (SpreadHorz.X,SpreadHorz.Y);
			Projectile.Pitch += FRandom (SpreadVert.X,SpreadVert.Y);
			Projectile.Vel3DFromAngle (Projectile.Speed,Projectile.Angle,Projectile.Pitch);
			Console.Printf ("The pitch is %f",Pitch);
		}
	}
}
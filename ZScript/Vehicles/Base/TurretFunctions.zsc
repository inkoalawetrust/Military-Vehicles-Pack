//$GZDB_SKIP
//Functions and code exclusive to the turret class.
Extend Class MVP_BaseTurret
{
	//Is the turrets' target too high or to low over the turrets' elevation limits ?
	Int IsOverPitchLimits()
	{
		If (MaxPitch == 0 && MinPitch == 0) Return ELEVATION_INBOUNDS; //No elevation limits.
		Double Diff = 0.1; //The turret pitch is clamped every tick, so this small difference allows them to still stop shooting.
		If (Pitch-Diff < MaxPitch) Return ELEVATION_TOOHIGH;
		If (Pitch+Diff > MinPitch) Return ELEVATION_TOOLOW;
		Return ELEVATION_INBOUNDS;
	}
	
	//Conditionally change the turrets' sprites based on pitch.
	Int UpdateTurretElevation (Int FaceDown, Int FaceStraight, Int FaceUp, Int FaceUp2)
	{
		If (Pitch >= 6 && Pitch >= 0)
			Return FaceDown;
		Else If (Pitch < 6 && Pitch >= -15)
			Return FaceStraight;
		Else If (Pitch < -14 && Pitch >= -50)
			Return FaceUp;
		Else If (Pitch <= -50)
			Return FaceUp2;
		
		Return FaceStraight;
	}
	
	Enum TurretRotationFlags
	{
		RTVF_NOTARGETCHECK	= 1 << 0, //The turret will apply its' rotation mechanics even without a target.
		RTVF_RELATIVEONLY	= 1 << 1, //The turret will only rotate relative to its' masters' angle + its' DeathAngleOffset, even if the turret isn't destroyed.
		RTVF_SOUNDONLY		= 1 << 2, //Only handle the sound related mechanics.
		RTVF_ALTSOUNDLOGIC	= 1 << 3, //Play the turn sound when the angle difference between the last and current tick is bigger tha TurnSoundRadius.
	}
	
	//Makes the turret rotate back over time to the direction that the vehicle is facing. Instead of snapping back instantly.
	//By default, the turn sound plays when LastEnemyDelay is 0, and only for as long as the angle difference between the turret and vehicle is big enough.
	//What this means in practice is that the sound by default only plays when the turret is rotating back to its' vehicle after a fight.
	Void RotateToVehicle (Int Flags = 0)
	{
		If (!Master) Return;
		
		/*If (Flags & RTVF_SOUNDONLY)
		{
			If (TurnSound && AbsAngle (Master.Angle, Angle) > TurnSoundRadius)
					A_StartSound (TurnSound,attenuation:0.8);
			Return;
		}
		
		If (Flags & RTVF_ALTSOUNDLOGIC)
		{
			If (AbsAngle (Angle,OldAngle) >= TurnSoundRadius && LastEnemyDelay)
				A_StartSound ("Vehicle/APC/TurretTurn",attenuation:0.8);
		}*/
		
		If (IsDead (Self) || Flags & RTVF_RELATIVEONLY)
		{
			Angle = Master.Angle+DeathAngleOffset;
			Return;
		}
		
		If ((!Target || Flags & RTVF_NOTARGETCHECK))
		{
			If (AbsAngle (Master.Angle, Angle) < 0.75) LastEnemyDelay = 0; //Snap back into the vehicles' position if the angle difference is small enough.
			
			//If the pitch difference is too small, just start snapping to the vehicles' direction.
			If (!LastEnemyDelay || Abs (Master.Pitch - Pitch) < 0.75)
				Pitch = Master.Pitch;
			Else
				Pitch += (Master.Pitch - Pitch) * TurnAmount;
			
			If (!LastEnemyDelay)
			{
				Angle = Master.Angle;
				//If (IsActorPlayingSound (CHAN_BODY,TurnSound)) A_StopSound (CHAN_BODY); //DEBUG: For debugging the di-cokka's extreme pain turret turn.
			}
			Else
			{
				//If (!(Flags & RTVF_ALTSOUNDLOGIC) && TurnSound && AbsAngle (Master.Angle, Angle) > TurnSoundRadius)
				//	A_StartSound (TurnSound,attenuation:0.8);
				Angle += DeltaAngle (Angle, Master.Angle) * TurnAmount;
			}
		}
	}
	
	Void UpdateLastEnemyTimer (Int DefaultValue = 50)
	{
		If (!Target && LastEnemyDelay > 0)
			LastEnemyDelay--;
		Else If (Target)
			LastEnemyDelay = DefaultValue;
	}
	
	//Handles making the vehicles lead their shots based on their targets' movement, regardless of whether or not it's a player or monster.
	//Projectile: The projectile to spawn.
	//SpreadHorz/SpreadVert: Maximum and minimum horizontal and vertical spread, stored in Vector2s.
	//MinDist: The minimum distance below which target prediction won't be used. And the projectile will be fired straight at the target instead.
	Void HandleTargetPrediction (Actor Projectile, Vector2 SpreadHorz = (0,0), Vector2 SpreadVert = (0,0), Double MinDist = 1024)
	{
		Vector3 OldVel;
		If (!Projectile || !Target) Return;
		
		//No movement prediction, so just shoot normally and move on.
		If (bNoTargetPrediction || Distance3DSquared(Target) <= MinDist*MinDist)
		{
			NormalProjectileFire (Projectile,SpreadHorz,SpreadVert);
			Return;
		}
		
		//Target has no velocity for VelIntercept to work with. This is almost always the case for normal NPCs, which move using small teleport steps, instead of actual movement.
		If ((Target.Vel.X == 0 && Target.Vel.Y == 0 && Target.Vel.Z == 0))
		{
			OldVel = Target.Vel;
			
			If (Target.CurState.Tics)
				Target.Vel = Level.Vec3Diff (LastEnemyPosition,CurrentEnemyPosition) / Target.CurState.Tics;
			Else //Fallback to prevent division by zero.
				Target.Vel = Level.Vec3Diff (LastEnemyPosition,CurrentEnemyPosition);
			
			If ((Target.Vel.X == 0 && Target.Vel.Y == 0 && Target.Vel.Z == 0)) //Still no velocity
			{
				NormalProjectileFire (Projectile,SpreadHorz,SpreadVert);
				Target.Vel = OldVel; //Revert velocity.
				Return;
			}
			Projectile.VelIntercept (Target);
			Projectile.Angle += FRandom (SpreadHorz.X,SpreadHorz.Y);
			Projectile.Pitch += FRandom (SpreadVert.X,SpreadVert.Y);
			Projectile.Vel3DFromAngle (Projectile.Speed,Projectile.Angle,Projectile.Pitch);
			Target.Vel = OldVel;
		}
		//Target has velocity, like if it's a player or a custom actor with velocity-based movement.
		Else
		{
			Projectile.VelIntercept (Target);
			Projectile.Angle += FRandom (SpreadHorz.X,SpreadHorz.Y);
			Projectile.Pitch += FRandom (SpreadVert.X,SpreadVert.Y);
			Projectile.Vel3DFromAngle (Projectile.Speed,Projectile.Angle,Projectile.Pitch);
		}
	}
	
	//Adds projectile spread and adjusts the projectiles' velocity accordingly. Basically just normal shooting with no prediction.
	Void NormalProjectileFire (Actor Projectile, Vector2 SpreadHorz, Vector2 SpreadVert)
	{
		Projectile.A_FaceMovementDirection();
		Projectile.Angle += FRandom (SpreadHorz.X,SpreadHorz.Y);
		Projectile.Pitch += FRandom (SpreadVert.X,SpreadVert.Y);
		Projectile.Vel3DFromAngle (Projectile.Speed,Projectile.Angle,Projectile.Pitch);
	}
	
	//This function can be used by turrets to make them able to pick different targets from their master, instead of chasing or firing at the same target.
	//The Avoid parameter specifies the actor to avoid targeting, Origin specifies the actor the search starts around, and CheckRange is the search range.
	/*MinAlternateTargetRange specifies how far the new target must be from the actor that must be avoided. A value of 0 or less makes it just randomly
	pick one of the target candidates. If there is no other target that is further than MinAlternateTargetRange from the actor to avoid, then it picks the
	last target candidate left in the array.*/
	Actor PickDifferentTarget (Actor Avoid, Actor Origin, Double CheckRange, Double MinAlternateTargetRange = -1)
	{
		If (!Avoid || !CheckRange) Return Null;
		
		Array <Actor> TargetList;
		
		BlockThingsIterator EnemyFinder = BlockThingsIterator.Create (Origin,CheckRange);
		
		CheckRange *= CheckRange; //Do the multiplication for Distance3DSquared only once.
		
		While (EnemyFinder.Next())
		{
			Actor Mobj = EnemyFinder.Thing;
			
			If (!Mobj || Mobj == Avoid) Continue; //AVOID THIS TARGET.
			
			If (Mobj.bDormant || !Mobj.bIsMonster) Continue; //Don't attack dormant or non-monster actors.
			
			If (!CanBeTargeted(Mobj)) Continue; //Can't be targeted. (Duh)
			
			If (IsDead (Mobj)) Continue; //Is dead (Duuuuuuuuuuh)
			
			If (Origin.Distance3DSquared(Mobj) > CheckRange) Continue; //Too out of reach.
			
			If (!IsHostile (Mobj)) Continue; //Actor isn't hostile.
			
			If (!CheckSight(Mobj)) Continue; //Actor is not visible.
			
			TargetList.Push(Mobj); //Actor passed the checks, put it on the list of candidates.
		}
		
		//If no target was found at all.
		If (!TargetList.Size()) Return Null;
		
		//The minimum distance the new target must have from the actor to avoid is zero, so just pick a random potential target that was found.
		If (MinAlternateTargetRange <= 0) Return TargetList[Random(0,TargetList.Size()-1)];
		
		For (Int I = 0; I < TargetList.Size(); I++)
		{
			If (I == TargetList.Size()-1) Return TargetList[I]; //No target that were further than the actor to avoid, so return the last candidate left.
			
			If (TargetList[I].Distance3DSquared(Avoid) > MinAlternateTargetRange) Return TargetList[I]; //Candidate is too close to the actor to avoid.
			Else {} //Found a potential target that is far enough away from the actor that must be avoided.
		}
		
		Return Null;
	}
}

//This is the base class for making custom LineTracer-based line of fire checks for vehicles. This is better than the old method of a do-all LOF check method.
//It contains some basic LOF-related checks methods. Along with access to the MVPs' generic actor checks.
Class MVP_LOFRaycast : LineTracer
{
	Mixin MVP_CheckFunctions;
	Bool BadLOF; //If true, there is something standing in the shooters' line of fire.
	Actor Shooter; //The actor firing the raycast.
	
	//Should the actor shoot at the prop ?
	//Other: The actor to check.
	//HealthThreshold: If the props' health is at or below this value, then shoot.
	Bool CanShootAtProp (Actor Other, Int HealthThreshold = 400)
	{
		If (!Other || !Shooter) Return False;
		If (HealthThreshold <= 0) Return False; //No health limit specified.
		
		//Actor is an destructible inanimate object. And it's health is at or below the minimum threshold.
		If (IsInanimateObject (Other) && !IsIndestructible (Other) && Other.Health <= HealthThreshold)
			Return True;
		
		Return False;
	}
	
	//Is the other actor a corpse that is still collidable ?
	Bool IsSolidCorpse (Actor Other)
	{
		If (!Other) Return False;
		
		If (!IsDead (Other)) Return False;
		
		If (!Other.bDontCorpse) Return False;
		
		Return True;
	}
	
	//Useful for ripper projectiles, returns false if the actor hit can be ripped.
	Bool CantRipActor (Actor Other, Int RipLevel)
	{
		Bool NoRipMin = !Other.RipLevelMin;
		Bool NoRipMax = !Other.RipLevelMax;
		
		If (!NoRipMin && Other.RipLevelMin > RipLevel || !NoRipMax && Other.RipLevelMax < RipLevel)
			Return True;
		
		Return False;
	}
	
	Enum BLITWFlags
	{
		BLITW_HitscansToo 	= 1 << 0,	//Check for hitscan blocking lines too.
		BLITW_HitscansOnly	= 1 << 1	//Check ONLY for hitscan blocking lines.
	}
	//Is the line the trace went through blocking ?
	Bool BlockingLineInTheWay (Line Blocking, Int Flags)
	{
		If (!Blocking) Return False;
		
		If (!Flags)
			If (Blocking.Flags & (Line.ML_BLOCKPROJECTILE | Line.ML_BLOCKEVERYTHING))
				Return True;
		Else If (Flags & BLITW_HitscansToo)
			If (Blocking.Flags & (Line.ML_BLOCKPROJECTILE | Line.ML_BLOCKHITSCAN | Line.ML_BLOCKEVERYTHING))
				Return True;
		Else If (Flags & BLITW_HitscansOnly)
			If (Blocking.Flags & (Line.ML_BLOCKHITSCAN | Line.ML_BLOCKEVERYTHING))
				Return True;
		
		Return False;
	}
}

//Generic projectile LOF check for non-ripping projectiles, should be applicable to most projectiles.
Class MVP_ProjectileLOFCheck : MVP_LOFRaycast
{
	Int PropHealthThreshold;
	Override ETraceStatus TraceCallback()
	{
		If (PropHealthThreshold == 0) PropHealthThreshold = 400; //Default value, since it can't be set with a normal variable decleration.
		Actor Mobj = Results.HitActor;
		
		If (!Shooter) Return Trace_Stop;
		
		If (Mobj == Shooter.Master) Return Trace_Skip;
		
		//The target is in the line of fire. Shoot them anyway.
		If (Mobj == Shooter.Target)
			Return Trace_Stop;
		
		//Indestructible prop in the way.
		If (IsIndestructible (Mobj) && IsInanimateObject (Mobj) || !IsIndestructible(Mobj) && IsInanimateObject (Mobj) && !CanShootAtProp(Mobj,400))
		{
			BadLOF = True;
			Return Trace_Stop;
		}
		
		//Destructible prop, but far too strong to shoot through in a timely manner.
		If (!IsIndestructible(Mobj) && IsInanimateObject (Mobj) && !CanShootAtProp(Mobj,PropHealthThreshold))
		{
			BadLOF = True;
			Return Trace_Stop;
		}
		
		//Solid corpse of an enemy in the way, shell can't go through.
		If (Shooter.IsHostile(Mobj) && IsSolidCorpse(Mobj))
		{
			BadLOF = True;
			Return Trace_Stop;
		}
		
		//Self explanatory.
		If (BlockingLineInTheWay (Results.HitLine,0))
		{
			BadLOF = True;
			Return Trace_Stop;
		}
		
		Return Trace_Skip;
	}
}
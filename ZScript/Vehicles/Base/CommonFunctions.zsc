//$GZDB_SKIP
//NOTE: This shit is really long, some of it will be moved over once I begin working on KAI. But still, different types of functions should probably begin being put in different files.

//Functions that can be used outside of the MVP_BaseVehicle class.
Mixin Class MVP_MathFunctions
{
	//KAINOTE: All the math functions have been moved to the library, I'll probably just remove this mixin from the MVP entirely.
}

Mixin Class MVP_UniversalFunctions
{
	Enum LiquidTypes
	{
		LIQUID_NONE = 0,
		LIQUID_WATER = 1,
		LIQUID_NUKAGE = 2,
		LIQUID_BLOOD = 3,
		LIQUID_LAVA = 4,
		LIQUID_SLIME = 5
	};
	
	Int CheckLiquid (TextureID Texture)
	{
		/*===============================================================
		This class stores the names of the different textures used for each type of liquid.
		These lists can be expanded as seen fit for your project, in case it has additional custom water/nukage/blood/lava/slime textures.
		The lists already contain some names of liquid flats that don't exist in the vanilla game, for built-in mod compatibility.
		Such as by having waterfall textures that don't exist like WFALL# and NFALL#.
		===============================================================*/
		Static Const String WaterTextures[] = {"FWATER1", "FWATER2", "FWATER3", "FWATER4", "WFALL1", "WFALL2", "WFALL3", "WFALL4"};
		Static Const String NukageTextures[] = {"NUKAGE1", "NUKAGE2", "NUKAGE3", "NFALL1", "NFALL2", "NFALL3", "NFALL4"};
		Static Const String BloodTextures[] = {"BLOOD1", "BLOOD2", "BLOOD3", "BFALL1", "BFALL2", "BFALL3", "BFALL4"};
		Static Const String LavaTextures[] = {"LAVA1","LAVA2", "LAVA3", "LAVA4", "DBRAIN1", "DBRAIN2", "DBRAIN3", "DBRAIN4", "LFALL1", "LFALL2", "LFALL3", "LFALL4"};
		Static Const String SlimeTextures[] = {"SLIME01","SLIME02", "SLIME03", "SLIME04", "SLIME05","SLIME06", "SLIME07", "SLIME08", "SFALL1", "SFALL2", "SFALL3", "SFALL4"};
		
		For (Int I = 0; I < WaterTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (WaterTextures[I]) == Texture)
				Return LIQUID_WATER;
		For (Int I = 0; I < NukageTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (NukageTextures[I]) == Texture)
				Return LIQUID_NUKAGE;
		For (Int I = 0; I < BloodTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (BloodTextures[I]) == Texture)
				Return LIQUID_BLOOD;
		For (Int I = 0; I < LavaTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (LavaTextures[I]) == Texture)
				Return LIQUID_LAVA;
		For (Int I = 0; I < SlimeTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (SlimeTextures[I]) == Texture)
				Return LIQUID_SLIME;
		
		Return LIQUID_NONE;
	}
}

//Generic status checks.
//KAIREMOVE: Remove all the functions in this mixin besides CustomMarinesAvailable and MVP_IsHostile, since the rest are in KAIs' version of the mixin.
Mixin Class MVP_CheckFunctions
{
	
}

//Vehicle functions and code shared by both MVP_BaseVehicle and KAI_BaseVehicle.
//Inheritance will be the death of me.
Mixin Class MVP_CommonFunctions
{
	Bool CustomMarinesAvailable()
	{
		Let MarineCheck = SM_MarineChecker (EventHandler.Find("SM_MarineChecker"));
		
		If (!MarineCheck.NoCustomMarines)
			Return True;
		Else
			Return False;
	}
	
	//KAICHANGE: The library now has an IsActorHostile virtual for the KAI(MVP)_CrushCorpses function. So plug this function in as the return value of that virtual.
	//Is the other actor hostile?
	Bool MVP_IsHostile (Actor Caller, Actor Other)
	{
		If (!Caller || !Other) Return False;
		
		If (Caller.bFriendly) //It's as shrimple as that.
			Return Caller.IsHostile (Other);
		//Enemy vehicles are the reason this function exists.
		//They generally don't attack other non-enemy military NPCs. But they will do so if those NPCs are targetting them, or another enemy military NPC.
		Else
		{
			//Non-friendly actors always hate players and their allies.
			If (Other.Player || Other.bFriendly)
				Return True;
			
			//Don't consider own species hostile.
			//If (Caller.bNoInfightSpecies && Caller.Species == Other.Species)
			//	{console.printf ("that's my own species");Return False;} //DEBUG
			
			//Is the other actor targetting you or your turret ?
			If (Other.Target && (Other.Target == Caller || Other.Target == MVP_BaseVehicle(Caller).Turret))
				Return True;
			
			//Is the other actor targetting an actor with the same species as you ? Then they are an enemy as far as you are concerned.
			If (Other.Target && (Caller.bNoInfightSpecies && Caller.Species == Other.Target.Species))
				Return True;
		}
		
		Return False;
	}
	
	Const MARINE_RECURSIONS = 32; //How many times marine dropping vehicles can try dropping in an invalid spot before giving up.
	
	Enum VehicleCommands
	{
		ORDER_NONE = 0, //Null
		ORDER_FOLLOW = 1, //Follow the player when having no target.
		ORDER_WANDER = 2, //Wander around when having no target, instead of following the player.
		ORDER_STAY = 3, //Stay in place until a target appears or you are ordered to start moving again. Then stand around again once the chase timer is out.
		//ORDER_GOTOPOINT ? Perhaps, but maybe not, since I'm not sure how I could code the vehicles to head to a specified point.
	};
	
	//AI variables
	Actor DeathWarnZone; //The warning zone attached to the vehicle after it died, if any. Used to warn Smart Marines if the vehicle wreck is burning.
	
	//Internal variables
	Array <Actor> DeathFlames; //Pointers to the flames created by the vehicle being gibbed.
	
	//=====|Status checks|=====\\	
	//KAIKEEP: Keep this function to the MVP. Since it runs stuff that only makes sense in the context of the MVP. IDEA: Maybe make IsPowerful a virtual ?
	//Add a function that determines if the vehicles' target is a VERY powerful enemy.
	Bool IsPowerful (Actor Other)
	{
		Name CustomMarine = 'SmartMarine';
		Name CustomTurretMarine = "TurretMarine";
		Name TurretWeapon = 'SmartMarineMGWeapon';
		
		If (!Other)
			Return False;
		
		//Is the other actor a smart marine or player on a turret ?
		If (CustomMarinesAvailable() && (Other Is CustomMarine && MarineIsOnTurret (Other)
		|| Other Is CustomTurretMarine
		|| Other.Player && Other.Player.ReadyWeapon && Other.Player.ReadyWeapon.GetClassName() == TurretWeapon))
			Return True;
		
		//Does the actor have 2500 health or more, is sufficiently large, or can reflect projectiles ?
		If ((Other.SpawnHealth() >= 2500 || Other.Health >= 2500) || (Other.Height >= 80 && Other.Radius >= 72) || Other.bReflective)
			Return True;
		
		Return False;
	}
	//=====|Spawn functions|=====\\
	Enum MVPFlameFlags
	{
		FSP_WARNMARINES = 1 << 0, //If any flames are succesfully created around the vehicle, should a marine warning zone be made ?
		FSP_VEHICLEDEATH = 1 << 1 //Mark the warning zone as needing to vanish once all of the flames have evaporated.
	}
	
	//FIXME: Fix a bug where sometimes no flames will spawn, not sure why it happens, but it seems to occur in crammed spaces usually.
	//Creates multiple flames within the bounding box of the vehicle. Used to create flaming wrecks when vehicles are gibbed.
	//Flags: The flags that control the spawning behavior, look at MVPFlameFlags for more info. Default flags are FSP_WARNMARINES and FSP_VEHICLEDEATH.
	//Amount: The random amount of flames that will be created, the X component is the minimum amount of flames, and Y is the maximum.
	//Lifespan: The random lifespan each flame has in tics, the default is 35*30 (30 seconds). The X component is the minimum lifespan a flame can have, and Y is the maximum.
	Void SpawnDeathFlames (Int Flags = FSP_WARNMARINES|FSP_VEHICLEDEATH, Vector2 Amount = (5,12), Vector2 Lifespan = (24*TICRATE,105*TICRATE))
	{
		Int RandomFlames = Random (Int(Amount.X),Int(Amount.Y));
		Actor Flame;
		Vector3 SpawnPos;
		//Spawn a random amount of flames around the APC wreck.
		For (Int I = 0; I < RandomFlames; I++)
		{
			SpawnPos = (FRandom (-Radius*1.75,Radius*1.75),FRandom (-Radius,Radius),0);
			SpawnPos.Z = GetZAt (SpawnPos.X,SpawnPos.Y) + 8 + FRandom (0, Height - 8);
			//If the random position relative to the vehicle is valid.
			If (Level.IsPointInLevel (Vec3Offset(SpawnPos.X,SpawnPos.Y,SpawnPos.Z)))
				Flame = Spawn ("MVP_Flame",Vec3Offset(SpawnPos.X,SpawnPos.Y,SpawnPos.Z)); //Then spawn the flame.
			
			If (Flame)
			{
				Flame.Master = Self; //So the flame knows what actor to warp to.
				MVP_Flame(Flame).Offsets = SpawnPos;
				Flame.ReactionTime = Int(FRandom (Lifespan.X,LifeSpan.Y));
				DeathFlames.Push (Flame); //Add the valid flame to the list.
			}
		}
		
		//Clean up the null entries in the array.
		For (Int I = DeathFlames.Size()-1; I >= 0; I--)
			If (!DeathFlames[I]) DeathFlames.Delete(I); //Remove null entries.
		
		//Create a warning zone if any flames actually spawned.
		If (Flags & FSP_WARNMARINES && DeathFlames.Size())
			If (Flags & FSP_VEHICLEDEATH)
				DeathWarnZone = WarnMarines (MWRN_WARP|MWRN_ALLIESTOO|MWRN_VEHICLEDEATH,Radius*1.75+48,towho:Self);
			Else
				DeathWarnZone = WarnMarines (MWRN_WARP|MWRN_ALLIESTOO,Radius*1.75+48,towho:Self);
	}
	
	//=====|Marine related functions|=====\\
	//KAI: All the marine shit stays here in the MVP. It'll be reworked when the marines are rewritten.
	//Is the marine on a turret ? Literally just a convoluted way to return if the OnTurret bool is true or false for the marine.
	Bool MarineIsOnTurret (Actor Other)
	{
		If (!Other) Return False;
		
		Name MGMarine = "TurretMarine";
		Let IsOnTurret = ServiceIterator.Find ("SM_SmartMarines").Next();
		
		If (Other.GetClassName() == MGMarine)
			Return True;
		
		If (IsOnTurret.GetInt ("IsOnTurret",ObjectArg:Other))
			Return True;
		
		Return False;
	}
	
	//Spawn a smart marine (Cool and smart), or fall back to spawning ZDoom marines (Cringe and dumb) if unavailable.
	Actor SpawnMarine (Vector3 Position = (0,0,0), Bool SetMaster = False)
	{
		Name CustomMarine = 'SmartMarine';
		Class<Actor> WhatToSpawn;
		Actor Spawnee;
		Bool b;
		
		If (CustomMarinesAvailable())
			WhatToSpawn = CustomMarine;
		//Smart Marines aren't loaded, so spawn shitty ZDoom marines instead.
		Else
			WhatToSpawn = "MarineChaingun";
		
		//[b,Spawnee] = A_SpawnItemEx (WhatToSpawn,Position.X,Position.Y,GetZAt (Position.X,Position.Y),flags:SXF_NOCHECKPOSITION | SetMaster ? SXF_SETMASTER : 0);
		//Position = Vec2Offset (Position.X * Cos (Angle) + Position.Y * Sin (Angle),Position.X * Sin (Angle) - Position.Y * Cos (Angle));
		//Spawnee = Spawn (WhatToSpawn,Vec3Offset (Position.X * Cos(Angle) + Position.Y * Sin (Angle),Position.X * Sin (Angle) - Position.Y * Cos (Angle),(Position.Z == 0 ? GetZAt (Position.X,Position.Y) : Position.Z)));
		Spawnee = Spawn (WhatToSpawn,Vec3OffsetRelative (Self,Position,flags:V3R_ANGLEONLY),ALLOW_REPLACE);
		If (Target != Goal)
			Spawnee.CopyFriendliness (Self,True);
		Else
			Spawnee.CopyFriendliness (Self,False);
		Spawnee.bSummonedMonster = True; //Mark marines as being spawned from another actor.
		Spawnee.Angle = Self.Angle;
		If (SetMaster)
			Spawnee.Master = Self;
		//At least try to make the default ZDoom marines a bit smarter.
		If (WhatToSpawn != CustomMarine)
		{
			Spawnee.Speed = 16;
			Spawnee.bSeeFriendlyMonsters = True;
			Spawnee.FriendlySeeBlocks = 16;
			Spawnee.bAvoidMelee = True;
		}
		
		Return Spawnee;
	}
	
	Enum MVPMarineWarnFlags
	{
		MWRN_ALLIESTOO = 1 << 0, //The warning zone should warn marines friendly to the caller as well.
		MWRN_WARP = 1 << 1, //The warning zone should stick to the actor specified by the ToWho parameter.
		MWRN_PAINONLY = 1 << 2, //The warning zone is just warning the marines of an attack that only causes pain (e.g the Pain Ray).
		MWRN_VEHICLEDEATH = 1 << 3, //Despawn the warning zone if the vehicles DeathFlames array is empty.
	}
	
	//Spawns a warning zone for smart marines that gives them a token, which tells them to run away from the warning zone.
	//Since it is basically a fancy wrapper for giving the "SM_ImInDanger" token, you could make your own actors to also support that token.
	//Flags: The flags that determine the behavior of the warning zone. Info on the flags is above. Default flag is MWRN_WARP.
	//Range: The range of the warning zone (NO WAYU !?1?1?1?!@?@?!/@/3/$3?3??543?), default is 256.
	//ToWho: What actor should the zone be attached to ?
	//Offsets: The offsets which the warning zone uses when warping to the specified actor. Default is no offsets.
	Actor WarnMarines (Int Flags = MWRN_WARP, Double Range = 256, Actor ToWho = Null, Vector3 Offsets = (0,0,0))
	{
		If (!CustomMarinesAvailable()) Return Null;
		Vector3 SpawnPos = ToWho ? Vec3OffsetRelative(ToWho,Offsets) : Self.Pos;
		Actor WarnZone = Spawn ("SmartMarineWarningZone",SpawnPos);
		
		WarnZone.CopyFriendliness (Self,False);
		If (Flags & MWRN_WARP) WarnZone.Master = ToWho;
		If (Flags & MWRN_ALLIESTOO) SmartMarineWarningZone(WarnZone).Flags |= MWRN_ALLIESTOO;
		If (Flags & MWRN_PAINONLY) SmartMarineWarningZone(WarnZone).Flags |= MWRN_PAINONLY; //I had forgot to make the function handle this warning zone flag for two months lmfao.
		If (Flags & MWRN_VEHICLEDEATH) SmartMarineWarningZone(WarnZone).Flags = MWRN_VEHICLEDEATH;
		WarnZone.MaxTargetRange = Range;
		SmartMarineWarningZone(WarnZone).Offset = Offsets;
		
		Return WarnZone; //Return a pointer to the created warning zone.
	}
	
	//Only warn a specific marine, and return if the warning token was successfully given to them.
	Bool WarnSpecificMarine (Actor Marine)
	{
		Name WarningToken = "SM_ImInDanger";
		Inventory Token;
		
		If (!Marine) //No marine to warn.
			Return False;
		
		Token = Marine.GiveInventoryType (WarningToken); //Give the token to the marine.
		If (Token)
			Token.Master = Self;
		
		If (!(Marine.FindInventory (WarningToken)) || !(Marine.CountInv (WarningToken) <= 0)) //The marine didn't get a token.
			Return False;
		
		Return True;
	}
	
	//=====|Vehicle behaviors|=====\\
	//KAI: This stays here in the MVP.
	//Increase an integer value based on the amount of enemies and how powerful they are, to use for AOE attacks.
	//Probably needs a rewrite in the future, besides being a bit basic. The specific checks for the callers' target are also a little sussy.
	//Range: The range around which to check for enemies.
	//AvoidAllies: Deduct points from the score for any allies in the AOE.
	Int AttackByQuantity (Double Range = 256, Bool AvoidAllies = False)
	{
		Actor Mobj;
		Int Chance;
		Bool IsHostile, IsVisible; //Caching
		
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Self,Range);
		
		While (FindEnemies.Next())
		{
			Mobj = FindEnemies.Thing;
			
			If (IsDead (Mobj) || IsInanimateObject (Mobj) && Mobj == Self) Continue;
			
			IsHostile = IsHostile (Mobj); IsVisible = IsVisible (Mobj,False);
			If (AvoidAllies && !IsHostile && IsVisible)
			{
				If (Mobj.bIsMonster) Chance -= 5;
				If (Mobj.Player) Chance -= 25;
				Continue;
			}
			
			If (Mobj != Target && Mobj.Distance3DSquared (Target) <= Range*Range && IsHostile && IsVisible)
			{
				If (Mobj.Health >= 10)
					Chance += 5;
				Else
					Chance += 1;
				
				If (IsPowerful (Mobj))
					Chance += 25;
			}
		}
		
		Return Chance;
	}
	
	//Throws actors away from the caller, the code is mostly copied from BlastActor.
	Void FlingActor (Actor Victim, Double Speed, Bool Harmless, Bool PushImmovables = False)
	{
		Double Ang = AngleTo(Victim);
		Vector2 Move = AngleToVector(Ang, Speed);
		
		Victim.Vel.XY = Move;
		Victim.Vel.Z = 500. / Victim.Mass;
		
		If (Victim.Player)
		{
			// Players handled automatically
		}
		Else If (!Harmless)
		{
			Victim.bBlasted = True;
		}
		
		If (Victim.bTouchy) // Touchy objects die when blasted
		{
			Victim.bArmed = False; // Disarm
			Victim.DamageMobj(Self, Self, Victim.Health, 'Melee', DMG_FORCED|DMG_EXPLOSION);
		}
	}
	
		//=====|Headlight functions|=====\\
		//KAIREMOVE: This can be painlessly deleted now.
		//Turn the vehicles' headlights on.
		Void TurnHeadlightsOn()
		{
			If (LightsOnAlready) Return;
			LightLevel = 64; //Light up the vehicle.
			If (Turret) Turret.LightLevel = 64; //And the turret, if any.
			For (Int I = HeadLights.Size()-1; I >= 0; I--)
			{
				If (Headlights[I])
				{
					Headlights[I].Activate(Self);
					Headlights[I].Active = True;
				}
			}
			If (GetAge() > 1) LightsOnAlready = True; //1 tic delay to allow the lights to spawn in the first place.
		}
		
		//Turn them off.
		Void TurnHeadlightsOff()
		{
			LightLevel = 0;
			If (Turret) Turret.LightLevel = 0;
			For (Int I = HeadLights.Size()-1; I >= 0; I--)
			{
				If (Headlights[I])
				{
					Headlights[I].Deactivate(Self);
					Headlights[I].Active = False;
				}
			}
			LightsOnAlready = False;
		}
		
		//Remove them when the vehicle is killed or removed.
		Void RemoveHeadlights()
		{
			For (Int I = HeadLights.Size()-1; I >= 0; I--)
			{
				If (Headlights[I])
				{
					Headlights[I].Destroy();
					Headlights.Delete(I);
				}
			}
			LightsOnAlready = False;
		}
}
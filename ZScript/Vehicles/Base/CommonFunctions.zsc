//Vehicle functions
Extend Class MVP_BaseVehicle
{
	//=====|Talking in tongues|=====\\
	//What does this do ? I have no fucking idea, Agent_Ash gave it to me to fix how much the truck slows down based on the mass of the object it hit while ramming.
	Clearscope Double LinearMap (Double Val, Double O_Min, Double O_Max, Double N_Min, Double N_Max) 
	{
		Return (Val - O_Min) * (N_Max - N_Min) / (O_Max - O_Min) + N_Min;
	}
	
	//=====|Status checks|=====\\
	
	Bool IsDead (Actor Other)
	{
		If (!Other) Return False;
		
		Return (Other.Player ? Other.Player.PlayerState == PST_DEAD : Other.Health <= 0);
	}
	
	Bool IsIndestructible (Actor Other)
	{
		Return (Other.bInvulnerable || Other.bNoDamage/* || (!Other.bShootable)*/);
	}
	
	Bool IsInanimateObject (Actor Other)
	{
		Return (!Other.bIsMonster && !Other.Player);
	}
	
	Bool IsPatrolling ()
	{
		Return (Goal || Target Is "PatrolPoint");
	}
	
	Bool IsInState (StateLabel CheckFor = "Spawn")
	{
		Return (InStateSequence(CurState,ResolveState (CheckFor)));
	}
	
	Bool CanBeTargeted (Actor Other)
	{
		If (!Other) Return False;
		Return (!Other.bNoTarget && !Other.bNeverTarget && !(Other.Player && Other.Player.Cheats & CF_NOTARGET));
	}
	
	/*Used to check if marines can spawn in the specified position, the radius and height parameters are for vehicles like the truck,
	that- ugh, nevermind, I can't put into words what this does.*/
	Bool ValidPositionAt (Vector2 Offset = (0,0), Double TempRadius = 32, Double TempHeight = 56)
	{
		//Store the previous position and dimensions of the vehicle.
		Vector3 PrevPos = Pos;
		Double PrevRadius = Radius;
		Double PrevHeight = Height;
		
		A_SetSize (TempRadius,TempHeight);
		SetXYZ (Vec3Offset (Offset.X * Cos(Angle) + Offset.Y * Sin (Angle), Offset.X * Sin (Angle) - Offset.Y * Cos (Angle),Pos.Z)); //The same formula used to spawn marines.
		
		Bool Ok = CheckPosition (Pos.XY);
		
		A_SetSize (PrevRadius,PrevHeight);
		SetXYZ (PrevPos);
		
		Return Ok;
	}
	
	//Written by Boondorl.
	Double PitchTo (Actor Other)
	{
		Vector3 Diff = Vec3To(Other);
		Double L = Diff.Length();
		If (L <= 0)
			Return 0;

		Diff /= l;
		Return -ASin(Diff.Z);
	}
	
	//Add a function that determines if the vehicles' target is a VERY powerful enemy.
	Bool IsPowerful (Actor Other)
	{
		Name CustomMarine = 'SmartMarine';
		Name CustomTurretMarine = "TurretMarine";
		Name TurretWeapon = 'SmartMarineMGWeapon';
		
		If (!Other)
			Return False;
		
		//Is the other actor a smart marine or player on a turret ?
		If (CustomMarinesAvailable()
		&& (Other Is CustomMarine && MarineIsOnTurret (Other)
		|| Other Is CustomTurretMarine
		|| Other.Player && Other.Player.ReadyWeapon && Other.Player.ReadyWeapon.GetClassName() == TurretWeapon))
			Return True;
		
		//Does the actor have 2500 health or more, is sufficiently large, or can reflect projectiles ?
		If (Other.SpawnHealth() >= 2500 || (Other.Height >= 80 && Other.Radius >= 72) || Other.bReflective)
			Return True;
		
		Return False;
	}
	
	//=====|Marine related functions|=====\\
	//Can the vehicle spawn Smart Marines ?
	Bool CustomMarinesAvailable()
	{
		Let MarineCheck = SM_MarineChecker (EventHandler.Find("SM_MarineChecker"));
		
		If (!MarineCheck.NoCustomMarines)
			Return True;
		Else
			Return False;
	}
	
	//Spawn a smart marine (Cool and smart), or fall back to spawning ZDoom marines (Cringe and dumb) if unavailable.
	Actor SpawnMarine (Vector2 Position = (0,0), Bool SetMaster = False)
	{
		Name CustomMarine = 'SmartMarine';
		Class<Actor> WhatToSpawn;
		Actor Spawnee;
		Bool b;
		
		If (CustomMarinesAvailable())
			WhatToSpawn = CustomMarine;
		//Smart Marines aren't loaded, so spawn shitty ZDoom marines instead.
		Else
			WhatToSpawn = "MarineChaingun";
		
		//[b,Spawnee] = A_SpawnItemEx (WhatToSpawn,Position.X,Position.Y,GetZAt (Position.X,Position.Y),flags:SXF_NOCHECKPOSITION | SetMaster ? SXF_SETMASTER : 0);
		//Position = Vec2Offset (Position.X * Cos (Angle) + Position.Y * Sin (Angle),Position.X * Sin (Angle) - Position.Y * Cos (Angle));
		Spawnee = Spawn (WhatToSpawn,Vec3Offset (Position.X * Cos(Angle) + Position.Y * Sin (Angle),Position.X * Sin (Angle) - Position.Y * Cos (Angle),GetZAt (Position.X,Position.Y)));
		If (Target != Goal)
			Spawnee.CopyFriendliness (Self,True);
		Else
			Spawnee.CopyFriendliness (Self,False);
		Spawnee.bSummonedMonster = True;
		Spawnee.Angle = Self.Angle;
		If (SetMaster)
			Spawnee.Master = Self;
		
		Return Spawnee;
	}
	
	//Is the marine on a turret ? Literally just a convoluted way to return if the OnTurret bool is true or false for the marine.
	Bool MarineIsOnTurret (Actor Other)
	{
		String MGMarine = "TurretMarine";
		Let IsOnTurret = ServiceIterator.Find ("SM_SmartMarines").Next();
		
		If (Other.GetClassName() == MGMarine)
			Return True;
		
		If (IsOnTurret.GetInt("",ObjectArg:Other))
			Return True;
		
		Return False;
	}
	
	//Spawns a warning zone for smart marines that gives them a token, which tells them to run away from the warning zone.
	Actor WarnMarines (Double Range = 256, Bool AlliesToo = False, Bool StickToTarget = True, Bool PainOnly = False)
	{
		If (!CustomMarinesAvailable()) Return Null;
		Actor WarnZone = Spawn ("SmartMarineWarningZone",Target.Pos);
		
		WarnZone.CopyFriendliness (Self,False);
		WarnZone.MaxTargetRange = Range;
		WarnZone.bHarmFriends = AlliesToo;
		If (StickToTarget)
			WarnZone.Master = Target;
		
		Return WarnZone; //Return a pointer to the created warn zone.
	}
	
	//Only warn a specific marine, and return if the warning token was successfully given to them.
	Bool WarnSpecificMarine (Actor Marine)
	{
		String WarningToken = "SM_ImInDanger";
		Inventory Token;
		
		If (!Marine) //No marine to warn.
			{a_log ("404");Return False;}
		
		Token = Marine.GiveInventoryType (WarningToken); //Give the token to the marine.
		If (Token)
			Token.Master = Self;
		
		If (!(Marine.FindInventory (WarningToken)) || !(Marine.CountInv (WarningToken) <= 0)) //The marine didn't get a token.
			{a_log ("no tokens ?");Return False;}
		a_log ("epic win");
		Return True;
	}
	
	//=====|Vehicle behaviors|=====\\
	//As a friendly vehicle, only follow the player until within a certain distance from them, to prevent the player from being dogpiled by vehicles.
	Void FollowPlayerControl (Double MaxDist = 384)
	{
		If (!PlayerInGame[FriendPlayer])
			Return;
		
		If (bFriendly)
			bDontFollowPlayers = (Distance3DSquared (Players[FriendPlayer].Mo) <= MaxDist*MaxDist);
	}
	
	//Increase an integer value based on the amount of enemies and how powerful they are, to use for AOE attacks.
	Int AttackByQuantity (Double Range = 256, Bool AvoidAllies = False)
	{
		Actor Mobj;
		Int Chance;
		
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Self,Range);
		
		While (FindEnemies.Next())
		{
			Mobj = FindEnemies.Thing;
			
			If (IsDead (Mobj) || Mobj == Self) Continue;
			
			If (AvoidAllies && !IsHostile (Mobj) && IsVisible (Mobj,False))
			{
				If (Mobj.bIsMonster) Chance -= 5;
				If (Mobj.Player) Chance -= 25;
				Continue;
			}
			
			If ((Mobj.bIsMonster || Mobj.Player) && Mobj != Target && Mobj.Distance3DSquared (Target) <= Range*Range && IsHostile (Mobj) && IsVisible (Mobj,False))
			{
				If (Mobj.Health >= 10)
					Chance += 5;
				Else
					Chance += 1;
				
				If (IsPowerful (Mobj))
					Chance += 25;
			}
		}
		
		Return Chance;
	}
	
	//Does exactly what it says, finds the nearest enemy that can be targeted and is visible, and returns a pointer to it.
	Actor FindNearestEnemy (Double Range = 256)
	{
		If (Range <= -1) Return Null; //Return nothing at negative ranges.
		
		Array <Actor> NearbyEnemies;
		Double NearestDistance = INT.MAX;
		
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Self,Range);
		
		While (FindEnemies.Next())
		{
			Actor Mobj = FindEnemies.Thing;
			
			//Skip this actor if it's dead, cannot be targeted, is not a monster nor a player, or is not even an enemy.
			If (!Mobj || IsDead (Mobj) || !CanBeTargeted (Mobj) || !(Mobj.bIsMonster || Mobj.Player) || !IsHostile (Mobj)) Continue;
			
			NearbyEnemies.Push(Mobj); //Add it to the list.
		}
		
		Actor NearestEnemy;
		
		//Now check through the enemies found in range.
		For (Int I = NearbyEnemies.Size()-1; I >= 0; I--)
		{
			//Whittle them down to the enemy that is the closest to the vehicle, and that is visible.
			Double CurrentDistance = Distance3DSquared (NearbyEnemies[I]);
			If (NearestDistance > CurrentDistance && CheckSight (NearbyEnemies[I]))
			{
				NearestDistance = CurrentDistance;
				NearestEnemy = NearbyEnemies[I];
			}
		}
		
		Return NearestEnemy;
	}
	
	//Throws actors away from the caller, the code is mostly copied from BlastActor.
	Void FlingActor (Actor Victim, Double Speed, Bool Harmless, Bool PushImmovables = False)
	{
		Double Ang = AngleTo(Victim);
		Vector2 Move = AngleToVector(Ang, Speed);
		
		Victim.Vel.XY = Move;
		Victim.Vel.Z = 500. / Victim.Mass;
		
		If (Victim.Player)
		{
			// Players handled automatically
		}
		Else If (!Harmless)
		{
			Victim.bBlasted = True;
		}
		
		If (Victim.bTouchy) // Touchy objects die when blasted
		{
			Victim.bArmed = False; // Disarm
			Victim.DamageMobj(Self, Self, Victim.Health, 'Melee', DMG_FORCED|DMG_EXPLOSION);
		}
	}
	
		//=====|Headlight functions|=====\\
		//Turn the vehicles' headlights on.
		Void TurnHeadlightsOn()
		{
			LightLevel = 64; //Light up the vehicle.
			If (Turret) Turret.LightLevel = 64; //And the turret, if any.
			For (Int I = HeadLights.Size()-1; I >= 0; I--)
			{
				If (Headlights[I])
				{
					Headlights[I].Activate(Self);
					Headlights[I].Active = True;
				}
			}
		}
		
		//Turn them off.
		Void TurnHeadlightsOff()
		{
			LightLevel = 0;
			If (Turret) Turret.LightLevel = 0;
			For (Int I = HeadLights.Size()-1; I >= 0; I--)
			{
				If (Headlights[I])
				{
					Headlights[I].Deactivate(Self);
					Headlights[I].Active = False;
				}
			}
		}
		
		//Remove them when the vehicle is killed or removed.
		Void RemoveHeadlights()
		{
			For (Int I = HeadLights.Size()-1; I >= 0; I--)
			{
				If (Headlights[I])
				{
					Headlights[I].Destroy();
					Headlights.Delete(I);
				}
			}
		}
}
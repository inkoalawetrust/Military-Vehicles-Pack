//Vehicle functions
Extend Class MVP_BaseVehicle
{
	//=====|Status checks|=====\\
	
	Bool IsDead (Actor Other)
	{
		If (!Other) Return False;
		
		Return (Other.Health <= 0);
	}
	
	Bool IsPatrolling ()
	{
		Return (Goal || Target Is "PatrolPoint");
	}
	
	Bool IsInState (StateLabel CheckFor = "Spawn")
	{
		Return (InStateSequence(CurState,ResolveState (CheckFor)));
	}
	
	Bool CanBeTargeted (Actor Other)
	{
		If (!Other) Return False;
		Return (!Other.bNoTarget && !Other.bNeverTarget && !(Other.Player && Other.Player.Cheats & CF_NOTARGET));
	}
	
	//Add a function that determines if the vehicles' target is a VERY powerful enemy.
	Bool IsPowerful (Actor Other)
	{
		Name CustomMarine = 'SmartMarine';
		Name CustomTurretMarine = "TurretMarine";
		Name TurretWeapon = 'SmartMarineMGWeapon';
		
		If (!Other)
			Return False;
		
		//Is the other actor a smart marine or player on a turret ?
		If (CustomMarinesAvailable()
		&& (Other Is CustomMarine && MarineIsOnTurret (Other)
		|| Other Is CustomTurretMarine
		|| Other.Player && Other.Player.ReadyWeapon && Other.Player.ReadyWeapon.GetClassName() == TurretWeapon))
			Return True;
		
		//Does the actor have 2500 health or more, is sufficiently large, or can reflect projectiles ?
		If (Other.SpawnHealth() >= 2500 || (Other.Height >= 80 && Other.Radius >= 72) || Other.bReflective)
			Return True;
		
		Return False;
	}
	
	//=====|Marine related functions|=====\\
	//Can the vehicle spawn Smart Marines ?
	Bool CustomMarinesAvailable()
	{
		Let MarineCheck = SM_MarineChecker (EventHandler.Find("SM_MarineChecker"));
		
		If (!MarineCheck.NoCustomMarines)
			Return True;
		Else
			Return False;
	}
	
	//Spawn a smart marine (Cool and smart), or fall back to spawning ZDoom marines (Cringe and dumb) if unavailable.
	Actor SpawnMarine (Vector2 Position = (0,0), Bool SetMaster = False)
	{
		Name CustomMarine = 'SmartMarine';
		Class<Actor> WhatToSpawn;
		Actor Spawnee;
		Bool b;
		
		If (CustomMarinesAvailable())
			WhatToSpawn = CustomMarine;
		//Smart Marines aren't loaded, so spawn shitty ZDoom marines instead.
		Else
			WhatToSpawn = "MarineChaingun";
		
		//[b,Spawnee] = A_SpawnItemEx (WhatToSpawn,Position.X,Position.Y,GetZAt (Position.X,Position.Y),flags:SXF_NOCHECKPOSITION);
		//Position = Vec2Offset (Position.X * Cos (Angle) + Position.Y * Sin (Angle),Position.X * Sin (Angle) - Position.Y * Cos (Angle));
		Spawnee = Spawn (WhatToSpawn,Vec3Offset (Position.X,Position.Y,GetZAt (Position.X,Position.Y)));
		Spawnee.CopyFriendliness (Self,True);
		Spawnee.bSummonedMonster = True;
		Spawnee.Angle = Self.Angle;
		If (SetMaster)
			Spawnee.Master = Self;
		
		Return Spawnee;
	}
	
	//Is the marine on a turret ? Literally just a convoluted way to return if the OnTurret bool is true or false for the marine.
	Bool MarineIsOnTurret (Actor Other)
	{
		Let IsOnTurret = ServiceIterator.Find ("SM_SmartMarines").Next();
		
		If (!IsOnTurret)
			Return False;
		
		If (IsOnTurret.GetInt("",ObjectArg:Other))
			Return True;
		
		Return False;
	}
	
	//Spawns a warning zone for smart marines that gives them a token, which tells them to run away from the warning zone.
	Actor WarnMarines (Double Range = 256, Bool AlliesToo = False, Bool StickToTarget = True, Bool PainOnly = False)
	{
		If (!CustomMarinesAvailable()) Return Null;
		Actor WarnZone = Spawn ("SmartMarineWarningZone",Target.Pos);
		
		WarnZone.CopyFriendliness (Self,False);
		WarnZone.MaxTargetRange = Range;
		WarnZone.bHarmFriends = AlliesToo;
		If (StickToTarget)
			WarnZone.Master = Target;
		
		Return WarnZone;
	}
	
	//=====|Vehicle behaviors|=====\\
	//As a friendly vehicle, only follow the player until within a certain distance from them, to prevent the player from being dogpiled by vehicles.
	Void FollowPlayerControl (Double MaxDist = 284)
	{
		If (!PlayerInGame[FriendPlayer])
			Return;
		
		If (bFriendly)
			bDontFollowPlayers = (Distance3DSquared (Players[FriendPlayer].Mo) <= MaxDist*MaxDist);
	}
	
	//Increase an integer value based on the amount of enemies and how powerful they are, to use for AOE attacks.
	Int AttackByQuantity (Double Range = 256, Bool AvoidAllies = False)
	{
		Actor Mobj;
		Int Chance;
		
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Self,Range);
		
		While (FindEnemies.Next())
		{
			Mobj = FindEnemies.Thing;
			
			If (IsDead (Mobj) || Mobj == Self) Continue;
			
			If (AvoidAllies && !IsHostile (Mobj) && IsVisible (Mobj,False))
			{
				If (Mobj.bIsMonster) Chance -= 5;
				If (Mobj.Player) Chance -= 25;
				Continue;
			}
			
			If ((Mobj.bIsMonster || Mobj.Player) && Mobj != Target && Mobj.Distance3DSquared (Target) <= Range*Range && IsHostile (Mobj) && IsVisible (Mobj,False))
			{
				If (Mobj.Health >= 10)
					Chance += 5;
				Else
					Chance += 1;
				
				If (IsPowerful (Mobj))
					Chance += 25;
			}
		}
		
		Return Chance;
	}
	
	//Does exactly what it says, finds the nearest enemy that can be targeted and is visible, and returns a pointer to it.
	Actor FindNearestEnemy (Double Range = 256)
	{
		Array <Actor> NearbyEnemies;
		Double NearestDistance = INT.MAX;
		
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Self,Range);
		
		While (FindEnemies.Next())
		{
			Actor Mobj = FindEnemies.Thing;
			
			//Skip this actor if it's dead, cannot be targeted, is not a monster nor a player, or is not even an enemy.
			If (!Mobj || IsDead (Mobj) || !CanBeTargeted (Mobj) || !(Mobj.bIsMonster || Mobj.Player) || !IsHostile (Mobj)) Continue;
			
			NearbyEnemies.Push(Mobj); //Add it to the list.
		}
		
		Actor NearestEnemy;
		
		//Now check through the enemies found in range.
		For (Int I = NearbyEnemies.Size()-1; I >= 0; I--)
		{
			//Whittle them down to the enemy that is the closest to the vehicle, and that is visible.
			Double CurrentDistance = Distance3DSquared (NearbyEnemies[I]);
			If (NearestDistance > CurrentDistance && CheckSight (NearbyEnemies[I]))
			{
				NearestDistance = CurrentDistance;
				NearestEnemy = NearbyEnemies[I];
			}
		}
		
		Return NearestEnemy;
	}
	
		//=====|Headlight functions|=====\\
		//Turn the vehicles' headlights on.
		Void TurnHeadlightsOn()
		{
			LightLevel = 64; //Light up the vehicle.
			If (Turret) Turret.LightLevel = 64; //And the turret, if any.
			For (Int I = HeadLights.Size()-1; I >= 0; I--)
			{
				If (Headlights[I])
				{
					Headlights[I].Activate(Self);
					Headlights[I].Active = True;
				}
			}
		}
		
		//Turn them off.
		Void TurnHeadlightsOff()
		{
			LightLevel = 0;
			If (Turret) Turret.LightLevel = 0;
			For (Int I = HeadLights.Size()-1; I >= 0; I--)
			{
				If (Headlights[I])
				{
					Headlights[I].Deactivate(Self);
					Headlights[I].Active = False;
				}
			}
		}
		
		//Remove them when the vehicle is killed or removed.
		Void RemoveHeadlights()
		{
			For (Int I = HeadLights.Size()-1; I >= 0; I--)
			{
				If (Headlights[I])
				{
					Headlights[I].Destroy();
					Headlights.Delete(I);
				}
			}
		}
	
	//Vehicle specific functions
	Void SpawnArmyCarHeadlights ()
	{
		//Initialize headlights
			//Front left headlight
			Headlights.Push(MVP_HeadLight(Spawn("MVP_Headlight",Pos)));
			HeadLights[0].Offset = (64,28,8);
			Headlights[0].Master = Self;
			//Front right headlight
			Headlights.Push(MVP_HeadLight(Spawn("MVP_Headlight",Pos)));
			HeadLights[1].Offset = (64,-28,8);
			Headlights[1].Master = Self;
			
			//Back left headlight
			Headlights.Push(MVP_HeadLight(Spawn("MVP_Headlight",Pos)));
			HeadLights[2].Offset = (40,28,8);
			Headlights[2].Master = Self;
			HeadLights[2].IsBacklight = True;
			HeadLights[2].Args[DynamicLight.LIGHT_GREEN] = HeadLights[2].Args[DynamicLight.LIGHT_BLUE] = 0;
			HeadLights[2].Args[DynamicLight.LIGHT_INTENSITY] = 32;
			HeadLights[2].SpotInnerAngle = 40;
			Headlights[2].SpotOuterAngle = 80;
			//Back right headlight
			Headlights.Push(MVP_HeadLight(Spawn("MVP_Headlight",Pos)));
			HeadLights[3].Offset = (40,-28,8);
			Headlights[3].Master = Self;
			HeadLights[3].IsBacklight = True;
			HeadLights[3].Args[DynamicLight.LIGHT_GREEN] = HeadLights[3].Args[DynamicLight.LIGHT_BLUE] = 0;
			HeadLights[3].Args[DynamicLight.LIGHT_INTENSITY] = 32;
			HeadLights[3].SpotInnerAngle = 40;
			Headlights[3].SpotOuterAngle = 80;
	}
}
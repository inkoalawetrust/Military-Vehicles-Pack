//Vehicle functions
Extend Class MVP_BaseVehicle
{
	//=====|Talking in tongues|=====\\
	//What does this do ? I have no fucking idea, Agent_Ash gave it to me to fix how much the truck slows down based on the mass of the object it hit while ramming.
	Clearscope Double LinearMap (Double Val, Double O_Min, Double O_Max, Double N_Min, Double N_Max) 
	{
		Return (Val - O_Min) * (N_Max - N_Min) / (O_Max - O_Min) + N_Min;
	}
	
	//=====|Status checks|=====\\
	
	Bool IsDead (Actor Other)
	{
		If (!Other) Return False;
		
		Return (Other.Player ? Other.Player.PlayerState == PST_DEAD : Other.Health <= 0);
	}
	
	Bool IsIndestructible (Actor Other)
	{
		Return (Other.bInvulnerable || Other.bNoDamage/* || (!Other.bShootable)*/);
	}
	
	Bool IsInanimateObject (Actor Other)
	{
		Return (!Other.bIsMonster && !Other.Player);
	}
	
	Bool IsPatrolling ()
	{
		Return (Goal || Target Is "PatrolPoint");
	}
	
	Bool IsInState (StateLabel CheckFor = "Spawn")
	{
		Return (InStateSequence(CurState,ResolveState (CheckFor)));
	}
	
	Bool CanBeTargeted (Actor Other)
	{
		If (!Other) Return False;
		Return (!Other.bNoTarget && !Other.bNeverTarget && !(Other.Player && Other.Player.Cheats & CF_NOTARGET));
	}
	
	/*Used to check if marines can spawn in the specified position, the radius and height parameters are for vehicles like the truck,
	that- ugh, nevermind, I can't put into words what this does.*/
	Bool ValidPositionAt (Vector2 Offset = (0,0), Double TempRadius = 32, Double TempHeight = 56)
	{
		//Store the previous position and dimensions of the vehicle.
		Vector3 PrevPos = Pos;
		Double PrevRadius = Radius;
		Double PrevHeight = Height;
		
		A_SetSize (TempRadius,TempHeight);
		SetXYZ (Vec3Offset (Offset.X * Cos(Angle) + Offset.Y * Sin (Angle), Offset.X * Sin (Angle) - Offset.Y * Cos (Angle),Pos.Z)); //The same formula used to spawn marines.
		
		Bool Ok = CheckPosition (Pos.XY);
		
		A_SetSize (PrevRadius,PrevHeight);
		SetXYZ (PrevPos);
		
		Return Ok;
	}
	
	//Written by Boondorl.
	Double PitchTo (Actor Other)
	{
		Vector3 Diff = Vec3To(Other);
		Double L = Diff.Length();
		If (L <= 0)
			Return 0;

		Diff /= l;
		Return -ASin(Diff.Z);
	}
	
	//Add a function that determines if the vehicles' target is a VERY powerful enemy.
	Bool IsPowerful (Actor Other)
	{
		Name CustomMarine = 'SmartMarine';
		Name CustomTurretMarine = "TurretMarine";
		Name TurretWeapon = 'SmartMarineMGWeapon';
		
		If (!Other)
			Return False;
		
		//Is the other actor a smart marine or player on a turret ?
		If (CustomMarinesAvailable()
		&& (Other Is CustomMarine && MarineIsOnTurret (Other)
		|| Other Is CustomTurretMarine
		|| Other.Player && Other.Player.ReadyWeapon && Other.Player.ReadyWeapon.GetClassName() == TurretWeapon))
			Return True;
		
		//Does the actor have 2500 health or more, is sufficiently large, or can reflect projectiles ?
		If (Other.SpawnHealth() >= 2500 || (Other.Height >= 80 && Other.Radius >= 72) || Other.bReflective)
			Return True;
		
		Return False;
	}
	
	//=====|Marine related functions|=====\\
	//Can the vehicle spawn Smart Marines ?
	Bool CustomMarinesAvailable()
	{
		Let MarineCheck = SM_MarineChecker (EventHandler.Find("SM_MarineChecker"));
		
		If (!MarineCheck.NoCustomMarines)
			Return True;
		Else
			Return False;
	}
	
	//Spawn a smart marine (Cool and smart), or fall back to spawning ZDoom marines (Cringe and dumb) if unavailable.
	Actor SpawnMarine (Vector2 Position = (0,0), Bool SetMaster = False)
	{
		Name CustomMarine = 'SmartMarine';
		Class<Actor> WhatToSpawn;
		Actor Spawnee;
		Bool b;
		
		If (CustomMarinesAvailable())
			WhatToSpawn = CustomMarine;
		//Smart Marines aren't loaded, so spawn shitty ZDoom marines instead.
		Else
			WhatToSpawn = "MarineChaingun";
		
		//[b,Spawnee] = A_SpawnItemEx (WhatToSpawn,Position.X,Position.Y,GetZAt (Position.X,Position.Y),flags:SXF_NOCHECKPOSITION | SetMaster ? SXF_SETMASTER : 0);
		//Position = Vec2Offset (Position.X * Cos (Angle) + Position.Y * Sin (Angle),Position.X * Sin (Angle) - Position.Y * Cos (Angle));
		Spawnee = Spawn (WhatToSpawn,Vec3Offset (Position.X * Cos(Angle) + Position.Y * Sin (Angle),Position.X * Sin (Angle) - Position.Y * Cos (Angle),GetZAt (Position.X,Position.Y)));
		If (Target != Goal)
			Spawnee.CopyFriendliness (Self,True);
		Else
			Spawnee.CopyFriendliness (Self,False);
		Spawnee.bSummonedMonster = True;
		Spawnee.Angle = Self.Angle;
		If (SetMaster)
			Spawnee.Master = Self;
		
		Return Spawnee;
	}
	
	//Is the marine on a turret ? Literally just a convoluted way to return if the OnTurret bool is true or false for the marine.
	Bool MarineIsOnTurret (Actor Other)
	{
		If (!Other) Return False;
		
		String MGMarine = "TurretMarine";
		Let IsOnTurret = ServiceIterator.Find ("SM_SmartMarines").Next();
		
		If (Other.GetClassName() == MGMarine)
			Return True;
		
		If (IsOnTurret.GetInt ("IsOnTurret",ObjectArg:Other))
			Return True;
		
		Return False;
	}
	
	//Spawns a warning zone for smart marines that gives them a token, which tells them to run away from the warning zone.
	Actor WarnMarines (Double Range = 256, Bool AlliesToo = False, Bool StickToTarget = True, Bool PainOnly = False)
	{
		If (!CustomMarinesAvailable()) Return Null;
		Actor WarnZone = Spawn ("SmartMarineWarningZone",Target.Pos);
		
		WarnZone.CopyFriendliness (Self,False);
		WarnZone.MaxTargetRange = Range;
		WarnZone.bHarmFriends = AlliesToo;
		If (StickToTarget)
			WarnZone.Master = Target;
		
		Return WarnZone; //Return a pointer to the created warn zone.
	}
	
	//Only warn a specific marine, and return if the warning token was successfully given to them.
	Bool WarnSpecificMarine (Actor Marine)
	{
		String WarningToken = "SM_ImInDanger";
		Inventory Token;
		
		If (!Marine) //No marine to warn.
			Return False;
		
		Token = Marine.GiveInventoryType (WarningToken); //Give the token to the marine.
		If (Token)
			Token.Master = Self;
		
		If (!(Marine.FindInventory (WarningToken)) || !(Marine.CountInv (WarningToken) <= 0)) //The marine didn't get a token.
			Return False;
		
		Return True;
	}
	
	//=====|Vehicle behaviors|=====\\
	//Generic chase function shared by all vehicles.
	Void MVP_Chase (Bool AttackWhenScared = False, Double FollowDist = 384, Bool NoRandomTurn = False, Bool TurretMode = False)
	{
		//Vehicles get scared if they have a living, visible target, and are either defenseless or the target is too powerful.
		If (!bNoFear)
		{
			If (Target && !CanAttack() || Target && IsPowerful (Target))
				If (!IsDead (Target) && IsVisible(Target, True))
				{
					FearTimer = Random (2,64);
					bFrightened = AlreadyRetreating = True;
				}
				Else
					bFrightened = False;
			Else
				bFrightened = False;
			
			If (FearTimer)
			{
				FearTimer--;
				bFrightened = AlreadyRetreating = True;
			}
			
			If (AttackWhenScared && bFrightened)
				MinMissileChance = bMissileMore = 1;
		}
		
		If (!TurretMode) //Turrets don't need to do anything involving moving.
		{
			FollowPlayerControl (FollowDist);
			
			//Vehicles try to stay away from enemies that are too close.
			Actor OldTarget;
			NearestEnemy = FindNearestEnemy (User_RetreatDistance);
			If (!NearestEnemy || IsPatrolling())
				A_Chase (Null,Null,CHF_DONTIDLE | (NoRandomTurn ? CHF_NORANDOMTURN : 0));
			Else If (NearestEnemy && !AlreadyRetreating)
			{
				OldTarget = Target;
				Target = NearestEnemy;
				bFrightened = True;
				FearTimer = Random (2,48);
				A_Chase (Null,Null,CHF_DONTIDLE | (NoRandomTurn ? CHF_NORANDOMTURN : 0));
				Target = OldTarget;
			}
			Else
				A_Chase (Null,Null,CHF_DONTIDLE | (NoRandomTurn ? CHF_NORANDOMTURN : 0));
		}
		
		If (ShouldAttack()) //Run the unique attack decision code of the vehicle.
		{
			ChaseTimer = 0;
			Return; //End the function if the vehicle should attack.
		}
		
		//They also eventually stop chasing their target after it's out of sight for long enough.
		If (User_ChaseTime > 0)
		{
			If (ChaseTimer >= User_ChaseTime)
			{
				A_ClearTarget();
				ChaseTimer = 0;
				//Vehicles ordered to stay also go back to standing still once the timer runs out.
				If (CurrentOrder == ORDER_STAY)
				{a_log ("times up, time to go back to standing around");
					SetStateLabel ("Spawn");
					Return;
				}
			}
			
			If (!IsPatrolling())
			{
				If (!Target || Target && !CheckSight (Target,SF_SEEPASTBLOCKEVERYTHING))
					ChaseTimer++;
				//Target is visible again, reset the timer.
				Else
					ChaseTimer = 0;
			}
		}
	}
	
	//This stupid copy and paste has to literally only exist because P_HitFriend breaks friendly turrets with allies below or above them.
	//The function is more or less the same as it's native counterpart, give or take the syntax and code comments, and it being slower by being non-native.
	//Maybe I can add more custom code here, like lowering the distance to make vehicles even more likely to attack, so that I can further justify this thing existing.
	Bool MVP_CheckMissileRange (Actor Other)
	{
		Double Dist;
		
		If (CurSector.Flags & Sector.SECF_NOATTACK) Return False;
		
		If (!CheckSight (Other, SF_SEEPASTBLOCKEVERYTHING)) Return False;
		
		If (bJustHit)
		{
			bJustHit = False;
			
			If (!bFriendly) Return True;
			If (IsDead(Other)) Return False;
			If (!IsFriend(Other)) Return True;
			
			If (Other.Player)
				Return (Random2[PR_Defect]() > 128);
			Else
				Return !(Other.bJustHit && Random2[PR_Defect]() > 128);
		}
		
		If (ReactionTime) Return False;
		
		If (IsFriend (Other)) Return False;
		
		//If (bFriendly && HitFriend ()) Return False; //This line right here, this is the only reason this stupid duplicate of P_CheckMissileRange has to exist.
		
		Dist = Distance2D (Other) - 64;
		
		If (!MeleeState)
			Dist -= 128;
		
		If (MaxTargetRange > 0 && Dist > MaxTargetRange) Return False;
		
		If (MeleeState && Dist < MeleeThreshold) Return False;
		
		If (bMissileMore) Dist *= 0.5;
		If (bMissileEvenMore) Dist *= 0.125;
		
		Int MMC = Int(MinMissileChance * G_SkillPropertyFloat(SKILLP_Aggressiveness));
		Return Random2[PR_CheckMissileRange]() >= Min(Int(Dist), MMC);
	}
	
	//Used to make vehicles able to run over and grind corpses like crushers. Still WIP so finish it when I wake up.
	Void MVP_CrushCorpses (Double MaxHeight = 48, Double MaxRadius = 64)
	{
		BlockThingsIterator Crusher = BlockThingsIterator.Create (Self);
		Actor Mobj;
		
		While (Crusher.Next())
		{
			Mobj = Crusher.Thing;
			If (!Mobj) Continue; //No actor to crush.
			If (!IsDead (Mobj)) Continue; //Actor isn't dead already.
			If (Mobj.Radius > MaxRadius || Mobj.Height > MaxHeight) Continue; //Actor is too big.
			If (Distance3DSquared (Mobj) > ((Radius*2)*1.75)*((Radius*2)*1.75)) Continue;
			
			Mobj.Grind (False); //Crush corpse, but not items.
		}
	}
	
	//As a friendly vehicle, only follow the player until within a certain distance from them, to prevent the player from being dogpiled by vehicles.
	Void FollowPlayerControl (Double MaxDist = 384)
	{
		If (!PlayerInGame[FriendPlayer] || CurrentOrder == ORDER_WANDER)
			Return;
		
		If (bFriendly)
			bDontFollowPlayers = (Distance3DSquared (Players[FriendPlayer].Mo) <= MaxDist*MaxDist);
	}
	
	//Increase an integer value based on the amount of enemies and how powerful they are, to use for AOE attacks.
	Int AttackByQuantity (Double Range = 256, Bool AvoidAllies = False)
	{
		Actor Mobj;
		Int Chance;
		
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Self,Range);
		
		While (FindEnemies.Next())
		{
			Mobj = FindEnemies.Thing;
			
			If (IsDead (Mobj) || Mobj == Self) Continue;
			
			If (AvoidAllies && !IsHostile (Mobj) && IsVisible (Mobj,False))
			{
				If (Mobj.bIsMonster) Chance -= 5;
				If (Mobj.Player) Chance -= 25;
				Continue;
			}
			
			If ((Mobj.bIsMonster || Mobj.Player) && Mobj != Target && Mobj.Distance3DSquared (Target) <= Range*Range && IsHostile (Mobj) && IsVisible (Mobj,False))
			{
				If (Mobj.Health >= 10)
					Chance += 5;
				Else
					Chance += 1;
				
				If (IsPowerful (Mobj))
					Chance += 25;
			}
		}
		
		Return Chance;
	}
	
	//Does exactly what it says, finds the nearest enemy that can be targeted and is visible, and returns a pointer to it.
	Actor FindNearestEnemy (Double Range = 256)
	{
		If (Range <= -1) Return Null; //Return nothing at negative ranges.
		
		Array <Actor> NearbyEnemies;
		Double NearestDistance = INT.MAX;
		
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Self,Range);
		
		While (FindEnemies.Next())
		{
			Actor Mobj = FindEnemies.Thing;
			
			//Skip this actor if it's dead, cannot be targeted, is not a monster nor a player, or is not even an enemy.
			If (!Mobj || IsDead (Mobj) || !CanBeTargeted (Mobj) || !(Mobj.bIsMonster || Mobj.Player) || !IsHostile (Mobj)) Continue;
			
			NearbyEnemies.Push(Mobj); //Add it to the list.
		}
		
		Actor NearestEnemy;
		
		//Now check through the enemies found in range.
		For (Int I = NearbyEnemies.Size()-1; I >= 0; I--)
		{
			//Whittle them down to the enemy that is the closest to the vehicle, and that is visible.
			Double CurrentDistance = Distance3DSquared (NearbyEnemies[I]);
			If (NearestDistance > CurrentDistance && CheckSight (NearbyEnemies[I]))
			{
				NearestDistance = CurrentDistance;
				NearestEnemy = NearbyEnemies[I];
			}
		}
		
		Return NearestEnemy;
	}
	
	//Throws actors away from the caller, the code is mostly copied from BlastActor.
	Void FlingActor (Actor Victim, Double Speed, Bool Harmless, Bool PushImmovables = False)
	{
		Double Ang = AngleTo(Victim);
		Vector2 Move = AngleToVector(Ang, Speed);
		
		Victim.Vel.XY = Move;
		Victim.Vel.Z = 500. / Victim.Mass;
		
		If (Victim.Player)
		{
			// Players handled automatically
		}
		Else If (!Harmless)
		{
			Victim.bBlasted = True;
		}
		
		If (Victim.bTouchy) // Touchy objects die when blasted
		{
			Victim.bArmed = False; // Disarm
			Victim.DamageMobj(Self, Self, Victim.Health, 'Melee', DMG_FORCED|DMG_EXPLOSION);
		}
	}
	
		//=====|Headlight functions|=====\\
		//Turn the vehicles' headlights on.
		Void TurnHeadlightsOn()
		{
			LightLevel = 64; //Light up the vehicle.
			If (Turret) Turret.LightLevel = 64; //And the turret, if any.
			For (Int I = HeadLights.Size()-1; I >= 0; I--)
			{
				If (Headlights[I])
				{
					Headlights[I].Activate(Self);
					Headlights[I].Active = True;
				}
			}
		}
		
		//Turn them off.
		Void TurnHeadlightsOff()
		{
			LightLevel = 0;
			If (Turret) Turret.LightLevel = 0;
			For (Int I = HeadLights.Size()-1; I >= 0; I--)
			{
				If (Headlights[I])
				{
					Headlights[I].Deactivate(Self);
					Headlights[I].Active = False;
				}
			}
		}
		
		//Remove them when the vehicle is killed or removed.
		Void RemoveHeadlights()
		{
			For (Int I = HeadLights.Size()-1; I >= 0; I--)
			{
				If (Headlights[I])
				{
					Headlights[I].Destroy();
					Headlights.Delete(I);
				}
			}
		}
}
Extend Class MVP_BaseVehicle
{
	Mixin MVP_SharedFunctions;
}

Extend Class MVP_BaseTurret
{
	Mixin MVP_SharedFunctions;
}

Extend Class MVP_BaseProp
{
	Mixin MVP_SharedFunctions;
}

Extend Class MVP_BaseTurretProp
{
	Mixin MVP_SharedFunctions;
}

Mixin Class MVP_UniversalFunctions
{
	Enum LiquidTypes
	{
		LIQUID_NONE = 0,
		LIQUID_WATER = 1,
		LIQUID_NUKAGE = 2,
		LIQUID_BLOOD = 3,
		LIQUID_LAVA = 4,
		LIQUID_SLIME = 5
	};
	
	Int CheckLiquid (TextureID Texture)
	{
		/*===============================================================
		This class stores the names of the different textures used for each type of liquid.
		These lists can be expanded as seen fit for your project, in case it has additional custom water/nukage/blood/lava/slime textures.
		The lists already contain some names of liquid flats that don't exist in the vanilla game, for built-in mod compatibility.
		Such as by having waterfall textures that don't exist like WFALL# and NFALL#.
		===============================================================*/
		Static Const String WaterTextures[] = {"FWATER1", "FWATER2", "FWATER3", "FWATER4", "WFALL1", "WFALL2", "WFALL3", "WFALL4"};
		Static Const String NukageTextures[] = {"NUKAGE1", "NUKAGE2", "NUKAGE3", "NFALL1", "NFALL2", "NFALL3", "NFALL4"};
		Static Const String BloodTextures[] = {"BLOOD1", "BLOOD2", "BLOOD3", "BFALL1", "BFALL2", "BFALL3", "BFALL4"};
		Static Const String LavaTextures[] = {"LAVA1","LAVA2", "LAVA3", "LAVA4", "DBRAIN1", "DBRAIN2", "DBRAIN3", "DBRAIN4", "LFALL1", "LFALL2", "LFALL3", "LFALL4"};
		Static Const String SlimeTextures[] = {"SLIME01","SLIME02", "SLIME03", "SLIME04", "SLIME05","SLIME06", "SLIME07", "SLIME08", "SFALL1", "SFALL2", "SFALL3", "SFALL4"};
		
		For (Int I = 0; I < WaterTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (WaterTextures[I]) == Texture)
				Return LIQUID_WATER;
		For (Int I = 0; I < NukageTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (NukageTextures[I]) == Texture)
				Return LIQUID_NUKAGE;
		For (Int I = 0; I < BloodTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (BloodTextures[I]) == Texture)
				Return LIQUID_BLOOD;
		For (Int I = 0; I < LavaTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (LavaTextures[I]) == Texture)
				Return LIQUID_LAVA;
		For (Int I = 0; I < SlimeTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (SlimeTextures[I]) == Texture)
				Return LIQUID_SLIME;
		
		Return LIQUID_NONE;
	}
}

Mixin Class MVP_SharedFunctions
{
	String User_DefaultOrder; //The default order the vehicle follows upon spawning.
	//=====|Virtual functions|=====\\
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		If (!bFriendly) Species = 'MilitaryHostile';
		
		If (!User_DefaultOrder || User_DefaultOrder ~== "")
		{
			//This tries to pick a random visible player for the vehicle to follow, if no friendly players are in sight, the vehicle will wander instead.
			Array <PlayerPawn> VisibleFriends;
			//Find all visible players friendly to you.
			For (Int I = 0; I < MAXPLAYERS; I++)
			{
				If (!PlayerInGame[I]) Continue;
				
				If (IsFriend (Players[I].Mo) && CheckSight (Players[I].Mo, SF_IGNOREVISIBILITY|SF_IGNOREWATERBOUNDARY))
					VisibleFriends.Push (Players[I].Mo);
			}
			
			//Found at least one visible friendly player to follow.
			If (VisibleFriends.Size() - 1 >= 0)
			{
				SetFriendPlayer (VisibleFriends[Random (0, VisibleFriends.Size() - 1)].Player); //Randomly pick a visible friend to follow.
				CurrentOrder = ORDER_FOLLOW;
			}
			//No friendplayer, or they are out of sight
			Else If (!FriendPlayer || FriendPlayer && !CheckSight (Players[FriendPlayer].Mo, SF_IGNOREVISIBILITY|SF_IGNOREWATERBOUNDARY))
			{
				CurrentOrder = ORDER_WANDER;
				bDontFollowPlayers = True;
			}
		}
		Else If (User_DefaultOrder ~== "Follow")
		{
			CurrentOrder = ORDER_FOLLOW;
		}
		Else If (User_DefaultOrder ~== "Wander")
		{
			CurrentOrder = ORDER_WANDER;
			bDontFollowPlayers = True;
		}
		Else If (User_DefaultOrder ~== "Stay" || User_DefaultOrder ~== "Stand")
		{
			CurrentOrder = ORDER_STAY;
		}
	}
	
	Override Bool IsActorHostile (Actor Other)
	{
		Return (IsHostile (Other) || IsTargetingAllies (Self, Other));
	}
	
	Bool CustomMarinesAvailable()
	{
		Let MarineCheck = SM_MarineChecker (EventHandler.Find("SM_MarineChecker"));
		
		If (!MarineCheck.NoCustomMarines)
			Return True;
		Else
			Return False;
	}
	
	//=====|Marine related functions|=====\\
	//Is the marine on a turret ? Literally just a convoluted way to return if the OnTurret bool is true or false for the marine.
	Bool MarineIsOnTurret (Actor Other)
	{
		If (!Other) Return False;
		
		Name MGMarine = "TurretMarine";
		Let IsOnTurret = ServiceIterator.Find ("SM_SmartMarines").Next();
		
		If (Other.GetClassName() == MGMarine)
			Return True;
		
		If (IsOnTurret.GetInt ("IsOnTurret",ObjectArg:Other))
			Return True;
		
		Return False;
	}
	
	//Spawn a smart marine (Cool and smart), or fall back to spawning ZDoom marines (Cringe and dumb) if unavailable.
	Actor SpawnMarine (Vector3 Position = (0,0,0), Bool SetMaster = False)
	{
		Name CustomMarine = 'SmartMarine';
		Class<Actor> WhatToSpawn;
		Actor Spawnee;
		Bool b;
		
		If (CustomMarinesAvailable())
			WhatToSpawn = CustomMarine;
		//Smart Marines aren't loaded, so spawn shitty ZDoom marines instead.
		Else
			WhatToSpawn = "MarineChaingun";
		
		//[b,Spawnee] = A_SpawnItemEx (WhatToSpawn,Position.X,Position.Y,GetZAt (Position.X,Position.Y),flags:SXF_NOCHECKPOSITION | SetMaster ? SXF_SETMASTER : 0);
		//Position = Vec2Offset (Position.X * Cos (Angle) + Position.Y * Sin (Angle),Position.X * Sin (Angle) - Position.Y * Cos (Angle));
		//Spawnee = Spawn (WhatToSpawn,Vec3Offset (Position.X * Cos(Angle) + Position.Y * Sin (Angle),Position.X * Sin (Angle) - Position.Y * Cos (Angle),(Position.Z == 0 ? GetZAt (Position.X,Position.Y) : Position.Z)));
		Spawnee = Spawn (WhatToSpawn,KAI_Math.Vec3OffsetRelative (Self,Position,flags:KAI_Math.V3R_ANGLEONLY),ALLOW_REPLACE);
		If (Target != Goal)
			Spawnee.CopyFriendliness (Self,True);
		Else
			Spawnee.CopyFriendliness (Self,False);
		Spawnee.bSummonedMonster = True; //Mark marines as being spawned from another actor.
		Spawnee.Angle = Self.Angle;
		If (SetMaster)
			Spawnee.Master = Self;
		//At least try to make the default ZDoom marines a bit smarter.
		If (WhatToSpawn != CustomMarine)
		{
			Spawnee.Speed = 16;
			Spawnee.bSeeFriendlyMonsters = True;
			Spawnee.FriendlySeeBlocks = 16;
			Spawnee.bAvoidMelee = True;
		}
		
		Return Spawnee;
	}
	
	Enum KAIMarineWarnFlags
	{
		MWRN_ALLIESTOO = 1 << 0, //The warning zone should warn marines friendly to the caller as well.
		MWRN_WARP = 1 << 1, //The warning zone should stick to the actor specified by the ToWho parameter.
		MWRN_PAINONLY = 1 << 2, //The warning zone is just warning the marines of an attack that only causes pain (e.g the Pain Ray).
		MWRN_VEHICLEDEATH = 1 << 3, //Despawn the warning zone if the vehicles DeathFlames array is empty.
	}
	
	//Spawns a warning zone for smart marines that gives them a token, which tells them to run away from the warning zone.
	//Since it is basically a fancy wrapper for giving the "SM_ImInDanger" token, you could make your own actors to also support that token.
	//Flags: The flags that determine the behavior of the warning zone. Info on the flags is above. Default flag is MWRN_WARP.
	//Range: The range of the warning zone (NO WAYU !?1?1?1?!@?@?!/@/3/$3?3??543?), default is 256.
	//ToWho: What actor should the zone be attached to ?
	//Offsets: The offsets which the warning zone uses when warping to the specified actor. Default is no offsets.
	Actor WarnMarines (Int Flags = MWRN_WARP, Double Range = 256, Actor ToWho = Null, Vector3 Offsets = (0,0,0))
	{
		If (!CustomMarinesAvailable()) Return Null;
		Vector3 SpawnPos = ToWho ? KAI_Math.Vec3OffsetRelative(ToWho,Offsets) : Self.Pos;
		Actor WarnZone = Spawn ("SmartMarineWarningZone",SpawnPos);
		
		WarnZone.CopyFriendliness (Self,False);
		If (Flags & MWRN_WARP) WarnZone.Master = ToWho;
		If (Flags & MWRN_ALLIESTOO) SmartMarineWarningZone(WarnZone).Flags |= MWRN_ALLIESTOO;
		If (Flags & MWRN_PAINONLY) SmartMarineWarningZone(WarnZone).Flags |= MWRN_PAINONLY; //I had forgot to make the function handle this warning zone flag for two months lmfao.
		If (Flags & MWRN_VEHICLEDEATH) SmartMarineWarningZone(WarnZone).Flags = MWRN_VEHICLEDEATH;
		WarnZone.MaxTargetRange = Range;
		SmartMarineWarningZone(WarnZone).Offset = Offsets;
		
		Return WarnZone; //Return a pointer to the created warning zone.
	}
	
	//Only warn a specific marine, and return if the warning token was successfully given to them.
	Bool WarnSpecificMarine (Actor Marine)
	{
		Name WarningToken = "SM_ImInDanger";
		Inventory Token;
		
		If (!Marine) //No marine to warn.
			Return False;
		
		Token = Marine.GiveInventoryType (WarningToken); //Give the token to the marine.
		If (Token)
			Token.Master = Self;
		
		If (!(Marine.FindInventory (WarningToken)) || !(Marine.CountInv (WarningToken) <= 0)) //The marine didn't get a token.
			Return False;
		
		Return True;
	}
	
	//Add a function that determines if the vehicles' target is a VERY powerful enemy. //10/4/2023 update: How about we don't ?
	Bool IsPowerful (Actor Other)
	{
		Name CustomMarine = 'SmartMarine';
		Name CustomTurretMarine = "TurretMarine";
		Name TurretWeapon = 'SmartMarineMGWeapon';
		
		If (!Other)
			Return False;
		
		//Is the other actor a smart marine or player on a turret ?
		If (CustomMarinesAvailable() && (Other Is CustomMarine && MarineIsOnTurret (Other)
		|| Other Is CustomTurretMarine
		|| Other.Player && Other.Player.ReadyWeapon && Other.Player.ReadyWeapon.GetClassName() == TurretWeapon))
			Return True;
		
		//Does the actor have 2500 health or more, is sufficiently large, or can reflect projectiles ?
		If ((Other.SpawnHealth() >= 2500 || Other.Health >= 2500) || (Other.Height >= 80 && Other.Radius >= 72) || Other.bReflective)
			Return True;
		
		Return False;
	}
	
	Enum KAIChaseFlags
	{
		KAIC_ATTACKWHENSCARED = 1 << 0, //The vehicle will still be very likely to attack when scared of an enemy.
		KAIC_NORANDOMTURN = 	1 << 1, //Turns on CHF_NORANDOMTURN on the A_Chase calls. TODO: Remove this too. Just use the A_Chase flags so they are passed to KAI_MoveTowards !
		KAIC_NOCHASE = 			1 << 2, //Don't run any code related to the vehicle moving. Useful for vehicle turrets turrets. TODO: Probably replace this with the CHF_DONTMOVE A_Chase flag.
		KAIC_CORPSESEEKER = 	1 << 3,	//The vehicle will actively go after corpses to crush them if it has nothing else to do. TODO: Move this behavior to the MVP and remove this flag.
		KAIC_NOTURRETRETARGET =	1 << 4, //The vehicle will never target the hull of a vehicle instead of its' turret. Even if doing so would be better.
		//TODO: Add a PLAYERSASTHREATS flag. That optionally allows to consider the threat level of players with god or buddha mode.
	}
	
	//The standard land vehicle chase function.
	//WaitState: The state the vehicle should wait in if it stopped at a delayed patrol point. No state means it just calls SetState.
	//Flags: The flags to use. Look above for a list.
	//ChaseFlags: The A_Chase flags to use. Supports the same flags' KAI_MoveTowards does.
	//TurnRadius: How wide the turns the vehicle takes are, the smaller the number the bigger the turn. Default is 10 degrees per step.
	//FollowDist: The minimum distance the vehicle must have from its' friend player (If friendly) before it stops following them. To prevent dogpiling.
	//RetreatDist: The amount of distance the vehicle generally keeps from enemies. Quadrupled for actors whose threat level is above the ThreatLevelThreshold property.
	Void KAI_LandVehicleChase (StateLabel WaitState = Null, Int Flags = 0, Int ChaseFlags = 0, Double TurnRadius = 10, Double FollowDist = 384, Double RetreatDist = 768)
	{
		Bool MovedAlready; //If one of the KAI_MoveTowards/Away calls was made. Don't call the rest.
		Double MajorThreatRange = (RetreatDist*4)*(RetreatDist*4);
		//Temporarily store the aggro multiplier that is changed by the fear code. Then reset it after ShouldAttack() finishes.
		Double OldAggro = AggressionMultiplier;
		
		//ZScript exports of different segments of GZDooms' native AI code. This is the stuff not needed for movement.
		KAI_Chase_PreChecks(ChaseFlags);
		KAI_Chase_FriendsAttackPlayerEnemies(ChaseFlags); //This and Chase_Retarget are handled here, so the fear checks below work properly.
		KAI_Chase_Retarget(ChaseFlags);
		KAI_Chase_HandleActiveSound(ChaseFlags);
		
		//Handle making the vehicle run away from its' target if it's a major threat. Or it's powerless.
		If (!bNoFear && Target && !(Goal && bChaseGoal))
		{
			If (!(Flags & KAIC_NOCHASE) && !(ChaseFlags & CHF_DONTMOVE))
			{
				//If you can't attack, run. Also run if the other actor is frightening or you're frightened.
				If (!CanAttack() || bFrightened || IsFrightening (Target) ||
				//If the targets' threat level is over the threshold, and it's visible and nearby, GTFO.
				ThreatLevelThreshold != THREAT_ASSESS && AssessThreatLevel(Target, False) >= ThreatLevelThreshold && (Distance3DSquared(Target) < MajorThreatRange && CheckSight (Target)))
				{a_log ("oh god oh fuck");
					KAI_MoveAway (Target,runrad:256,detourfactor:0.5,anglelimit:TurnRadius,chaseflags:ChaseFlags,flags:KMT_CHASEGOAL);
					MovedAlready = True;
				}
			}
			
			If (Flags & KAIC_ATTACKWHENSCARED)
				AggressionMultiplier *= 0.5;
		}
		
		FollowPlayerControl (FollowDist); //Handle turning on bDontFollowPlayers if you are too close to your friendplayer.
		
		//If you can move and haven't done so already.
		If (!(Flags & KAIC_NOCHASE) && !(ChaseFlags & CHF_DONTMOVE) && !MovedAlready)
		{
			If (!(IsPatrolling(Self) && bChaseGoal)) NearestEnemy = FindNearestEnemy (RetreatDist);
			//If you aren't patrolling and not allowed off your route, and there is an enemy nearby.
			If (NearestEnemy)
			{a_log ("the danger zone");
				KAI_MoveAway (NearestEnemy,runrad:256,detourfactor:0.5,anglelimit:TurnRadius,chaseflags:ChaseFlags); //Keep your distance.
				MovedAlready = True;
			}
			//If your turrets' target is too high up for it to reach.
			Else If (Turret && Turret.Target && Turret.ElevationState == Turret.ELEVATION_TOOHIGH)
			{a_log ("moving back so my turret can fire");
				KAI_MoveAway (Turret.Target,runrad:256,detourfactor:0.5,anglelimit:TurnRadius,chaseflags:ChaseFlags); //Back off to allow your turret to shoot.
				MovedAlready = True;
			}
			//TODO: Move this to the OnWander virtual I'm adding later.
			/*Else If (Flags & KAIC_CORPSESEEKER && !Target && !IsPatrolling (Self) && CurrentOrder == ORDER_WANDER)
			{
				//Don't have a corpse to crush already.
				If (!CorpseTarget)
				{
					If (CorpseTarget = FindNearestCorpse();)
						KAI_MoveTowards (CorpseTarget.Pos);
				}
				//There is an available corpse to head to and crush.
				Else
					KAI_MoveTowards (CorpseTarget.Pos);
			}*/
			//If none of the other conditions are true. Run the standard A_Chase code (Minus movement), and KAI_MoveTowards.
			Else
			{
				Bool B;
				//A_Chase (Null,Null,CHF_DONTMOVE|CHF_DONTTURN|ChaseFlags); //This breaks the custom movement despite the self-explanatory flags. Okay GZDoom.
				KAI_Chase_HandleStrafing (Target,ChaseFlags); //No idea why the fuck you'd want a ground vehicle to do this. But here you go.
				[B,MovedAlready] = KAI_Chase_PatrolHandling(WaitState, 0.2, anglelimit:TurnRadius, chaseflags:ChaseFlags);
				//Finding a new target should be handled by the above A_Chase call, however if no new target was found. Call OnWander().
				//If (!Target && !(ChaseFlags & CHF_DONTIDLE))
				//	OnWander();
				
				//Finally, if you do have a target, DO move towards it, but with KAI_MoveTowards instead of the shitty native movement code.
				If (Target && !MovedAlready)
					KAI_MoveTowards (Target.Pos, anglelimit:TurnRadius, chaseflags:ChaseFlags, KMT_CHASEGOAL);
			}
			
			MovedAlready = True;
		}
		
		If (!(Flags & KAIC_NOTURRETRETARGET)) RetargetVehicleHull(); //If targeting another vehicles' turret. See if targeting the vehicle itself would be better.
		Actor CheckFrom = Turret; //Check from the turret if you should maybe stay still and shoot.
		If (!CheckFrom) CheckFrom = Self; //If you have no turret, check from yourself.
		If (StayStillAndShoot (CheckFrom)) Return;
		
		If (ShouldAttack()) //Run the unique attack decision code of the vehicle.
		{
			AggressionMultiplier = OldAggro; //Reset aggression chance.
			ChaseTimer = 0;
			CorpseTarget = Null;
			Return; //End the function if the vehicle should attack.
		}
		AggressionMultiplier = OldAggro; //Reset aggression chance.
		
		HandleChaseTimer();
	}
	
	//Breakdown of what this does in order:
	/*Makes the vehicle run away from powerful targets. It will run until the enemy is not visible, or it's 4 times further from the enemy than its' retreat distance.
	Once that happens, it will set a temporary delay where it will still run away, before chasing the target again. To not rubberband behind corners.*/
	//When scared, it will also halve the aggression multiplier for KAI_CheckMissileRange().
	//If NOCHASE is off and the vehicle is allowed to move:
		//The vehicle will move away from the nearest enemy if it's within the retreat distance. And the vehicle is not already scared of a powerful enemy or patrolling.
		//If the vehicle has a turret, and the turrets' target is too high for it to shoot it. The vehicle will drive away from it until the turret can shoot it.
		//If the vehicle has no target, isn't patrolling, and is ordered to wander around. It will drive to and crush the nearest corpse. This one makes little sense to port to the KAI since it's so specific.
		//If none of the above are the casse, THEN the vehicle will call normal A_Chase for its' movement.
	//The vehicle will run RetargetVehicleHull() if allowed. Basically check if the target is a vehicle turret, and if I'd be better to target the other vehicle itself.
	//Run the StayStillAndShoot() virtual.
	//Run the ShouldAttack() virtual, which is where the actually attack decision code in the vehicle chase function is handled.
	//Handle the chase timer, which makes the vehicle remove its' target pointer after a set amount of time.
	
	//Generic chase function shared by all vehicles.
	//Flags: Look above for available flags.
	//FollowDist: The distance below which the vehicle will stop trying to follow the player, to not get in their way.
	Void KAI_Chase (Int Flags = 0, Double FollowDist = 384)
	{
		Bool AlreadyRetreating; //The vehicle is already running away from something that doesn't involve the enemy avoiding code, so don't bother to run from nearby enemies.
		Double PowerfulEnemyRetreatRange = (User_RetreatDistance*4)*(User_RetreatDistance*4); //Vehicles stay 4 times further away from powerful enemies than normal ones.
		
		//Temporarily store the values that are changed by the fear code.
		Double OldAggro = AggressionMultiplier;
		
		//Vehicles get scared if they have a living, visible target, and are either defenseless or the target is too powerful.
		If (!bNoFear)
		{
			If (Target && !CanAttack() || Target && IsPowerful (Target) && Distance3DSquared (Target) <= PowerfulEnemyRetreatRange)
				If (!IsDead (Target) && IsVisible(Target, True))
				{
					FearTimer = Random (2,64);
					bFrightened = AlreadyRetreating = True;
				}
				Else
					bFrightened = False;
			Else
				bFrightened = False;
			
			If (FearTimer)
			{
				FearTimer--;
				bFrightened = AlreadyRetreating = True;
			}
			
			If ((Flags & KAIC_ATTACKWHENSCARED) && bFrightened)
				AggressionMultiplier *= 0.5;
		}
		
		If (!(Flags & KAIC_NOCHASE))
		{
			FollowPlayerControl (FollowDist);
			
			//Vehicles try to stay away from enemies that are too close.
			Actor OldTarget;
			If (!(IsPatrolling(Self) && bChaseGoal)) NearestEnemy = FindNearestEnemy (User_RetreatDistance); //Only retreat from enemies if NOT set to patrol AND ignore targets.
			//Have a close enemy, and not already retreating from something like a powerful target.
			If (NearestEnemy && !AlreadyRetreating)
			{
				OldTarget = Target;
				Target = NearestEnemy;
				bFrightened = True;
				FearTimer = Random (2,48);
				//KAI_MoveAway (NearestEnemy,detourfactor:0.5);
				A_Chase (Null,Null,CHF_DONTIDLE | ((Flags & KAIC_NORANDOMTURN) ? CHF_NORANDOMTURN : 0)); //So move away from the nearest enemy.
				Target = OldTarget;
			}
			//If the vehicle turrets' target is too high, move away from it to allow the turret to shoot it.
			Else If (Turret && Turret.Target && Turret.ElevationState == Turret.ELEVATION_TOOHIGH)
			{
				OldTarget = Target;
				Target = Turret.Target;
				bFrightened = True;
				FearTimer = Random (8,32);
				//KAI_MoveAway (Turret.Target,detourfactor:0.5);
				A_Chase (Null,Null,CHF_DONTIDLE | ((Flags & KAIC_NORANDOMTURN) ? CHF_NORANDOMTURN : 0));
				Target = OldTarget;
			}
			//Archvile trolling mode activated.
			Else If (!Target && !IsPatrolling(Self) && !NearestEnemy && CurrentOrder == ORDER_WANDER && (Flags & KAIC_CORPSESEEKER))
			{
				//Don't have a corpse to crush already.
				If (!CorpseTarget)
				{
					CorpseTarget = FindNearestCorpse();
					
					If (!CorpseTarget) //Still no corpse found.
						A_Chase (Null,Null,CHF_DONTIDLE | ((Flags & KAIC_NORANDOMTURN) ? CHF_NORANDOMTURN : 0));
					Else
						KAI_MoveTowards (CorpseTarget.Pos);
				}
				//There is an available corpse to head to and crush.
				Else
					KAI_MoveTowards (CorpseTarget.Pos);
			}
			Else
				A_Chase (Null,Null,CHF_DONTIDLE | ((Flags & KAIC_NORANDOMTURN) ? CHF_NORANDOMTURN : 0));
		}
		
		If (!(Flags & KAIC_NOTURRETRETARGET)) RetargetVehicleHull();
		Actor CheckFrom = Turret;
		If (!CheckFrom) CheckFrom = Self; 
		If (StayStillAndShoot (CheckFrom)) Return;
		
		If (ShouldAttack()) //Run the unique attack decision code of the vehicle.
		{
			AggressionMultiplier = OldAggro; //Reset aggression chance.
			ChaseTimer = 0;
			CorpseTarget = Null;
			Return; //End the function if the vehicle should attack.
		}
		AggressionMultiplier = OldAggro; //Reset aggression chance.
		
		HandleChaseTimer();
	}
	
	Void HandleChaseTimer() //Made into a separate function so it can be called independently by turrets and such.
	{
		//They also eventually stop chasing their target after it's out of sight for long enough.
		If (User_ChaseTime > 0)
		{
			If (ChaseTimer >= User_ChaseTime)
			{
				A_ClearTarget();
				ChaseTimer = 0;
				//Vehicles ordered to stay also go back to standing still once the timer runs out.
				If (CurrentOrder == ORDER_STAY)
				{
					SetStateLabel ("Spawn");
					Return;
				}
			}
			
			If (!IsPatrolling(Self))
			{
				If (!Target || Target && !CheckSight (Target,SF_SEEPASTBLOCKEVERYTHING))
					ChaseTimer++;
				//Target is visible again, reset the timer.
				Else
					ChaseTimer = 0;
			}
		}
	}
	
	//As a friendly vehicle, only follow the player until within a certain distance from them, to prevent the player from being dogpiled by vehicles.
	Void FollowPlayerControl (Double MaxDist = 384)
	{
		If (!PlayerInGame[FriendPlayer] || CurrentOrder == ORDER_WANDER)
			Return;
		
		If (bFriendly)
			bDontFollowPlayers = (Distance3DSquared (Players[FriendPlayer].Mo) <= MaxDist*MaxDist);
	}
	
	//Is the other actor hostile?
	/*NOTE: This is here because the transition of the base vehicle code to my KAI library was kinda rough. Because the MVP vehicles have different criteria
	for if another actor is hostile. I replaced the function in the KAI with a more generic IsTargettingAllies() function and an IsActorHostile() virtual.
	To allow to define different hostility criteria for MVP vehicles than stock KAI actors (And so other modders can do that too I guess).
	As of the time I'm typing this the MVP vehicles' IsActorHostile() runs IsHostile() and IsTargettingAllies() but if potential regressions persist.
	Then I will have them use this function again.*/
	Bool MVP_IsHostile (Actor Caller, Actor Other)
	{
		If (!Caller || !Other) Return False;
		
		If (Caller.bFriendly) //It's as shrimple as that.
			Return Caller.IsHostile (Other);
		//Enemy vehicles are the reason this function exists.
		//They generally don't attack other non-enemy military NPCs. But they will do so if those NPCs are targetting them, or another enemy military NPC.
		Else
		{
			//Non-friendly actors always hate players and their allies.
			If (Other.Player || Other.bFriendly)
				Return True;
			
			//Don't consider own species hostile.
			//If (Caller.bNoInfightSpecies && Caller.Species == Other.Species)
			//	{console.printf ("that's my own species");Return False;} //DEBUG
			
			//Is the other actor targetting you or your turret ?
			If (Other.Target && (Other.Target == Caller || Other.Target == MVP_BaseVehicle(Caller).Turret))
				Return True;
			
			//Is the other actor targetting an actor with the same species as you ? Then they are an enemy as far as you are concerned.
			If (Other.Target && (Caller.bNoInfightSpecies && Caller.Species == Other.Target.Species))
				Return True;
		}
		
		Return False;
	}
	
	//Increase an integer value based on the amount of enemies and how powerful they are, to use for AOE attacks.
	//Probably needs a rewrite in the future, besides being a bit basic. The specific checks for the callers' target are also a little sussy.
	//Range: The range around which to check for enemies.
	//AvoidAllies: Deduct points from the score for any allies in the AOE.
	Int AttackByQuantity (Double Range = 256, Bool AvoidAllies = False)
	{
		Actor Mobj;
		Int Chance;
		Bool IsHostile, IsVisible; //Caching
		
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Self,Range);
		
		While (FindEnemies.Next())
		{
			Mobj = FindEnemies.Thing;
			
			If (IsDead (Mobj) || IsInanimateObject (Mobj) && Mobj == Self) Continue;
			
			IsHostile = IsHostile (Mobj); IsVisible = IsVisible (Mobj,False);
			If (AvoidAllies && !IsHostile && IsVisible)
			{
				If (Mobj.bIsMonster) Chance -= 5;
				If (Mobj.Player) Chance -= 25;
				Continue;
			}
			
			If (Mobj != Target && Mobj.Distance3DSquared (Target) <= Range*Range && IsHostile && IsVisible)
			{
				If (Mobj.Health >= 10)
					Chance += 5;
				Else
					Chance += 1;
				
				If (IsPowerful (Mobj))
					Chance += 25;
			}
		}
		
		Return Chance;
	}
	
	//Death flame handling.
	Array <Actor> DeathFlames; //Pointers to the flames created by the vehicle being gibbed.
	Enum KAIFlameFlags
	{
		FSP_WARNMARINES = 1 << 0, //If any flames are succesfully created around the vehicle, should a marine warning zone be made ?
		FSP_VEHICLEDEATH = 1 << 1 //Mark the warning zone as needing to vanish once all of the flames have evaporated.
	}
	
	//FIXME: Fix a bug where sometimes no flames will spawn, not sure why it happens, but it seems to occur in crammed spaces usually.
	//Creates multiple flames within the bounding box of the vehicle. Used to create flaming wrecks when vehicles are gibbed.
	//Flags: The flags that control the spawning behavior, look at KAIFlameFlags for more info. Default flags are FSP_WARNMARINES and FSP_VEHICLEDEATH.
	//Amount: The random amount of flames that will be created, the X component is the minimum amount of flames, and Y is the maximum.
	//Lifespan: The random lifespan each flame has in tics, the default is 35*30 (30 seconds). The X component is the minimum lifespan a flame can have, and Y is the maximum.
	Void SpawnDeathFlames (Int Flags = FSP_WARNMARINES|FSP_VEHICLEDEATH, Vector2 Amount = (5,12), Vector2 Lifespan = (24*TICRATE,105*TICRATE))
	{
		Int RandomFlames = Random (Int(Amount.X),Int(Amount.Y));
		Actor Flame;
		Vector3 SpawnPos;
		//Spawn a random amount of flames around the APC wreck.
		For (Int I = 0; I < RandomFlames; I++)
		{
			SpawnPos = (FRandom (-Radius*1.75,Radius*1.75),FRandom (-Radius,Radius),0);
			SpawnPos.Z = GetZAt (SpawnPos.X,SpawnPos.Y) + 8 + FRandom (0, Height - 8);
			//If the random position relative to the vehicle is valid.
			If (Level.IsPointInLevel (Vec3Offset(SpawnPos.X,SpawnPos.Y,SpawnPos.Z)))
				Flame = Spawn ("MVP_Flame",Vec3Offset(SpawnPos.X,SpawnPos.Y,SpawnPos.Z)); //Then spawn the flame.
			
			If (Flame)
			{
				Flame.Master = Self; //So the flame knows what actor to warp to.
				MVP_Flame(Flame).Offsets = SpawnPos;
				Flame.ReactionTime = Int(FRandom (Lifespan.X,LifeSpan.Y));
				DeathFlames.Push (Flame); //Add the valid flame to the list.
			}
		}
		
		//Clean up the null entries in the array.
		For (Int I = DeathFlames.Size()-1; I >= 0; I--)
			If (!DeathFlames[I]) DeathFlames.Delete(I); //Remove null entries.
		
		//Create a warning zone if any flames actually spawned.
		If (Flags & FSP_WARNMARINES && DeathFlames.Size())
			If (Flags & FSP_VEHICLEDEATH)
				DeathWarnZone = WarnMarines (MWRN_WARP|MWRN_ALLIESTOO|MWRN_VEHICLEDEATH,Radius*1.75+48,towho:Self);
			Else
				DeathWarnZone = WarnMarines (MWRN_WARP|MWRN_ALLIESTOO,Radius*1.75+48,towho:Self);
	}
}

//A generic check used to find where a projectile will roughly land, to place a warning zone for marines there.
//This is here because KAI projectiles usually go through allies.
Class MVP_GenericWarnMarineCheck : KAI_LOFRaycast
{
	Int BlockMode; //Works like the variable in KAI_LOFActorFinder.
	Override ETraceStatus TraceCallback()
	{
		Actor Mobj = Results.HitActor;
		
		//Standard KAI projectiles go through allies.
		If (Mobj && (IsInanimateObject (Mobj) || Shooter && IsHostile (Shooter,Mobj)))
			Return Trace_Stop;
		
		//The trace specifically hit a projectile blocking line. e.g a window linedef or a polyobject.
		If (Results.HitLine && Results.HitLine.Flags & Line.ML_BLOCKEVERYTHING || BlockMode != 0 && BlockingLineInTheWay (Results.HitLine,BlockMode))
			Return Trace_Stop;
		
		//Level geometry is in the way.
		If (HitLevelGeometry (Results))
			Return Trace_Stop;
		
		Return Trace_Skip;
	}
}
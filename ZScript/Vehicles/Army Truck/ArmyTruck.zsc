Class MVP_ArmyTruck : MVP_BaseVehicle
{
	Default
	{
		//$Title Army Truck
		//$Category Vehicles/Army Truck
		//$Sprite TRK1A1
		Health 1000;
		GibHealth 300;
		XScale 0.65;
		YScale 0.541666; //0.65 / 1.2
		Height 96;
		Radius 72;
		DeathHeight 88;
		Mass 22000;
		Speed 12;
		FastSpeed 18;
		RipLevelMin 2;
		
		Obituary "%o was ran over by a truck.";
		Tag "Army Truck";
		DamageFactor "Melee", 0.4;
		DamageFactor "Electric", 0.3;
		DamageFactor "ExplosiveImpact", 0.9;
		DamageFactor "Explosion", 0.9;
		DamageFactor "HitScan", 0.9; //The generic damage type of hitscan attacks.
		//Damage factors specific to the Smart Marines.
		DamageFactor "MarineHMG", 0.9;
		DamageFactor "MarineGrenade", 1.5;
		DamageFactor "MarineRifle", 0.9;
		
		+MVP_BaseVehicle.Transport; //Carries soldiers.
		+NoExtremeDeath; //So the truck doesn't gib enemies it runs over.
	}
	
	Override Void UserVariableDefaults()
	{
		If (User_MarineAmount == 0) User_MarineAmount = 14;
		If (User_RetreatDistance == 0) User_RetreatDistance = 1024;
		Super.UserVariableDefaults();
	}
	
	Override Void Tick()
	{
		Super.Tick ();
		
		If (IsFrozen()) Return;
		
		If (DeployTimer) DeployTimer--;
	}
	
	Override Void PostBeginPlay ()
	{
		Super.PostBeginPlay();
		
		SpawnArmyTruckHeadlights();
	}
	
	Override String GetObituary (Actor Victim, Actor Inflictor, Name MOD, Bool PlayerAttack)
	{
		String MeleeObituaries[] = {
		"%o was ran over by a truck.",
		"%o forgot to check both sides of the road before crossing.",
		"%o was visited by truck-kun.",
		"%o is really bad at bullfighting.",
		"A trucks' passion was more than %o's heart could withstand."};
		
		If (MOD == 'Melee')
			Return MeleeObituaries [Random (0,MeleeObituaries.Size() - 1)];
		
		Return Super.GetObituary (Victim, Inflictor, MOD, PlayerAttack);
	}
	
	//https://www.youtube.com/watch?v=J9FImc2LOr8
	Override Bool Slam (Actor Victim)
	{
		If (!Victim)
			Return True;
		
		If (Victim.bMissile) //Use normal collision behavior for unpushable actors and projectiles.
			Return False;
		
		//Make the truck able to climb over really short actors.
		If (IsInanimateObject (Victim) && Victim.bSolid && (Victim.Pos.Z + Victim.Height - Pos.Z <= MaxStepHeight/4))
			SetOrigin ((Pos.X,Pos.Y,Victim.Pos.Z+Victim.Height),True);
		
		//Allows both friends and enemies to be pushed out of the way, while only damaging enemies.
		If (IsThrustable (Victim))
			FlingActor (Victim,Vel.XY.Length(),True);console.printf ("i have hit a %s",Victim.getclassname());
		
		If ((IsHostile(Victim) || IsInanimateObject (Victim)))
		{
			Victim.DamageMobj (Self,Self,Random (30,40)*Clamp(Vel.XY.Length(),0.1,INT.MAX),'Melee',angle:Angle); //Isekai the enemy.
			
			console.printf ("vel is %f",vel.length());
			//Black box, no idea how to alter it to decrease/increase how much the truck is slowed down when ramming.
			Double Mul = LinearMap(Victim.Mass, 1000, 100, 0.0, 1.0);
			Mul = Clamp(Mul, 0.0, 1.0);
			Vel *= Mul;console.printf ("vel is now %f",vel.length());
			
			//Stop ramming if you've hit a powerful enemy,  or one that shouldn't be pushed.
			//Maybe change this in the future to have the truck stop only if it hit a VERY powerful enemy ?
			If (IsPowerful (Victim) || !IsThrustable (Victim) && IsIndestructible (Victim))
			{a_log ("i need to stop");
				HitThings.Clear();
				TotalMassHit = 0;
				CancelCharge = True;
				Return False; //Powerful actor has been hit.
			}
			
			//Add the object you've hit to the counter IF IT ISN'T IN ALREADY !
			If (!HasBeenHitBefore(Victim))
			{
				TotalMassHit += Victim.Mass;console.printf ("total mass is now %d",totalmasshit);
				If (Random (0,512) < 2 && !(Victim.Player || Victim Is "PlayerPawn"))
				{
					Victim.Die (Self,Self,0,'Melee'); //Used to call the actors' specials before they get their own harem.
					Spawn (Victim.TeleFogSourceType,Victim.Pos,ALLOW_REPLACE);
					Victim.Destroy();
				}
				Else
					HitThings.Push (Victim);
				a_log ("this is a new and unique smacking experience");

				Return True; //Continue ramming.
			}
			
			Return True;
		}
		
		Return False;
	}
	
	//https://github.com/ZDoom/gzdoom/blob/18a67cfdb28b8c43898eeb92b6075bfc5ac4e6c1/src/playsim/p_interaction.cpp#L1108
	Override Int DamageMobj (Actor Inflictor, Actor Source, Int Damage, Name MOD, Int Flags, Double Angle)
	{
		If (bSkullFly)
		{
			Vector3 OldVel = Vel;
			Int Dmg = Super.DamageMobj (Inflictor, Source, Damage, MOD, Flags, Angle);
			Vel = OldVel;
			
			Return Dmg;
		}
		
		Return Super.DamageMobj (Inflictor, Source, Damage, MOD, Flags, Angle);
	}
	
	Override Void OnDestroy()
	{
		Super.OnDestroy();
		
		If (WarningZone)
			WarningZone.Destroy();
	}
	
	Override Void Die (Actor Source, Actor Inflictor, Int DmgFlags, Name MeansOfDeath)
	{
		If (WarningZone)
			WarningZone.Destroy();
		
		Super.Die (Source, Inflictor, DmgFlags, MeansOfDeath);
	}
	
	Bool CanAttack()
	{
		Return (User_MarineAmount > 0 || User_Ramming);
	}
	
	Bool IsThrustable (Actor Other)
	{
		Return (!Other.bDontThrust && !Other.bDontBlast);
	}
	
	Bool ChargePathClear (Bool HostileOnly = False)
	{
		FLineTraceData Result;
		Actor Mobj;
		/*Bool LeftWall, RightWall; //Don't actually know which one is which lol.
		
		//First check if any corner of the hitbox would get stuck in level geometry.
		LineTrace (AngleTo (Target),256,PitchTo (Target),TRF_BLOCKSELF|TRF_THRUACTORS,Height/2,offsetside:Radius,data:Result);
		//spawn ("techlamp",result.hitlocation);
		If (Result.HitType == TRACE_HITWALL)
			LeftWall = True;
		
		LineTrace (AngleTo (Target),256,PitchTo (Target),TRF_BLOCKSELF|TRF_THRUACTORS,Height/2,offsetside:-Radius,data:Result);
		//spawn ("techlamp",result.hitlocation);
		If (Result.HitType == TRACE_HITWALL)
			RightWall = True;
		
		//If only one of the walls is blocked and the other isn't, instead of either both or neither of them being blocked.
		If ((!LeftWall && RightWall) || (LeftWall && !RightWall))
			Return False; //Then you are probably just about to repeatedly hit a corner, so don't ram.
		//=========================================================================
		*/
		If (!Target) Return False;
		LineTrace (AngleTo (Target),MaxTargetRange,PitchTo (Target),TRF_THRUHITSCAN|TRF_SOLIDACTORS,Height/2,data:Result);
		Mobj = Result.HitActor;
		
		If (!Mobj || Mobj == Self) Return False; //Can't even find the target. Or the raycast hit yourself
		
		If (!(Mobj.Pos.Z + Mobj.Height > Pos.Z && Mobj.Pos.Z + Mobj.Height < Pos.Z + Height)) Return False; //Actor is too high or low from the truck.
		
		If (IsHostile (Mobj)) {/*a_log ("hit enemy, good");*/Return True;} //Enemy in the way.
		
		If (HostileOnly) Return False;
		
		If (Result.HitLine || !Mobj) {a_log ("hit a line");Return False;} //A line is in the way, or this attempted charge won't even hit any actor.
		
		If (!IsIndestructible (Mobj) && IsInanimateObject (Mobj) && Mobj.Health <= 500 && IsThrustable (Mobj)) {a_log ("prop hunt 2");Return True;} //Calling this means the truck is already aimed at a target, and if only a (Relatively) weak destructible prop is in the way, then charge anyway.
		
		If (IsIndestructible (Mobj) && !IsThrustable (Mobj)) {a_log ("movable object versus stoppable force");Return False;} //Hit an unpushable object, or rather, one that shouldn't be flung around.
		
		a_log ("ramming anyway");
		Return True;
	}
	
	Bool FlingPathClear (Actor Other)
	{
		FLineTraceData Result;
		
		LineTrace (AngleTo (Other),MaxTargetRange,PitchTo (Other),TRF_THRUHITSCAN|TRF_SOLIDACTORS,Height/2,data:Result);
		
		If (Result.HitActor && Result.HitActor == Other) Return True;
		
		Return False;
	}
	
	//Checks if the specified object is already in the HitThings array, meaning that the truck has already hit it before, this prevents the vehicle from counting multiple hits on the same actor.
	Bool HasBeenHitBefore (Actor Other)
	{
		If (!Other) {a_log ("is THIS causing the bug ?");Return False;}
		
		For (Int I = HitThings.Size()-1; 0 <= I; I--)
			If (HitThings[I] == Other)
				{Return True;a_log ("been there, done that");} //This actor is already in the list.
		a_log ("this is a new one");
		Return False;
	}
	
	Int User_MarineAmount; //The amount of marines still in the truck.
	Bool User_Ramming; //Should the truck run shit over ?
	
	Actor NearestEnemy; //The enemy closest to the truck, if any.
	Bool AlreadyRetreating; //The truck is already running away from something that doesn't involve the enemy avoiding code, so don't call the enemy avoiding code.
	Int FearTimer; //Makes the truck keep running away from it's target for an additional random amount of time, so the truck doesn't play peekaboo with enemies.
	Int ChaseTimer; //Makes the truck only chase its' target for a certain amount of time after it goes out of sight.
	Int MarinesToSpawn; //How many marines the truck should drop this time that it opened up.
	Int DeployTimer; //Adds a delay until the next time the truck is able to drop marines again.
	
	//Variables relating to the ramming attack.
	Array <Actor> HitThings; //How many things the truck has hit before stoping. Should probably replace this with a counter that adds the combine mas of everything the truck has hit.
	Actor WarningZone; //Spawns the warning zone when the car is charging, to get marines out of the way.
	Int TotalMassHit; //Adds up the mass of everything the truck has hit, causing it to stop ramming once this value has reached a certain threshold.
	Bool CancelCharge; //Tells the code on the Charge state to cancel the ramming.
	States
	{
		Spawn:
			TRK1 A 4
			{
				A_StopSound (CHAN_MOVING);
				A_StartSound("Vehicle/ArmyTruck/Idle",CHAN_IDLING,CHANF_LOOPING,attenuation:0.6);
				A_LookEx (0,0,8192,3072);
			}
			Loop;
		See:
			TRK1 AABBCCDD 2
			{
				/*//If the truck was prematurely put back to see by hitting an actor (Because that's default SKULLFLY behavior.)
				If ((TotalMassHit || HitThings.Size()-1) > 0)
				{
					bSkullFly = True;
					Return ResolveState ("ChargeLoop"); //Then go back to ramming.
				}*/
				
				A_StopSound (CHAN_IDLING);
				A_StartSound ("Vehicle/ArmyTruck/Moving",CHAN_MOVING,CHANF_LOOPING,attenuation:0.6);
				
				//Defenseless, or the target is powerful.
				If (Target && !CanAttack() || Target && IsPowerful (Target))
					If (!IsDead (Target) && IsVisible(Target, True))
					{a_log ("bring my brown pants");
						FearTimer = Random (2,64);
						bFrightened = AlreadyRetreating = True;
					}
					Else
						bFrightened = False;
				Else
					bFrightened = False;
				
				If (FearTimer)
				{
					FearTimer--;
					bFrightened = AlreadyRetreating = True;
				}
				
				FollowPlayerControl(512);
				
				Actor OldTarget;
				NearestEnemy = FindNearestEnemy (!CanAttack() ? User_RetreatDistance : User_RetreatDistance*0.75);
				If (!NearestEnemy || IsPatrolling())
					A_Chase (Null,Null,CHF_DONTIDLE | (((!Target || !User_MarineAmount) && !IsPatrolling()) ? CHF_NORANDOMTURN : 0));
				//Run away from the nearest enemy, unless you were already running away before.
				Else If (NearestEnemy && !AlreadyRetreating)
				{
					OldTarget = Target;
					Target = NearestEnemy;
					bFrightened = True;
					FearTimer = Random (2,48);a_log ("run away");
					A_Chase (Null,Null,CHF_DONTIDLE | (((!Target || !User_MarineAmount) && !IsPatrolling()) ? CHF_NORANDOMTURN : 0));
					Target = OldTarget;
				}
				Else
					A_Chase (Null,Null,CHF_DONTIDLE | (((!Target || !User_MarineAmount) && !IsPatrolling()) ? CHF_NORANDOMTURN : 0));
				
				If (Health <= SpawnHealth()/4)
					bMissileMore = bMissileEvenMore = True;
				
				If (CheckMissileRange() && Target != Goal && !(IsPatrolling() && bChaseGoal))
				{
					If (User_MarineAmount > 0 && DeployTimer <= 0)
						Return ResolveState ("DeployMarines");
					
					//Ramming decision code.
					If (User_Ramming && ChargePathClear())
					{
						//If your health is very low and you have no marines left inside.
						If (Health <= SpawnHealth()/4 && User_MarineAmount <= 0)
						{
							If (Random[pr_cajump](0,255) < 64) //Then be a lot more likely to ram enemies.
								Return ResolveState ("Charge");
						}
						//If your health isn't critically low but you have no marines inside.
						Else If (!(Health <= SpawnHealth()/4) && User_MarineAmount <= 0)
						{
							If (Random[pr_cajump](0,255) < 24) //Then be a more likely to ram enemies.
								Return ResolveState ("Charge");
						}/*
						//If your health isn't critical, and you still have marines.
						Else
						{
							If (Random[pr_cajump](0,512) < 2) //Then only rarely ram enemies.
								Return ResolveState ("Charge");
						}*/
					}
				}
				
				//Code that makes the truck eventually stop chasing its' target.
				If (User_ChaseTime > 0)
				{
					If (ChaseTimer >= User_ChaseTime)
					{
						A_ClearTarget();
						ChaseTimer = 0;
					}
					
					If (Target && !IsPatrolling())
					{
						If (!CheckSight (Target,SF_SEEPASTBLOCKEVERYTHING))
							ChaseTimer++;
						//Target is visible again, reset the timer.
						Else
							ChaseTimer = 0;
					}
				}
				
				bFrightened = AlreadyRetreating = bMissileMore = bMissileEvenMore = False;
				OldTarget = NearestEnemy = Null;
				
				Return State (Null);
			}
			Loop;
		//The trucks' marine deploying loop.
		DeployMarines:
			TNT1 A 0 A_JumpIf (User_MarineAmount <= 0,"See"); //No marines to drop.
			TNT1 A 0 //Temporarily make the truck bigger, to see if any of the marines would get stuck anywhere.
			{
				A_SetSize (Radius*1.25);
				
				If (!TestMobjLocation()) //If they would be stuck, cancel the drop.
				{a_log ("spawn check");
					A_SetSize (Default.Radius);
					Return ResolveState ("See");
				}
				
				A_SetSize (Default.Radius);
				
				Return State (Null);
			}
			TRK1 E Random (10,16) A_StartSound ("Vehicle/ArmyTruck/BackOpen",attenuation:0.8);
			TRK1 F 6;
			TRK1 G 4 A_StartSound ("Vehicle/ArmyTruck/BackSlam",attenuation:0.8);
			TRK1 G Random (8,12) {MarinesToSpawn = Random (3,5);}
			SpawnLoop:
				TRK1 G 0 A_JumpIf (User_MarineAmount <= 0,"EndDeploy");
				TRK1 G 0 A_JumpIf (MarinesToSpawn <= 0,"EndDeploy");
				TRK1 G 35 {If (Health <= SpawnHealth()/4) Tics = 35/2;} //Smaller spawn interval when about to die.
				TRK1 G 0
				{
					Actor Marine;
					a_log ("spawning a marine");a_logint (marinestospawn);
					Marine = SpawnMarine ((-128, FRandom (16,-16)));
					Marine.SetOrigin ((Marine.Pos.X,Marine.Pos.Y,Marine.Pos.Z+48),False);
					WarnSpecificMarine (Marine); //Get the marine out of the way, so they don't get stuck on each other.
					MarinesToSpawn--;
					User_MarineAmount--;
				}
				Loop;
			EndDeploy:
				TRK1 G 12 A_StartSound ("Vehicle/ArmyTruck/BackOpen",attenuation:0.8);
				TRK1 F 6;
				TRK1 E 4 A_StartSound ("Vehicle/ArmyTruck/BackSlam",attenuation:0.8);
				TRK1 E 0
				{
					If (!(Health <= SpawnHealth()/4))
						DeployTimer = Random (2,7)*35;
					Else
						DeployTimer = Random (1,3)*35; //Have a smaller delay if about to die, and you still have troops.
				}
				Goto See;
		Charge:
			TRK1 A 0
			{
				//Go back to See if the path to the target is covered, or there is no target. This is here in case the state is entered using a scripted ACS event.
				If (!ChargePathClear() || !Target)
				{	a_log ("the coast isn't clear");Return ResolveState ("See");}
				
				bSkullFly = True; //Stupid hack.
				bSlidesOnWalls = True;
				A_FaceTarget ();
				VelFromAngle (14);
				ChaseTimer = 0; //Just in case.
				WarningZone = WarnMarines (512,True,False);
				If (WarningZone)
					WarningZone.Master = Self;
				
				Return State (Null);
			}
		ChargeLoop:
			TRK1 AAABBBCCCDDD 1
			{
				//You no longer have a target to ram, or it has died.
				If (!Target || Target && IsDead (Target))
				{
					ChaseTimer = 0;
					A_ClearTarget();
					LookForPlayers(False); //Look for a new target.
				}
				
				//Look for a new target if the current one has gone out of sight for too long.
				If (Target)
				{
					If (!CheckSight (Target))
						ChaseTimer++;
					Else
						ChaseTimer = 0;
					
					If (ChaseTimer >= 35/3)
					{
						ChaseTimer = 0;
						A_ClearTarget();
						LookForPlayers(False); //Look for a new target.
					}
				}
				
				A_Recoil (-2.25);
				//Speed limit.
				If (Vel.XY.Length() >= 14.0)
					Vel.XY = Vel.XY.Unit() * Clamp (Vel.XY.Length(),0.0,14.0);
				A_FaceTarget (2.4);
				
				//You've hit enough mass worth of objects. Or you have no target even after the search above.
				If (TotalMassHit >= 10000 || !Target || CancelCharge)
				{if (!cancelcharge)a_log ("hit all the things"); else a_log ("no more charging");
					HitThings.Clear();
					TotalMassHit = 0;
					bSkullFly = bSlidesOnWalls = CancelCharge = False;a_log ("time to take a brake");
					If (WarningZone)
						WarningZone.Destroy();
					Return ResolveState ("Brake");
				}
				
				If (BlockingLine && !CheckMove (Vec2Angle (Vel.XY.Length(),Angle),PCM_NOACTORS))
				{
					//No idea if this even works as intended, can't even playtest it, since destructible geometry is totally undocumented lol.
					Destructible.DamageLinedef (BlockingLine,Self,Random (30,40)*Clamp(Vel.XY.Length(),0.1,INT.MAX),'Melee',0,Pos,False);
					HitThings.Clear();
					TotalMassHit = 0;
					bSkullFly = bSlidesOnWalls = CancelCharge = False;
					If (WarningZone)
						WarningZone.Destroy();
					Return ResolveState ("See");
				}
				
				//The truck will hit level geometry instead.
				If (!ChargePathClear (True) && !CheckMove (Vec2Angle (280,Angle),PCM_NOACTORS))
				{a_log ("incoming level geometry");
					HitThings.Clear();
					TotalMassHit = 0;
					bSkullFly = bSlidesOnWalls = CancelCharge = False;
					If (WarningZone)
						WarningZone.Destroy();
					Return ResolveState ("Brake");
				}
				
				Return State (Null);
			}
			Loop;
		Brake: //Braking Bad
			TRK1 # 1
			{
				Friction = 1.5;
				A_StartSound ("Vehicle/ArmyTruck/Brake",CHAN_MOVING,CHANF_LOOPING,attenuation:0.7);
				
				If (Pos.Z <= FloorZ) //Only brake (bad) while on the floor.
					Vel.XY *= 0.98;
				console.printf ("the speed is now %f",vel.xy.length());
				If (Vel.XY.Length() <= 4.5) //Go back to see once the velocity is low enough again.
				{a_log ("im slow enough now");
					A_StopSound (CHAN_MOVING);
					Friction = Default.Friction;
					Return ResolveState ("See");
				}
				
				A_SpawnItemEx ("MVP_TruckWheelSmoke",-128,20);
				A_SpawnItemEx ("MVP_TruckWheelSmoke",-128,-20);
				
				Return State (Null);
			}
			Loop;
		Death:
			TRK1 H 7 Bright
			{
				A_Explode (384,256,XF_HURTSOURCE|XF_EXPLICITDAMAGETYPE,True,damagetype:'Explosion');
				A_StartSound ("SFX/Explosion",CHAN_BODY,attenuation:0.5);
				A_StopSound (CHAN_IDLING);
				A_StopSound (CHAN_MOVING);
				
				A_SpawnItemEx ("MVP_ArmyTruckPipe",72,-16,60,FRandom (6,-6),FRandom (6,-6),FRandom (24,32));
				A_SpawnItemEx ("MVP_ArmyTruckWheel",72,8,60,FRandom (8,-8),FRandom (8,-8),FRandom (24,32));
				A_SpawnItemEx ("MVP_ArmyTruckBackDoor",-136,0,48,FRandom (-16,-32),FRandom (4,-4),FRandom (-2,16));
			}
			TRK1 IJ 7 Bright;
			TRK1 KL 7 Bright;
			TRK1 M -1;
			Stop;
		XDeath:
			TRK1 N 0
			{
				Int RandomFlames; RandomFlames = Random (5,12);
				Actor Flame;
				Actor Boom;
				Vector3 SpawnPos;
				
				Height = 70;
				
				Boom = Spawn ("MVP_BigExplosion",Pos);
				Boom.MaxTargetRange = 384;
				Boom.MeleeRange = 128;
				Boom.SetDamage(384);
				Boom.A_SetScale (2.0);
				
				A_QuakeEx (1,1,1,35*2,0,1024,flags:QF_3D|QF_SCALEDOWN);
				//Spawn a random amount of flames around the truck wreck.
				For (Int I = 0; I < RandomFlames; I++)
				{
					SpawnPos = (FRandom (-Radius*1.75,Radius*1.75),FRandom (-Radius,Radius),0);
					SpawnPos.Z = GetZAt (SpawnPos.X,SpawnPos.Y);
					Flame = Spawn ("MVP_Flame",SpawnPos); //So is the flame actor.
					
					If (Flame)
					{
						If (!Level.IsPointInLevel (Flame.Pos))
							Flame.Destroy();
						
						If (Flame)
						{
							Flame.Master = Self;
							MVP_Flame(Flame).Offsets = SpawnPos;
							Flame.ReactionTime *= FRandom (0.8,3.5);
						}
					}
				}
			}
			TRK1 N -1;
			Stop;
	}
}